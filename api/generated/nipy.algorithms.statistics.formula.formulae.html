

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Selection &mdash; Selection Documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />


</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html">
          

          
            
            <img src="../../_static/logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../docattribute.html">Selection documentation attribution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../algorithms/index.html">Non-randomized algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../randomized/index.html">Randomized algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../learning/index.html">Learning selection</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../documentation.html">Selection documentation</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">selection</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
      <li>Selection</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/api/generated/nipy.algorithms.statistics.formula.formulae.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast,
.nboutput.nblast {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast + .nbinput {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="algorithms-statistics-formula-formulae">
<h1>algorithms.statistics.formula.formulae<a class="headerlink" href="#algorithms-statistics-formula-formulae" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-algorithms-statistics-formula-formulae">
<h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">algorithms.statistics.formula.formulae</span></code><a class="headerlink" href="#module-algorithms-statistics-formula-formulae" title="Permalink to this headline">¶</a></h2>
<p>Inheritance diagram for <code class="docutils literal notranslate"><span class="pre">nipy.algorithms.statistics.formula.formulae</span></code>:</p>
digraph inheritance6435da5321 {
rankdir=LR;
size=&quot;8.0, 12.0&quot;;
  &quot;core.basic.Atom&quot; [fontname=&quot;Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans&quot;,fontsize=10,height=0.25,shape=box,style=&quot;setlinewidth(0.5)&quot;,tooltip=&quot;A parent class for atomic things. An atom is an expression with no subexpressions.&quot;];
  &quot;core.basic.Basic&quot; -&gt; &quot;core.basic.Atom&quot; [arrowsize=0.5,style=&quot;setlinewidth(0.5)&quot;];
  &quot;core.basic.Basic&quot; [fontname=&quot;Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans&quot;,fontsize=10,height=0.25,shape=box,style=&quot;setlinewidth(0.5)&quot;,tooltip=&quot;Base class for all objects in SymPy.&quot;];
  &quot;core.evalf.EvalfMixin&quot; [fontname=&quot;Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans&quot;,fontsize=10,height=0.25,shape=box,style=&quot;setlinewidth(0.5)&quot;,tooltip=&quot;Mixin class adding evalf capabililty.&quot;];
  &quot;core.expr.AtomicExpr&quot; [fontname=&quot;Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans&quot;,fontsize=10,height=0.25,shape=box,style=&quot;setlinewidth(0.5)&quot;,tooltip=&quot;A parent class for object which are both atoms and Exprs.&quot;];
  &quot;core.basic.Atom&quot; -&gt; &quot;core.expr.AtomicExpr&quot; [arrowsize=0.5,style=&quot;setlinewidth(0.5)&quot;];
  &quot;core.expr.Expr&quot; -&gt; &quot;core.expr.AtomicExpr&quot; [arrowsize=0.5,style=&quot;setlinewidth(0.5)&quot;];
  &quot;core.expr.Expr&quot; [fontname=&quot;Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans&quot;,fontsize=10,height=0.25,shape=box,style=&quot;setlinewidth(0.5)&quot;,tooltip=&quot;Base class for algebraic expressions.&quot;];
  &quot;core.basic.Basic&quot; -&gt; &quot;core.expr.Expr&quot; [arrowsize=0.5,style=&quot;setlinewidth(0.5)&quot;];
  &quot;core.evalf.EvalfMixin&quot; -&gt; &quot;core.expr.Expr&quot; [arrowsize=0.5,style=&quot;setlinewidth(0.5)&quot;];
  &quot;core.symbol.Dummy&quot; [fontname=&quot;Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans&quot;,fontsize=10,height=0.25,shape=box,style=&quot;setlinewidth(0.5)&quot;,tooltip=&quot;Dummy symbols are each unique, even if they have the same name:&quot;];
  &quot;core.symbol.Symbol&quot; -&gt; &quot;core.symbol.Dummy&quot; [arrowsize=0.5,style=&quot;setlinewidth(0.5)&quot;];
  &quot;core.symbol.Symbol&quot; [fontname=&quot;Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans&quot;,fontsize=10,height=0.25,shape=box,style=&quot;setlinewidth(0.5)&quot;,tooltip=&quot;Assumptions:&quot;];
  &quot;core.expr.AtomicExpr&quot; -&gt; &quot;core.symbol.Symbol&quot; [arrowsize=0.5,style=&quot;setlinewidth(0.5)&quot;];
  &quot;logic.boolalg.Boolean&quot; -&gt; &quot;core.symbol.Symbol&quot; [arrowsize=0.5,style=&quot;setlinewidth(0.5)&quot;];
  &quot;formula.formulae.Beta&quot; [URL=&quot;#nipy.algorithms.statistics.formula.formulae.Beta&quot;,fontname=&quot;Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans&quot;,fontsize=10,height=0.25,shape=box,style=&quot;setlinewidth(0.5)&quot;,target=&quot;_top&quot;,tooltip=&quot;A symbol tied to a Term `term`&quot;];
  &quot;core.symbol.Dummy&quot; -&gt; &quot;formula.formulae.Beta&quot; [arrowsize=0.5,style=&quot;setlinewidth(0.5)&quot;];
  &quot;formula.formulae.Factor&quot; [URL=&quot;#nipy.algorithms.statistics.formula.formulae.Factor&quot;,fontname=&quot;Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans&quot;,fontsize=10,height=0.25,shape=box,style=&quot;setlinewidth(0.5)&quot;,target=&quot;_top&quot;,tooltip=&quot;A qualitative variable in a regression model&quot;];
  &quot;formula.formulae.Formula&quot; -&gt; &quot;formula.formulae.Factor&quot; [arrowsize=0.5,style=&quot;setlinewidth(0.5)&quot;];
  &quot;formula.formulae.FactorTerm&quot; [URL=&quot;#nipy.algorithms.statistics.formula.formulae.FactorTerm&quot;,fontname=&quot;Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans&quot;,fontsize=10,height=0.25,shape=box,style=&quot;setlinewidth(0.5)&quot;,target=&quot;_top&quot;,tooltip=&quot;Boolean Term derived from a Factor.&quot;];
  &quot;formula.formulae.Term&quot; -&gt; &quot;formula.formulae.FactorTerm&quot; [arrowsize=0.5,style=&quot;setlinewidth(0.5)&quot;];
  &quot;formula.formulae.Formula&quot; [URL=&quot;#nipy.algorithms.statistics.formula.formulae.Formula&quot;,fontname=&quot;Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans&quot;,fontsize=10,height=0.25,shape=box,style=&quot;setlinewidth(0.5)&quot;,target=&quot;_top&quot;,tooltip=&quot;A Formula is a model for a mean in a regression model.&quot;];
  &quot;formula.formulae.RandomEffects&quot; [URL=&quot;#nipy.algorithms.statistics.formula.formulae.RandomEffects&quot;,fontname=&quot;Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans&quot;,fontsize=10,height=0.25,shape=box,style=&quot;setlinewidth(0.5)&quot;,target=&quot;_top&quot;,tooltip=&quot;Covariance matrices for common random effects analyses.&quot;];
  &quot;formula.formulae.Formula&quot; -&gt; &quot;formula.formulae.RandomEffects&quot; [arrowsize=0.5,style=&quot;setlinewidth(0.5)&quot;];
  &quot;formula.formulae.Term&quot; [URL=&quot;#nipy.algorithms.statistics.formula.formulae.Term&quot;,fontname=&quot;Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans&quot;,fontsize=10,height=0.25,shape=box,style=&quot;setlinewidth(0.5)&quot;,target=&quot;_top&quot;,tooltip=&quot;A sympy.Symbol type to represent a term an a regression model&quot;];
  &quot;core.symbol.Symbol&quot; -&gt; &quot;formula.formulae.Term&quot; [arrowsize=0.5,style=&quot;setlinewidth(0.5)&quot;];
  &quot;logic.boolalg.Boolean&quot; [fontname=&quot;Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans&quot;,fontsize=10,height=0.25,shape=box,style=&quot;setlinewidth(0.5)&quot;,tooltip=&quot;A boolean object is an object for which logic operations make sense.&quot;];
  &quot;core.basic.Basic&quot; -&gt; &quot;logic.boolalg.Boolean&quot; [arrowsize=0.5,style=&quot;setlinewidth(0.5)&quot;];
}
<span class="target" id="module-nipy.algorithms.statistics.formula.formulae"></span><div class="section" id="formula-objects">
<h3>Formula objects<a class="headerlink" href="#formula-objects" title="Permalink to this headline">¶</a></h3>
<p>A formula is basically a sympy expression for the mean of something of
the form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mean</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">Beta</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">*</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">expr</span><span class="p">])</span>
</pre></div>
</div>
<p>Or, a linear combination of sympy expressions, with each one multiplied
by its own “Beta”. The elements of expr can be instances of Term (for a
linear regression formula, they would all be instances of Term). But, in
general, there might be some other parameters (i.e. sympy.Symbol
instances) that are not Terms.</p>
<p>The design matrix is made up of columns that are the derivatives of mean
with respect to everything that is not a Term, evaluted at a recarray
that has field names given by [str(t) for t in self.terms].</p>
<p>For those familiar with R’s formula syntax, if we wanted a design matrix
like the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">table</span> <span class="o">=</span> <span class="n">read</span><span class="o">.</span><span class="n">table</span><span class="p">(</span><span class="s2">&quot;http://www-stat.stanford.edu/~jtaylo/courses/stats191/data/supervisor.table&quot;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">T</span><span class="p">)</span>
<span class="o">&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">lm</span><span class="p">(</span><span class="n">Y</span> <span class="o">~</span> <span class="n">X1</span><span class="o">*</span><span class="n">X3</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">table</span><span class="p">)</span>
<span class="p">)</span>
<span class="o">&gt;</span> <span class="n">d</span>
   <span class="p">(</span><span class="n">Intercept</span><span class="p">)</span> <span class="n">X1</span> <span class="n">X3</span> <span class="n">X1</span><span class="p">:</span><span class="n">X3</span>
<span class="mi">1</span>            <span class="mi">1</span> <span class="mi">51</span> <span class="mi">39</span>  <span class="mi">1989</span>
<span class="mi">2</span>            <span class="mi">1</span> <span class="mi">64</span> <span class="mi">54</span>  <span class="mi">3456</span>
<span class="mi">3</span>            <span class="mi">1</span> <span class="mi">70</span> <span class="mi">69</span>  <span class="mi">4830</span>
<span class="mi">4</span>            <span class="mi">1</span> <span class="mi">63</span> <span class="mi">47</span>  <span class="mi">2961</span>
<span class="mi">5</span>            <span class="mi">1</span> <span class="mi">78</span> <span class="mi">66</span>  <span class="mi">5148</span>
<span class="mi">6</span>            <span class="mi">1</span> <span class="mi">55</span> <span class="mi">44</span>  <span class="mi">2420</span>
<span class="mi">7</span>            <span class="mi">1</span> <span class="mi">67</span> <span class="mi">56</span>  <span class="mi">3752</span>
<span class="mi">8</span>            <span class="mi">1</span> <span class="mi">75</span> <span class="mi">55</span>  <span class="mi">4125</span>
<span class="mi">9</span>            <span class="mi">1</span> <span class="mi">82</span> <span class="mi">67</span>  <span class="mi">5494</span>
<span class="mi">10</span>           <span class="mi">1</span> <span class="mi">61</span> <span class="mi">47</span>  <span class="mi">2867</span>
<span class="mi">11</span>           <span class="mi">1</span> <span class="mi">53</span> <span class="mi">58</span>  <span class="mi">3074</span>
<span class="mi">12</span>           <span class="mi">1</span> <span class="mi">60</span> <span class="mi">39</span>  <span class="mi">2340</span>
<span class="mi">13</span>           <span class="mi">1</span> <span class="mi">62</span> <span class="mi">42</span>  <span class="mi">2604</span>
<span class="mi">14</span>           <span class="mi">1</span> <span class="mi">83</span> <span class="mi">45</span>  <span class="mi">3735</span>
<span class="mi">15</span>           <span class="mi">1</span> <span class="mi">77</span> <span class="mi">72</span>  <span class="mi">5544</span>
<span class="mi">16</span>           <span class="mi">1</span> <span class="mi">90</span> <span class="mi">72</span>  <span class="mi">6480</span>
<span class="mi">17</span>           <span class="mi">1</span> <span class="mi">85</span> <span class="mi">69</span>  <span class="mi">5865</span>
<span class="mi">18</span>           <span class="mi">1</span> <span class="mi">60</span> <span class="mi">75</span>  <span class="mi">4500</span>
<span class="mi">19</span>           <span class="mi">1</span> <span class="mi">70</span> <span class="mi">57</span>  <span class="mi">3990</span>
<span class="mi">20</span>           <span class="mi">1</span> <span class="mi">58</span> <span class="mi">54</span>  <span class="mi">3132</span>
<span class="mi">21</span>           <span class="mi">1</span> <span class="mi">40</span> <span class="mi">34</span>  <span class="mi">1360</span>
<span class="mi">22</span>           <span class="mi">1</span> <span class="mi">61</span> <span class="mi">62</span>  <span class="mi">3782</span>
<span class="mi">23</span>           <span class="mi">1</span> <span class="mi">66</span> <span class="mi">50</span>  <span class="mi">3300</span>
<span class="mi">24</span>           <span class="mi">1</span> <span class="mi">37</span> <span class="mi">58</span>  <span class="mi">2146</span>
<span class="mi">25</span>           <span class="mi">1</span> <span class="mi">54</span> <span class="mi">48</span>  <span class="mi">2592</span>
<span class="mi">26</span>           <span class="mi">1</span> <span class="mi">77</span> <span class="mi">63</span>  <span class="mi">4851</span>
<span class="mi">27</span>           <span class="mi">1</span> <span class="mi">75</span> <span class="mi">74</span>  <span class="mi">5550</span>
<span class="mi">28</span>           <span class="mi">1</span> <span class="mi">57</span> <span class="mi">45</span>  <span class="mi">2565</span>
<span class="mi">29</span>           <span class="mi">1</span> <span class="mi">85</span> <span class="mi">71</span>  <span class="mi">6035</span>
<span class="mi">30</span>           <span class="mi">1</span> <span class="mi">82</span> <span class="mi">59</span>  <span class="mi">4838</span>
<span class="n">attr</span><span class="p">(,</span><span class="s2">&quot;assign&quot;</span><span class="p">)</span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span>
<span class="o">&gt;</span>
</pre></div>
</div>
<p>With the Formula, it looks like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
<span class="gp">... </span>    <span class="p">(</span><span class="mi">43</span><span class="p">,</span> <span class="mi">51</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">39</span><span class="p">,</span> <span class="mi">61</span><span class="p">,</span> <span class="mi">92</span><span class="p">,</span> <span class="mi">45</span><span class="p">),</span> <span class="p">(</span><span class="mi">63</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">51</span><span class="p">,</span> <span class="mi">54</span><span class="p">,</span> <span class="mi">63</span><span class="p">,</span> <span class="mi">73</span><span class="p">,</span> <span class="mi">47</span><span class="p">),</span> 
<span class="gp">... </span>    <span class="p">(</span><span class="mi">71</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">68</span><span class="p">,</span> <span class="mi">69</span><span class="p">,</span> <span class="mi">76</span><span class="p">,</span> <span class="mi">86</span><span class="p">,</span> <span class="mi">48</span><span class="p">),</span> <span class="p">(</span><span class="mi">61</span><span class="p">,</span> <span class="mi">63</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">47</span><span class="p">,</span> <span class="mi">54</span><span class="p">,</span> <span class="mi">84</span><span class="p">,</span> <span class="mi">35</span><span class="p">),</span>
<span class="gp">... </span>    <span class="p">(</span><span class="mi">81</span><span class="p">,</span> <span class="mi">78</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="mi">66</span><span class="p">,</span> <span class="mi">71</span><span class="p">,</span> <span class="mi">83</span><span class="p">,</span> <span class="mi">47</span><span class="p">),</span> <span class="p">(</span><span class="mi">43</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">49</span><span class="p">,</span> <span class="mi">44</span><span class="p">,</span> <span class="mi">54</span><span class="p">,</span> <span class="mi">49</span><span class="p">,</span> <span class="mi">34</span><span class="p">),</span>
<span class="gp">... </span>    <span class="p">(</span><span class="mi">58</span><span class="p">,</span> <span class="mi">67</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="mi">66</span><span class="p">,</span> <span class="mi">68</span><span class="p">,</span> <span class="mi">35</span><span class="p">),</span> <span class="p">(</span><span class="mi">71</span><span class="p">,</span> <span class="mi">75</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">66</span><span class="p">,</span> <span class="mi">41</span><span class="p">),</span>
<span class="gp">... </span>    <span class="p">(</span><span class="mi">72</span><span class="p">,</span> <span class="mi">82</span><span class="p">,</span> <span class="mi">72</span><span class="p">,</span> <span class="mi">67</span><span class="p">,</span> <span class="mi">71</span><span class="p">,</span> <span class="mi">83</span><span class="p">,</span> <span class="mi">31</span><span class="p">),</span> <span class="p">(</span><span class="mi">67</span><span class="p">,</span> <span class="mi">61</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">47</span><span class="p">,</span> <span class="mi">62</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">41</span><span class="p">),</span>
<span class="gp">... </span>    <span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">53</span><span class="p">,</span> <span class="mi">53</span><span class="p">,</span> <span class="mi">58</span><span class="p">,</span> <span class="mi">58</span><span class="p">,</span> <span class="mi">67</span><span class="p">,</span> <span class="mi">34</span><span class="p">),</span> <span class="p">(</span><span class="mi">67</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">47</span><span class="p">,</span> <span class="mi">39</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">74</span><span class="p">,</span> <span class="mi">41</span><span class="p">),</span>
<span class="gp">... </span>    <span class="p">(</span><span class="mi">69</span><span class="p">,</span> <span class="mi">62</span><span class="p">,</span> <span class="mi">57</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">63</span><span class="p">,</span> <span class="mi">25</span><span class="p">),</span> <span class="p">(</span><span class="mi">68</span><span class="p">,</span> <span class="mi">83</span><span class="p">,</span> <span class="mi">83</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">77</span><span class="p">,</span> <span class="mi">35</span><span class="p">),</span>
<span class="gp">... </span>    <span class="p">(</span><span class="mi">77</span><span class="p">,</span> <span class="mi">77</span><span class="p">,</span> <span class="mi">54</span><span class="p">,</span> <span class="mi">72</span><span class="p">,</span> <span class="mi">79</span><span class="p">,</span> <span class="mi">77</span><span class="p">,</span> <span class="mi">46</span><span class="p">),</span> <span class="p">(</span><span class="mi">81</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">72</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">54</span><span class="p">,</span> <span class="mi">36</span><span class="p">),</span>
<span class="gp">... </span>    <span class="p">(</span><span class="mi">74</span><span class="p">,</span> <span class="mi">85</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">69</span><span class="p">,</span> <span class="mi">79</span><span class="p">,</span> <span class="mi">79</span><span class="p">,</span> <span class="mi">63</span><span class="p">),</span> <span class="p">(</span><span class="mi">65</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">65</span><span class="p">,</span> <span class="mi">75</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">60</span><span class="p">),</span>
<span class="gp">... </span>    <span class="p">(</span><span class="mi">65</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">46</span><span class="p">,</span> <span class="mi">57</span><span class="p">,</span> <span class="mi">75</span><span class="p">,</span> <span class="mi">85</span><span class="p">,</span> <span class="mi">46</span><span class="p">),</span> <span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">58</span><span class="p">,</span> <span class="mi">68</span><span class="p">,</span> <span class="mi">54</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">78</span><span class="p">,</span> <span class="mi">52</span><span class="p">),</span>
<span class="gp">... </span>    <span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">43</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">33</span><span class="p">),</span> <span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">61</span><span class="p">,</span> <span class="mi">52</span><span class="p">,</span> <span class="mi">62</span><span class="p">,</span> <span class="mi">66</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">41</span><span class="p">),</span>
<span class="gp">... </span>    <span class="p">(</span><span class="mi">53</span><span class="p">,</span> <span class="mi">66</span><span class="p">,</span> <span class="mi">52</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">63</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">37</span><span class="p">),</span> <span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">58</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">57</span><span class="p">,</span> <span class="mi">49</span><span class="p">),</span>
<span class="gp">... </span>    <span class="p">(</span><span class="mi">63</span><span class="p">,</span> <span class="mi">54</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">48</span><span class="p">,</span> <span class="mi">66</span><span class="p">,</span> <span class="mi">75</span><span class="p">,</span> <span class="mi">33</span><span class="p">),</span> <span class="p">(</span><span class="mi">66</span><span class="p">,</span> <span class="mi">77</span><span class="p">,</span> <span class="mi">66</span><span class="p">,</span> <span class="mi">63</span><span class="p">,</span> <span class="mi">88</span><span class="p">,</span> <span class="mi">76</span><span class="p">,</span> <span class="mi">72</span><span class="p">),</span>
<span class="gp">... </span>    <span class="p">(</span><span class="mi">78</span><span class="p">,</span> <span class="mi">75</span><span class="p">,</span> <span class="mi">58</span><span class="p">,</span> <span class="mi">74</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">78</span><span class="p">,</span> <span class="mi">49</span><span class="p">),</span> <span class="p">(</span><span class="mi">48</span><span class="p">,</span> <span class="mi">57</span><span class="p">,</span> <span class="mi">44</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">51</span><span class="p">,</span> <span class="mi">83</span><span class="p">,</span> <span class="mi">38</span><span class="p">),</span>
<span class="gp">... </span>    <span class="p">(</span><span class="mi">85</span><span class="p">,</span> <span class="mi">85</span><span class="p">,</span> <span class="mi">71</span><span class="p">,</span> <span class="mi">71</span><span class="p">,</span> <span class="mi">77</span><span class="p">,</span> <span class="mi">74</span><span class="p">,</span> <span class="mi">55</span><span class="p">),</span> <span class="p">(</span><span class="mi">82</span><span class="p">,</span> <span class="mi">82</span><span class="p">,</span> <span class="mi">39</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">78</span><span class="p">,</span> <span class="mi">39</span><span class="p">)],</span>
<span class="gp">... </span>             <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;i8&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;x1&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;i8&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;x2&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;i8&#39;</span><span class="p">),</span>
<span class="gp">... </span>                    <span class="p">(</span><span class="s1">&#39;x3&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;i8&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;x4&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;i8&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;x5&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;i8&#39;</span><span class="p">),</span>
<span class="gp">... </span>                    <span class="p">(</span><span class="s1">&#39;x6&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;i8&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x1</span> <span class="o">=</span> <span class="n">Term</span><span class="p">(</span><span class="s1">&#39;x1&#39;</span><span class="p">);</span> <span class="n">x3</span> <span class="o">=</span> <span class="n">Term</span><span class="p">(</span><span class="s1">&#39;x3&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Formula</span><span class="p">([</span><span class="n">x1</span><span class="p">,</span> <span class="n">x3</span><span class="p">,</span> <span class="n">x1</span><span class="o">*</span><span class="n">x3</span><span class="p">])</span> <span class="o">+</span> <span class="n">I</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">mean</span>
<span class="go">_b0*x1 + _b1*x3 + _b2*x1*x3 + _b3</span>
</pre></div>
</div>
<p>The I is the “intercept” term, I have explicity not used R’s default of
adding it to everything.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">design</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>  
<span class="go">array([(51.0, 39.0, 1989.0, 1.0), (64.0, 54.0, 3456.0, 1.0),</span>
<span class="go">       (70.0, 69.0, 4830.0, 1.0), (63.0, 47.0, 2961.0, 1.0),</span>
<span class="go">       (78.0, 66.0, 5148.0, 1.0), (55.0, 44.0, 2420.0, 1.0),</span>
<span class="go">       (67.0, 56.0, 3752.0, 1.0), (75.0, 55.0, 4125.0, 1.0),</span>
<span class="go">       (82.0, 67.0, 5494.0, 1.0), (61.0, 47.0, 2867.0, 1.0),</span>
<span class="go">       (53.0, 58.0, 3074.0, 1.0), (60.0, 39.0, 2340.0, 1.0),</span>
<span class="go">       (62.0, 42.0, 2604.0, 1.0), (83.0, 45.0, 3735.0, 1.0),</span>
<span class="go">       (77.0, 72.0, 5544.0, 1.0), (90.0, 72.0, 6480.0, 1.0),</span>
<span class="go">       (85.0, 69.0, 5865.0, 1.0), (60.0, 75.0, 4500.0, 1.0),</span>
<span class="go">       (70.0, 57.0, 3990.0, 1.0), (58.0, 54.0, 3132.0, 1.0),</span>
<span class="go">       (40.0, 34.0, 1360.0, 1.0), (61.0, 62.0, 3782.0, 1.0),</span>
<span class="go">       (66.0, 50.0, 3300.0, 1.0), (37.0, 58.0, 2146.0, 1.0),</span>
<span class="go">       (54.0, 48.0, 2592.0, 1.0), (77.0, 63.0, 4851.0, 1.0),</span>
<span class="go">       (75.0, 74.0, 5550.0, 1.0), (57.0, 45.0, 2565.0, 1.0),</span>
<span class="go">       (85.0, 71.0, 6035.0, 1.0), (82.0, 59.0, 4838.0, 1.0)], </span>
<span class="go">      dtype=[(&#39;x1&#39;, &#39;&lt;f8&#39;), (&#39;x3&#39;, &#39;&lt;f8&#39;), (&#39;x1*x3&#39;, &#39;&lt;f8&#39;), (&#39;1&#39;, &#39;&lt;f8&#39;)])</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="classes">
<h2>Classes<a class="headerlink" href="#classes" title="Permalink to this headline">¶</a></h2>
<div class="section" id="beta">
<h3><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Beta" title="nipy.algorithms.statistics.formula.formulae.Beta"><code class="xref py py-class docutils literal notranslate"><span class="pre">Beta</span></code></a><a class="headerlink" href="#beta" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta">
<em class="property">class </em><code class="sig-prename descclassname">nipy.algorithms.statistics.formula.formulae.</code><code class="sig-name descname">Beta</code><a class="reference internal" href="../../_modules/nipy/algorithms/statistics/formula/formulae.html#Beta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sympy.core.symbol.Dummy</span></code></p>
<p>A symbol tied to a Term <cite>term</cite></p>
<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">$self</em>, <em class="sig-param">/</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.adjoint">
<code class="sig-name descname">adjoint</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.adjoint" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.apart">
<code class="sig-name descname">apart</code><span class="sig-paren">(</span><em class="sig-param">x=None</em>, <em class="sig-param">**args</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.apart" title="Permalink to this definition">¶</a></dt>
<dd><p>See the apart function in sympy.polys</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.args">
<em class="property">property </em><code class="sig-name descname">args</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.args" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a tuple of arguments of ‘self’.</p>
<p class="rubric">Notes</p>
<p>Never use self._args, always use self.args.
Only use _args in __new__ when creating a new function.
Don’t override .args() from Basic (so that it’s easy to
change the interface in the future if needed).</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">cot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">args</span>
<span class="go">(x,)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">x</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">args</span>
<span class="go">(x, y)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">y</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.args_cnc">
<code class="sig-name descname">args_cnc</code><span class="sig-paren">(</span><em class="sig-param">cset=False</em>, <em class="sig-param">warn=True</em>, <em class="sig-param">split_1=True</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.args_cnc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return [commutative factors, non-commutative factors] of self.</p>
<p>self is treated as a Mul and the ordering of the factors is maintained.
If <code class="docutils literal notranslate"><span class="pre">cset</span></code> is True the commutative factors will be returned in a set.
If there were repeated factors (as may happen with an unevaluated Mul)
then an error will be raised unless it is explicitly suppressed by
setting <code class="docutils literal notranslate"><span class="pre">warn</span></code> to False.</p>
<p>Note: -1 is always separated from a Number unless split_1 is False.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">oo</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;A B&#39;</span><span class="p">,</span> <span class="n">commutative</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x y&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">()</span>
<span class="go">[[-1, 2, x, y], []]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">-</span><span class="mf">2.5</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">()</span>
<span class="go">[[-1, 2.5, x], []]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">A</span><span class="o">*</span><span class="n">B</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">()</span>
<span class="go">[[-1, 2, x, y], [A, B]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">A</span><span class="o">*</span><span class="n">B</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">(</span><span class="n">split_1</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[[-2, x, y], [A, B]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">(</span><span class="n">cset</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[{-1, 2, x, y}, []]</span>
</pre></div>
</div>
<p>The arg is always treated as a Mul:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">()</span>
<span class="go">[[], [x - 2 + A]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">-</span><span class="n">oo</span><span class="p">)</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">()</span> <span class="c1"># -oo is a singleton</span>
<span class="go">[[-1, oo], []]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.as_base_exp">
<code class="sig-name descname">as_base_exp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.as_base_exp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.as_coeff_Add">
<code class="sig-name descname">as_coeff_Add</code><span class="sig-paren">(</span><em class="sig-param">rational=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.as_coeff_Add" title="Permalink to this definition">¶</a></dt>
<dd><p>Efficiently extract the coefficient of a summation.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.as_coeff_Mul">
<code class="sig-name descname">as_coeff_Mul</code><span class="sig-paren">(</span><em class="sig-param">rational=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.as_coeff_Mul" title="Permalink to this definition">¶</a></dt>
<dd><p>Efficiently extract the coefficient of a product.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.as_coeff_add">
<code class="sig-name descname">as_coeff_add</code><span class="sig-paren">(</span><em class="sig-param">*deps</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.as_coeff_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the tuple (c, args) where self is written as an Add, <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
<p>c should be a Rational added to any terms of the Add that are
independent of deps.</p>
<p>args should be a tuple of all other terms of <code class="docutils literal notranslate"><span class="pre">a</span></code>; args is empty
if self is a Number or if self is independent of deps (when given).</p>
<p>This should be used when you don’t know if self is an Add or not but
you want to treat self as an Add or if you want to process the
individual arguments of the tail of self as an Add.</p>
<ul class="simple">
<li><p>if you know self is an Add and want only the head, use self.args[0];</p></li>
<li><p>if you don’t want to process the arguments of the tail but need the
tail then use self.as_two_terms() which gives the head and tail.</p></li>
<li><p>if you want to split self into an independent and dependent parts
use <code class="docutils literal notranslate"><span class="pre">self.as_independent(*deps)</span></code></p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">S</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">as_coeff_add</span><span class="p">()</span>
<span class="go">(3, ())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">as_coeff_add</span><span class="p">()</span>
<span class="go">(3, (x,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">as_coeff_add</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">(y + 3, (x,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">as_coeff_add</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">(y + 3, ())</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.as_coeff_exponent">
<code class="sig-name descname">as_coeff_exponent</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.as_coeff_exponent" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">c*x**e</span> <span class="pre">-&gt;</span> <span class="pre">c,e</span></code> where x can be any symbolic expression.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.as_coeff_mul">
<code class="sig-name descname">as_coeff_mul</code><span class="sig-paren">(</span><em class="sig-param">*deps</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.as_coeff_mul" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the tuple (c, args) where self is written as a Mul, <code class="docutils literal notranslate"><span class="pre">m</span></code>.</p>
<p>c should be a Rational multiplied by any factors of the Mul that are
independent of deps.</p>
<p>args should be a tuple of all other factors of m; args is empty
if self is a Number or if self is independent of deps (when given).</p>
<p>This should be used when you don’t know if self is a Mul or not but
you want to treat self as a Mul or if you want to process the
individual arguments of the tail of self as a Mul.</p>
<ul class="simple">
<li><p>if you know self is a Mul and want only the head, use self.args[0];</p></li>
<li><p>if you don’t want to process the arguments of the tail but need the
tail then use self.as_two_terms() which gives the head and tail;</p></li>
<li><p>if you want to split self into an independent and dependent parts
use <code class="docutils literal notranslate"><span class="pre">self.as_independent(*deps)</span></code></p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">S</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">as_coeff_mul</span><span class="p">()</span>
<span class="go">(3, ())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">as_coeff_mul</span><span class="p">()</span>
<span class="go">(3, (x, y))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">as_coeff_mul</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">(3*y, (x,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">as_coeff_mul</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">(3*y, ())</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.as_coefficient">
<code class="sig-name descname">as_coefficient</code><span class="sig-paren">(</span><em class="sig-param">expr</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.as_coefficient" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts symbolic coefficient at the given expression. In
other words, this functions separates ‘self’ into the product
of ‘expr’ and ‘expr’-free coefficient. If such separation
is not possible it will return None.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Beta.coeff" title="nipy.algorithms.statistics.formula.formulae.Beta.coeff"><code class="xref py py-obj docutils literal notranslate"><span class="pre">coeff</span></code></a></dt><dd><p>return sum of terms have a given factor</p>
</dd>
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Beta.as_coeff_Add" title="nipy.algorithms.statistics.formula.formulae.Beta.as_coeff_Add"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_coeff_Add</span></code></a></dt><dd><p>separate the additive constant from an expression</p>
</dd>
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Beta.as_coeff_Mul" title="nipy.algorithms.statistics.formula.formulae.Beta.as_coeff_Mul"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_coeff_Mul</span></code></a></dt><dd><p>separate the multiplicative constant from an expression</p>
</dd>
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Beta.as_independent" title="nipy.algorithms.statistics.formula.formulae.Beta.as_independent"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_independent</span></code></a></dt><dd><p>separate x-dependent terms/factors from others</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.polys.polytools.coeff_monomial</span></code></dt><dd><p>efficiently find the single coefficient of a monomial in Poly</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.polys.polytools.nth</span></code></dt><dd><p>like coeff_monomial but powers of monomial terms are used</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">E</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">Poly</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">E</span><span class="o">.</span><span class="n">as_coefficient</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">E</span><span class="p">)</span><span class="o">.</span><span class="n">as_coefficient</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">E</span><span class="p">)</span><span class="o">*</span><span class="n">E</span><span class="p">)</span><span class="o">.</span><span class="n">as_coefficient</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
</pre></div>
</div>
<p>Two terms have E in them so a sum is returned. (If one were
desiring the coefficient of the term exactly matching E then
the constant from the returned expression could be selected.
Or, for greater precision, a method of Poly can be used to
indicate the desired term from which the coefficient is
desired.)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">E</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">E</span><span class="p">)</span><span class="o">.</span><span class="n">as_coefficient</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="go">x + 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># just want the exact match</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">E</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">E</span><span class="p">);</span> <span class="n">p</span>
<span class="go">Poly(x*E + 2*E, x, E, domain=&#39;ZZ&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">coeff_monomial</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">nth</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>Since the following cannot be written as a product containing
E as a factor, None is returned. (If the coefficient <code class="docutils literal notranslate"><span class="pre">2*x</span></code> is
desired then the <code class="docutils literal notranslate"><span class="pre">coeff</span></code> method should be used.)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">E</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">as_coefficient</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">E</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="go">2*x</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">E</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">as_coefficient</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">as_coefficient</span><span class="p">(</span><span class="n">pi</span><span class="o">*</span><span class="n">I</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">as_coefficient</span><span class="p">(</span><span class="n">pi</span><span class="o">*</span><span class="n">I</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.as_coefficients_dict">
<code class="sig-name descname">as_coefficients_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.as_coefficients_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dictionary mapping terms to their Rational coefficient.
Since the dictionary is a defaultdict, inquiries about terms which
were not present will return a coefficient of 0. If an expression is
not an Add it is considered to have a single term.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">as_coefficients_dict</span><span class="p">()</span>
<span class="go">{1: 4, x: 3, a*x: 1}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">as_coefficients_dict</span><span class="p">()</span>
<span class="go">{a*x: 3}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.as_content_primitive">
<code class="sig-name descname">as_content_primitive</code><span class="sig-paren">(</span><em class="sig-param">radical=False</em>, <em class="sig-param">clear=True</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.as_content_primitive" title="Permalink to this definition">¶</a></dt>
<dd><p>This method should recursively remove a Rational from all arguments
and return that (content) and the new self (primitive). The content
should always be positive and <code class="docutils literal notranslate"><span class="pre">Mul(*foo.as_content_primitive())</span> <span class="pre">==</span> <span class="pre">foo</span></code>.
The primitive need not be in canonical form and should try to preserve
the underlying structure if possible (i.e. expand_mul should not be
applied to self).</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">sqrt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>The as_content_primitive function is recursive and retains structure:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span><span class="o">.</span><span class="n">as_content_primitive</span><span class="p">()</span>
<span class="go">(2, x + 3*y*(y + 1) + 1)</span>
</pre></div>
</div>
<p>Integer powers will have Rationals extracted from the base:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">6</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">as_content_primitive</span><span class="p">()</span>
<span class="go">(4, (3*x + 1)**2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">6</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">as_content_primitive</span><span class="p">()</span>
<span class="go">(1, (2*(3*x + 1))**(2*y))</span>
</pre></div>
</div>
<p>Terms may end up joining once their as_content_primitives are added:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="mi">5</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="p">))</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">y</span><span class="p">)))</span><span class="o">.</span><span class="n">as_content_primitive</span><span class="p">()</span>
<span class="go">(11, x*(y + 1))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="p">))</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">y</span><span class="p">)))</span><span class="o">.</span><span class="n">as_content_primitive</span><span class="p">()</span>
<span class="go">(9, x*(y + 1))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">z</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="p">))</span> <span class="o">+</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">y</span><span class="p">)))</span><span class="o">.</span><span class="n">as_content_primitive</span><span class="p">()</span>
<span class="go">(1, 6.0*x*(y + 1) + 3*z*(y + 1))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="mi">5</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="p">))</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">y</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">as_content_primitive</span><span class="p">()</span>
<span class="go">(121, x**2*(y + 1)**2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="mi">5</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="p">))</span> <span class="o">+</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">y</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">as_content_primitive</span><span class="p">()</span>
<span class="go">(1, 121.0*x**2*(y + 1)**2)</span>
</pre></div>
</div>
<p>Radical content can also be factored out of the primitive:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span><span class="o">.</span><span class="n">as_content_primitive</span><span class="p">(</span><span class="n">radical</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(2, sqrt(2)*(1 + 2*sqrt(5)))</span>
</pre></div>
</div>
<p>If clear=False (default is True) then content will not be removed
from an Add if it can be distributed to leave one or more
terms with integer coefficients.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">as_content_primitive</span><span class="p">()</span>
<span class="go">(1/2, x + 2*y)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">as_content_primitive</span><span class="p">(</span><span class="n">clear</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">(1, x/2 + y)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.as_dummy">
<code class="sig-name descname">as_dummy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.as_dummy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the expression with any objects having structurally
bound symbols replaced with unique, canonical symbols within
the object in which they appear and having only the default
assumption for commutativity being True.</p>
<p class="rubric">Notes</p>
<p>Any object that has structural dummy variables should have
a property, <cite>bound_symbols</cite> that returns a list of structural
dummy symbols of the object itself.</p>
<p>Lambda and Subs have bound symbols, but because of how they
are cached, they already compare the same regardless of their
bound symbols:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Lambda</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Lambda</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">Lambda</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Integral</span><span class="p">,</span> <span class="n">Symbol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Integral</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">as_dummy</span><span class="p">()</span>
<span class="go">Integral(_0, (_0, x))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_real</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.as_expr">
<code class="sig-name descname">as_expr</code><span class="sig-paren">(</span><em class="sig-param">*gens</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.as_expr" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a polynomial to a SymPy expression.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">sin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">as_poly</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">as_expr</span><span class="p">()</span>
<span class="go">x**2 + x*y</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">as_expr</span><span class="p">()</span>
<span class="go">sin(x)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.as_independent">
<code class="sig-name descname">as_independent</code><span class="sig-paren">(</span><em class="sig-param">*deps</em>, <em class="sig-param">**hint</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.as_independent" title="Permalink to this definition">¶</a></dt>
<dd><p>A mostly naive separation of a Mul or Add into arguments that are not
are dependent on deps. To obtain as complete a separation of variables
as possible, use a separation method first, e.g.:</p>
<ul class="simple">
<li><p>separatevars() to change Mul, Add and Pow (including exp) into Mul</p></li>
<li><p>.expand(mul=True) to change Add or Mul into Add</p></li>
<li><p>.expand(log=True) to change log expr into an Add</p></li>
</ul>
<p>The only non-naive thing that is done here is to respect noncommutative
ordering of variables and to always return (0, 0) for <cite>self</cite> of zero
regardless of hints.</p>
<p>For nonzero <cite>self</cite>, the returned tuple (i, d) has the
following interpretation:</p>
<ul class="simple">
<li><p>i will has no variable that appears in deps</p></li>
<li><p>d will either have terms that contain variables that are in deps, or
be equal to 0 (when self is an Add) or 1 (when self is a Mul)</p></li>
<li><p>if self is an Add then self = i + d</p></li>
<li><p>if self is a Mul then self = i*d</p></li>
<li><p>otherwise (self, S.One) or (S.One, self) is returned.</p></li>
</ul>
<p>To force the expression to be treated as an Add, use the hint as_Add=True</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">separatevars</span></code>, <a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Beta.expand" title="nipy.algorithms.statistics.formula.formulae.Beta.expand"><code class="xref py py-obj docutils literal notranslate"><span class="pre">expand</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">Add.as_two_terms</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">Mul.as_two_terms</span></code>, <a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Beta.as_coeff_add" title="nipy.algorithms.statistics.formula.formulae.Beta.as_coeff_add"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_coeff_add</span></code></a>, <a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Beta.as_coeff_mul" title="nipy.algorithms.statistics.formula.formulae.Beta.as_coeff_mul"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_coeff_mul</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<p>– self is an Add</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">exp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">(0, x*y + x)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">(x, x*y)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">(y + z, 2*x*sin(x) + x)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">(z, 2*x*sin(x) + x + y)</span>
</pre></div>
</div>
<p>– self is a Mul</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">(cos(y), x*sin(x))</span>
</pre></div>
</div>
<p>non-commutative terms cannot always be separated out when self is a Mul</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">n3</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;n1 n2 n3&#39;</span><span class="p">,</span> <span class="n">commutative</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">n1</span> <span class="o">+</span> <span class="n">n1</span><span class="o">*</span><span class="n">n2</span><span class="p">)</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">n2</span><span class="p">)</span>
<span class="go">(n1, n1*n2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">n2</span><span class="o">*</span><span class="n">n1</span> <span class="o">+</span> <span class="n">n1</span><span class="o">*</span><span class="n">n2</span><span class="p">)</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">n2</span><span class="p">)</span>
<span class="go">(0, n1*n2 + n2*n1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">n1</span><span class="o">*</span><span class="n">n2</span><span class="o">*</span><span class="n">n3</span><span class="p">)</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">n1</span><span class="p">)</span>
<span class="go">(1, n1*n2*n3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">n1</span><span class="o">*</span><span class="n">n2</span><span class="o">*</span><span class="n">n3</span><span class="p">)</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">n2</span><span class="p">)</span>
<span class="go">(n1, n2*n3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">n1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">(1, (x - y)*(x - n1))</span>
</pre></div>
</div>
<p>– self is anything else:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">(1, sin(x))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">(sin(x), 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">(1, exp(x + y))</span>
</pre></div>
</div>
<p>– force self to be treated as an Add:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">as_Add</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(0, 3*x)</span>
</pre></div>
</div>
<p>– force self to be treated as a Mul:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span><span class="o">+</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">as_Add</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">(1, x + 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="o">+</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">as_Add</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">(1, x - 3)</span>
</pre></div>
</div>
<p>Note how the below differs from the above in making the
constant on the dep term positive.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">y</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="o">+</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">(y, x - 3)</span>
</pre></div>
</div>
<dl class="simple">
<dt>– use .as_independent() for true independence testing instead</dt><dd><p>of .has(). The former considers only symbols in the free
symbols while the latter considers all symbols</p>
</dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Integral</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span> <span class="o">=</span> <span class="n">Integral</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="ow">in</span> <span class="n">I</span><span class="o">.</span><span class="n">free_symbols</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">I</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Note: when trying to get independent terms, a separation method
might need to be used first. In this case, it is important to keep
track of what you send to this routine so you know how to interpret
the returned values</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">separatevars</span><span class="p">,</span> <span class="n">log</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">separatevars</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">(exp(y), exp(x))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">(x, x*y)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">separatevars</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">(x, y + 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">(x, y + 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">mul</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">(x, x*y)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;a b&#39;</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">(log(a), log(b))</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.as_leading_term">
<code class="sig-name descname">as_leading_term</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.as_leading_term" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the leading (nonzero) term of the series expansion of self.</p>
<p>The _eval_as_leading_term routines are used to do this, and they must
always return a non-zero value.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">as_leading_term</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">as_leading_term</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">x**(-2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.as_numer_denom">
<code class="sig-name descname">as_numer_denom</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.as_numer_denom" title="Permalink to this definition">¶</a></dt>
<dd><p>expression -&gt; a/b -&gt; a, b</p>
<p>This is just a stub that should be defined by
an object’s class methods to get anything else.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Beta.normal" title="nipy.algorithms.statistics.formula.formulae.Beta.normal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">normal</span></code></a></dt><dd><p>return a/b instead of a, b</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.as_ordered_factors">
<code class="sig-name descname">as_ordered_factors</code><span class="sig-paren">(</span><em class="sig-param">order=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.as_ordered_factors" title="Permalink to this definition">¶</a></dt>
<dd><p>Return list of ordered factors (if Mul) else [self].</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.as_ordered_terms">
<code class="sig-name descname">as_ordered_terms</code><span class="sig-paren">(</span><em class="sig-param">order=None</em>, <em class="sig-param">data=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.as_ordered_terms" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform an expression to an ordered list of terms.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">as_ordered_terms</span><span class="p">()</span>
<span class="go">[sin(x)**2*cos(x), sin(x)**2, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.as_poly">
<code class="sig-name descname">as_poly</code><span class="sig-paren">(</span><em class="sig-param">*gens</em>, <em class="sig-param">**args</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.as_poly" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts <code class="docutils literal notranslate"><span class="pre">self</span></code> to a polynomial or returns <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">sin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">((</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">as_poly</span><span class="p">())</span>
<span class="go">Poly(x**2 + x*y, x, y, domain=&#39;ZZ&#39;)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">((</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">as_poly</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
<span class="go">Poly(x**2 + x*y, x, y, domain=&#39;ZZ&#39;)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">((</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">as_poly</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
<span class="go">None</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.as_powers_dict">
<code class="sig-name descname">as_powers_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.as_powers_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self as a dictionary of factors with each factor being
treated as a power. The keys are the bases of the factors and the
values, the corresponding exponents. The resulting dictionary should
be used with caution if the expression is a Mul and contains non-
commutative factors since the order that they appeared will be lost in
the dictionary.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Beta.as_ordered_factors" title="nipy.algorithms.statistics.formula.formulae.Beta.as_ordered_factors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_ordered_factors</span></code></a></dt><dd><p>An alternative for noncommutative applications, returning an ordered list of factors.</p>
</dd>
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Beta.args_cnc" title="nipy.algorithms.statistics.formula.formulae.Beta.args_cnc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">args_cnc</span></code></a></dt><dd><p>Similar to as_ordered_factors, but guarantees separation of commutative and noncommutative factors.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.as_real_imag">
<code class="sig-name descname">as_real_imag</code><span class="sig-paren">(</span><em class="sig-param">deep=True</em>, <em class="sig-param">**hints</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.as_real_imag" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs complex expansion on ‘self’ and returns a tuple
containing collected both real and imaginary parts. This
method can’t be confused with re() and im() functions,
which does not perform complex expansion at evaluation.</p>
<p>However it is possible to expand both re() and im()
functions and get exactly the same results as with
a single call to this function.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">I</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x,y&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">as_real_imag</span><span class="p">()</span>
<span class="go">(x, y)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">z</span><span class="p">,</span> <span class="n">w</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">z</span> <span class="o">+</span> <span class="n">w</span><span class="o">*</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">as_real_imag</span><span class="p">()</span>
<span class="go">(re(z) - im(w), re(w) + im(z))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.as_set">
<code class="sig-name descname">as_set</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.as_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Rewrites Boolean expression in terms of real sets.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">Or</span><span class="p">,</span> <span class="n">And</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Eq</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">as_set</span><span class="p">()</span>
<span class="go">{0}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">as_set</span><span class="p">()</span>
<span class="go">Interval.open(0, oo)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">And</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">as_set</span><span class="p">()</span>
<span class="go">Interval.open(-2, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Or</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">as_set</span><span class="p">()</span>
<span class="go">Union(Interval.open(-oo, -2), Interval.open(2, oo))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.as_terms">
<code class="sig-name descname">as_terms</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.as_terms" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform an expression to a list of terms.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.assumptions0">
<em class="property">property </em><code class="sig-name descname">assumptions0</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.assumptions0" title="Permalink to this definition">¶</a></dt>
<dd><p>Return object <cite>type</cite> assumptions.</p>
<p>For example:</p>
<blockquote>
<div><p>Symbol(‘x’, real=True)
Symbol(‘x’, integer=True)</p>
</div></blockquote>
<p>are different objects. In other words, besides Python type (Symbol in
this case), the initial assumptions are also forming their typeinfo.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Symbol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">assumptions0</span>
<span class="go">{&#39;commutative&#39;: True}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">assumptions0</span>
<span class="go">{&#39;commutative&#39;: True, &#39;complex&#39;: True, &#39;hermitian&#39;: True,</span>
<span class="go">&#39;imaginary&#39;: False, &#39;negative&#39;: False, &#39;nonnegative&#39;: True,</span>
<span class="go">&#39;nonpositive&#39;: False, &#39;nonzero&#39;: True, &#39;positive&#39;: True, &#39;real&#39;: True,</span>
<span class="go">&#39;zero&#39;: False}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.atoms">
<code class="sig-name descname">atoms</code><span class="sig-paren">(</span><em class="sig-param">*types</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.atoms" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the atoms that form the current object.</p>
<p>By default, only objects that are truly atomic and can’t
be divided into smaller pieces are returned: symbols, numbers,
and number symbols like I and pi. It is possible to request
atoms of any type, however, as demonstrated below.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">I</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">sin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">()</span>
<span class="go">{1, 2, I, pi, x, y}</span>
</pre></div>
</div>
<p>If one or more types are given, the results will contain only
those types of atoms.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Number</span><span class="p">,</span> <span class="n">NumberSymbol</span><span class="p">,</span> <span class="n">Symbol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Symbol</span><span class="p">)</span>
<span class="go">{x, y}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Number</span><span class="p">)</span>
<span class="go">{1, 2}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Number</span><span class="p">,</span> <span class="n">NumberSymbol</span><span class="p">)</span>
<span class="go">{1, 2, pi}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Number</span><span class="p">,</span> <span class="n">NumberSymbol</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
<span class="go">{1, 2, I, pi}</span>
</pre></div>
</div>
<p>Note that I (imaginary unit) and zoo (complex infinity) are special
types of number symbols and are not part of the NumberSymbol class.</p>
<p>The type can be given implicitly, too:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c1"># x is a Symbol</span>
<span class="go">{x, y}</span>
</pre></div>
</div>
<p>Be careful to check your assumptions when using the implicit option
since <code class="docutils literal notranslate"><span class="pre">S(1).is_Integer</span> <span class="pre">=</span> <span class="pre">True</span></code> but <code class="docutils literal notranslate"><span class="pre">type(S(1))</span></code> is <code class="docutils literal notranslate"><span class="pre">One</span></code>, a special type
of sympy atom, while <code class="docutils literal notranslate"><span class="pre">type(S(2))</span></code> is type <code class="docutils literal notranslate"><span class="pre">Integer</span></code> and will find all
integers in an expression:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">S</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">{1}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">{1, 2}</span>
</pre></div>
</div>
<p>Finally, arguments to atoms() can select more than atomic atoms: any
sympy type (loaded in core/__init__.py) can be listed as an argument
and those types of “atoms” as found in scanning the arguments of the
expression recursively:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Mul</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.core.function</span> <span class="k">import</span> <span class="n">AppliedUndef</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Function</span><span class="p">)</span>
<span class="go">{f(x), sin(y + I*pi)}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">AppliedUndef</span><span class="p">)</span>
<span class="go">{f(x)}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Mul</span><span class="p">)</span>
<span class="go">{I*pi, 2*sin(y + I*pi)}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.binary_symbols">
<em class="property">property </em><code class="sig-name descname">binary_symbols</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.binary_symbols" title="Permalink to this definition">¶</a></dt>
<dd><p>Return from the atoms of self those which are free symbols.</p>
<p>For most expressions, all symbols are free symbols. For some classes
this is not true. e.g. Integrals use Symbols for the dummy variables
which are bound variables, so Integral has a method to return all
symbols except those. Derivative keeps track of symbols with respect
to which it will perform a derivative; those are
bound variables, too, so it has its own free_symbols method.</p>
<p>Any other method that uses bound variables should implement a
free_symbols method.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.cancel">
<code class="sig-name descname">cancel</code><span class="sig-paren">(</span><em class="sig-param">*gens</em>, <em class="sig-param">**args</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.cancel" title="Permalink to this definition">¶</a></dt>
<dd><p>See the cancel function in sympy.polys</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.canonical_variables">
<em class="property">property </em><code class="sig-name descname">canonical_variables</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.canonical_variables" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dictionary mapping any variable defined in
<code class="docutils literal notranslate"><span class="pre">self.bound_symbols</span></code> to Symbols that do not clash
with any existing symbol in the expression.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Lambda</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Lambda</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">canonical_variables</span>
<span class="go">{x: _0}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.class_key">
<em class="property">classmethod </em><code class="sig-name descname">class_key</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.class_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Nice order of classes.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.coeff">
<code class="sig-name descname">coeff</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">n=1</em>, <em class="sig-param">right=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.coeff" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the coefficient from the term(s) containing <code class="docutils literal notranslate"><span class="pre">x**n</span></code>. If <code class="docutils literal notranslate"><span class="pre">n</span></code>
is zero then all terms independent of <code class="docutils literal notranslate"><span class="pre">x</span></code> will be returned.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">x</span></code> is noncommutative, the coefficient to the left (default) or
right of <code class="docutils literal notranslate"><span class="pre">x</span></code> can be returned. The keyword ‘right’ is ignored when
<code class="docutils literal notranslate"><span class="pre">x</span></code> is commutative.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Beta.as_coefficient" title="nipy.algorithms.statistics.formula.formulae.Beta.as_coefficient"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_coefficient</span></code></a></dt><dd><p>separate the expression into a coefficient and factor</p>
</dd>
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Beta.as_coeff_Add" title="nipy.algorithms.statistics.formula.formulae.Beta.as_coeff_Add"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_coeff_Add</span></code></a></dt><dd><p>separate the additive constant from an expression</p>
</dd>
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Beta.as_coeff_Mul" title="nipy.algorithms.statistics.formula.formulae.Beta.as_coeff_Mul"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_coeff_Mul</span></code></a></dt><dd><p>separate the multiplicative constant from an expression</p>
</dd>
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Beta.as_independent" title="nipy.algorithms.statistics.formula.formulae.Beta.as_independent"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_independent</span></code></a></dt><dd><p>separate x-dependent terms/factors from others</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.polys.polytools.coeff_monomial</span></code></dt><dd><p>efficiently find the single coefficient of a monomial in Poly</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.polys.polytools.nth</span></code></dt><dd><p>like coeff_monomial but powers of monomial terms are used</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
</pre></div>
</div>
<p>You can select terms that have an explicit negative in front of them:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">-</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">2*y</span>
</pre></div>
</div>
<p>You can select terms with no Rational coefficient:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<p>You can select terms independent of x by making n=0; in this case
expr.as_independent(x)[0] is returned (and 0 will be returned instead
of None):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span>
<span class="go">x**3 + 3*x**2 + 3*x + 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">eq</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))]</span>
<span class="go">[1, 3, 3, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">-=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">eq</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))]</span>
<span class="go">[1, 3, 3, 0]</span>
</pre></div>
</div>
<p>You can select terms that have a numerical term in front of them:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">-</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">-y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">sqrt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">x</span>
</pre></div>
</div>
<p>The matching is exact:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">z</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="go">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">z</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<p>In addition, no factoring is done, so 1 + z*(1 + y) is not obtained
from the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">z</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
<p>If such factoring is desired, factor_terms can be used first:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">factor_terms</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factor_terms</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">z</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">z*(y + 1) + 1</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">o</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;n m o&#39;</span><span class="p">,</span> <span class="n">commutative</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">m</span> <span class="o">+</span> <span class="n">m</span><span class="o">*</span><span class="n">n</span><span class="o">*</span><span class="n">m</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="c1"># = (1 + m)*n*m</span>
<span class="go">1 + m</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">m</span> <span class="o">+</span> <span class="n">m</span><span class="o">*</span><span class="n">n</span><span class="o">*</span><span class="n">m</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># = (1 + m)*n*m</span>
<span class="go">m</span>
</pre></div>
</div>
<p>If there is more than one possible coefficient 0 is returned:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">m</span> <span class="o">+</span> <span class="n">m</span><span class="o">*</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<p>If there is only one possible coefficient, it is returned:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">m</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">m</span><span class="o">*</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">m</span><span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="go">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">m</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">m</span><span class="o">*</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">m</span><span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.collect">
<code class="sig-name descname">collect</code><span class="sig-paren">(</span><em class="sig-param">syms</em>, <em class="sig-param">func=None</em>, <em class="sig-param">evaluate=True</em>, <em class="sig-param">exact=False</em>, <em class="sig-param">distribute_order_term=True</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.collect" title="Permalink to this definition">¶</a></dt>
<dd><p>See the collect function in sympy.simplify</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.combsimp">
<code class="sig-name descname">combsimp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.combsimp" title="Permalink to this definition">¶</a></dt>
<dd><p>See the combsimp function in sympy.simplify</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.compare">
<code class="sig-name descname">compare</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.compare" title="Permalink to this definition">¶</a></dt>
<dd><p>Return -1, 0, 1 if the object is smaller, equal, or greater than other.</p>
<p>Not in the mathematical sense. If the object is of a different type
from the “other” then their classes are ordered according to
the sorted_classes list.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">-1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.compute_leading_term">
<code class="sig-name descname">compute_leading_term</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">logx=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.compute_leading_term" title="Permalink to this definition">¶</a></dt>
<dd><p>as_leading_term is only allowed for results of .series()
This is a wrapper to compute a series first.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.conjugate">
<code class="sig-name descname">conjugate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.conjugate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.could_extract_minus_sign">
<code class="sig-name descname">could_extract_minus_sign</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.could_extract_minus_sign" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if self is not in a canonical form with respect
to its sign.</p>
<p>For most expressions, e, there will be a difference in e and -e.
When there is, True will be returned for one and False for the
other; False will be returned if there is no difference.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">{</span><span class="n">i</span><span class="o">.</span><span class="n">could_extract_minus_sign</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="o">-</span><span class="n">e</span><span class="p">)}</span>
<span class="go">{False, True}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.count">
<code class="sig-name descname">count</code><span class="sig-paren">(</span><em class="sig-param">query</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Count the number of matching subexpressions.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.count_ops">
<code class="sig-name descname">count_ops</code><span class="sig-paren">(</span><em class="sig-param">visual=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.count_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper for count_ops that returns the operation count.</p>
</dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.default_assumptions">
<code class="sig-name descname">default_assumptions</code><em class="property"> = {}</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.default_assumptions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.diff">
<code class="sig-name descname">diff</code><span class="sig-paren">(</span><em class="sig-param">*symbols</em>, <em class="sig-param">**assumptions</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.diff" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.doit">
<code class="sig-name descname">doit</code><span class="sig-paren">(</span><em class="sig-param">**hints</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.doit" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate objects that are not evaluated by default like limits,
integrals, sums and products. All objects of this kind will be
evaluated recursively, unless some species were excluded via ‘hints’
or unless the ‘deep’ hint was set to ‘False’.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Integral</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">2</span><span class="o">*</span><span class="n">Integral</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">2*Integral(x, x)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Integral</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">doit</span><span class="p">()</span>
<span class="go">x**2</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Integral</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">doit</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">2*Integral(x, x)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.dummy_eq">
<code class="sig-name descname">dummy_eq</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">symbol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.dummy_eq" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two expressions and handle dummy symbols.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Dummy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s1">&#39;u&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">dummy_eq</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">dummy_eq</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">dummy_eq</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.dummy_index">
<code class="sig-name descname">dummy_index</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.dummy_index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.equals">
<code class="sig-name descname">equals</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">failing_expression=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.equals" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if self == other, False if it doesn’t, or None. If
failing_expression is True then the expression which did not simplify
to a 0 will be returned instead of None.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">self</span></code> is a Number (or complex number) that is not zero, then
the result is False.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">self</span></code> is a number and has not evaluated to zero, evalf will be
used to test whether the expression evaluates to zero. If it does so
and the result has significance (i.e. the precision is either -1, for
a Rational result, or is greater than 1) then the evalf value will be
used to return True or False.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.evalf">
<code class="sig-name descname">evalf</code><span class="sig-paren">(</span><em class="sig-param">n=15</em>, <em class="sig-param">subs=None</em>, <em class="sig-param">maxn=100</em>, <em class="sig-param">chop=False</em>, <em class="sig-param">strict=False</em>, <em class="sig-param">quad=None</em>, <em class="sig-param">verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.evalf" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the given formula to an accuracy of n digits.
Optional keyword arguments:</p>
<blockquote>
<div><dl class="simple">
<dt>subs=&lt;dict&gt;</dt><dd><p>Substitute numerical values for symbols, e.g.
subs={x:3, y:1+pi}. The substitutions must be given as a
dictionary.</p>
</dd>
<dt>maxn=&lt;integer&gt;</dt><dd><p>Allow a maximum temporary working precision of maxn digits
(default=100)</p>
</dd>
<dt>chop=&lt;bool&gt;</dt><dd><p>Replace tiny real or imaginary parts in subresults
by exact zeros (default=False)</p>
</dd>
<dt>strict=&lt;bool&gt;</dt><dd><p>Raise PrecisionExhausted if any subresult fails to evaluate
to full accuracy, given the available maxprec
(default=False)</p>
</dd>
<dt>quad=&lt;str&gt;</dt><dd><p>Choose algorithm for numerical quadrature. By default,
tanh-sinh quadrature is used. For oscillatory
integrals on an infinite interval, try quad=’osc’.</p>
</dd>
<dt>verbose=&lt;bool&gt;</dt><dd><p>Print debug information (default=False)</p>
</dd>
</dl>
</div></blockquote>
<p class="rubric">Notes</p>
<p>When Floats are naively substituted into an expression, precision errors
may adversely affect the result. For example, adding 1e16 (a Float) to 1
will truncate to 1e16; if 1e16 is then subtracted, the result will be 0.
That is exactly what happens in the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="mf">1e16</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="mf">1e16</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">-</span> <span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<p>Using the subs argument for evalf is the accurate way to evaluate such an
expression:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">-</span> <span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="n">subs</span><span class="o">=</span><span class="n">values</span><span class="p">)</span>
<span class="go">1.00000000000000</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.expand">
<code class="sig-name descname">expand</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.expand" title="Permalink to this definition">¶</a></dt>
<dd><p>Expand an expression using hints.</p>
<p>See the docstring of the expand() function in sympy.core.function for
more information.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.expr_free_symbols">
<em class="property">property </em><code class="sig-name descname">expr_free_symbols</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.expr_free_symbols" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <code class="docutils literal notranslate"><span class="pre">free_symbols</span></code>, but returns the free symbols only if they are contained in an expression node.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">expr_free_symbols</span>
<span class="go">{x, y}</span>
</pre></div>
</div>
<p>If the expression is contained in a non-expression object, don’t return
the free symbols. Compare:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Tuple</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">expr_free_symbols</span>
<span class="go">set()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">free_symbols</span>
<span class="go">{x, y}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.extract_additively">
<code class="sig-name descname">extract_additively</code><span class="sig-paren">(</span><em class="sig-param">c</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.extract_additively" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self - c if it’s possible to subtract c from self and
make all matching coefficients move towards zero, else return None.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Beta.extract_multiplicatively" title="nipy.algorithms.statistics.formula.formulae.Beta.extract_multiplicatively"><code class="xref py py-obj docutils literal notranslate"><span class="pre">extract_multiplicatively</span></code></a>, <a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Beta.coeff" title="nipy.algorithms.statistics.formula.formulae.Beta.coeff"><code class="xref py py-obj docutils literal notranslate"><span class="pre">coeff</span></code></a>, <a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Beta.as_coefficient" title="nipy.algorithms.statistics.formula.formulae.Beta.as_coefficient"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_coefficient</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">x + 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">y</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">(x + 1)*(x + 2*y) + 3</span>
</pre></div>
</div>
<p>Sometimes auto-expansion will return a less simplified result
than desired; gcd_terms might be used in such cases:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">gcd_terms</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">4*x*(y + 1) + x*(4*y + 3) - x*(4*y + 4) + y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gcd_terms</span><span class="p">(</span><span class="n">_</span><span class="p">)</span>
<span class="go">x*(4*y + 3) + y</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.extract_branch_factor">
<code class="sig-name descname">extract_branch_factor</code><span class="sig-paren">(</span><em class="sig-param">allow_half=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.extract_branch_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Try to write self as <code class="docutils literal notranslate"><span class="pre">exp_polar(2*pi*I*n)*z</span></code> in a nice way.
Return (z, n).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">exp_polar</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">pi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exp_polar</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span><span class="o">.</span><span class="n">extract_branch_factor</span><span class="p">()</span>
<span class="go">(exp_polar(I*pi), 0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exp_polar</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span><span class="o">.</span><span class="n">extract_branch_factor</span><span class="p">()</span>
<span class="go">(1, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exp_polar</span><span class="p">(</span><span class="o">-</span><span class="n">pi</span><span class="o">*</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">extract_branch_factor</span><span class="p">()</span>
<span class="go">(exp_polar(I*pi), -1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exp_polar</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">extract_branch_factor</span><span class="p">()</span>
<span class="go">(exp_polar(x + I*pi), 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">y</span><span class="o">*</span><span class="n">exp_polar</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">I</span><span class="p">)</span><span class="o">*</span><span class="n">exp_polar</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">extract_branch_factor</span><span class="p">()</span>
<span class="go">(y*exp_polar(2*pi*x), -1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exp_polar</span><span class="p">(</span><span class="o">-</span><span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">extract_branch_factor</span><span class="p">()</span>
<span class="go">(exp_polar(-I*pi/2), 0)</span>
</pre></div>
</div>
<p>If allow_half is True, also extract exp_polar(I*pi):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">exp_polar</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span><span class="o">.</span><span class="n">extract_branch_factor</span><span class="p">(</span><span class="n">allow_half</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(1, 1/2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exp_polar</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span><span class="o">.</span><span class="n">extract_branch_factor</span><span class="p">(</span><span class="n">allow_half</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(1, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exp_polar</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span><span class="o">.</span><span class="n">extract_branch_factor</span><span class="p">(</span><span class="n">allow_half</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(1, 3/2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exp_polar</span><span class="p">(</span><span class="o">-</span><span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span><span class="o">.</span><span class="n">extract_branch_factor</span><span class="p">(</span><span class="n">allow_half</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(1, -1/2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.extract_multiplicatively">
<code class="sig-name descname">extract_multiplicatively</code><span class="sig-paren">(</span><em class="sig-param">c</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.extract_multiplicatively" title="Permalink to this definition">¶</a></dt>
<dd><p>Return None if it’s not possible to make self in the form
c * something in a nice way, i.e. preserving the properties
of arguments of self.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">Rational</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x,y&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">extract_multiplicatively</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span>
<span class="go">x*y**2</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">extract_multiplicatively</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">4</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">extract_multiplicatively</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">x</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">extract_multiplicatively</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">extract_multiplicatively</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">x/6</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.factor">
<code class="sig-name descname">factor</code><span class="sig-paren">(</span><em class="sig-param">*gens</em>, <em class="sig-param">**args</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.factor" title="Permalink to this definition">¶</a></dt>
<dd><p>See the factor() function in sympy.polys.polytools</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.find">
<code class="sig-name descname">find</code><span class="sig-paren">(</span><em class="sig-param">query</em>, <em class="sig-param">group=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.find" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all subexpressions matching a query.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.fourier_series">
<code class="sig-name descname">fourier_series</code><span class="sig-paren">(</span><em class="sig-param">limits=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.fourier_series" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute fourier sine/cosine series of self.</p>
<p>See the docstring of the <a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Beta.fourier_series" title="nipy.algorithms.statistics.formula.formulae.Beta.fourier_series"><code class="xref py py-func docutils literal notranslate"><span class="pre">fourier_series()</span></code></a> in sympy.series.fourier
for more information.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.fps">
<code class="sig-name descname">fps</code><span class="sig-paren">(</span><em class="sig-param">x=None</em>, <em class="sig-param">x0=0</em>, <em class="sig-param">dir=1</em>, <em class="sig-param">hyper=True</em>, <em class="sig-param">order=4</em>, <em class="sig-param">rational=True</em>, <em class="sig-param">full=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.fps" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute formal power power series of self.</p>
<p>See the docstring of the <a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Beta.fps" title="nipy.algorithms.statistics.formula.formulae.Beta.fps"><code class="xref py py-func docutils literal notranslate"><span class="pre">fps()</span></code></a> function in sympy.series.formal for
more information.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.free_symbols">
<em class="property">property </em><code class="sig-name descname">free_symbols</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.free_symbols" title="Permalink to this definition">¶</a></dt>
<dd><p>Return from the atoms of self those which are free symbols.</p>
<p>For most expressions, all symbols are free symbols. For some classes
this is not true. e.g. Integrals use Symbols for the dummy variables
which are bound variables, so Integral has a method to return all
symbols except those. Derivative keeps track of symbols with respect
to which it will perform a derivative; those are
bound variables, too, so it has its own free_symbols method.</p>
<p>Any other method that uses bound variables should implement a
free_symbols method.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.fromiter">
<em class="property">classmethod </em><code class="sig-name descname">fromiter</code><span class="sig-paren">(</span><em class="sig-param">args</em>, <em class="sig-param">**assumptions</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.fromiter" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new object from an iterable.</p>
<p>This is a convenience function that allows one to create objects from
any iterable, without having to convert to a list or tuple first.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Tuple</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Tuple</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">(0, 1, 2, 3, 4)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.func">
<em class="property">property </em><code class="sig-name descname">func</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.func" title="Permalink to this definition">¶</a></dt>
<dd><p>The top-level function in an expression.</p>
<p>The following should hold for all objects:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;</span> <span class="n">x</span> <span class="o">==</span> <span class="n">x</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">func</span>
<span class="go">&lt;class &#39;sympy.core.mul.Mul&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">args</span>
<span class="go">(2, x)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
<span class="go">2*x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">==</span> <span class="n">a</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.gammasimp">
<code class="sig-name descname">gammasimp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.gammasimp" title="Permalink to this definition">¶</a></dt>
<dd><p>See the gammasimp function in sympy.simplify</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.getO">
<code class="sig-name descname">getO</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.getO" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the additive O(..) symbol if there is one, else None.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.getn">
<code class="sig-name descname">getn</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.getn" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the order of the expression.</p>
<p>The order is determined either from the O(…) term. If there
is no O(…) term, it returns None.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">O</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="n">O</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">getn</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">getn</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.has">
<code class="sig-name descname">has</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.has" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether any subexpression matches any of the patterns.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">sin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Note <code class="docutils literal notranslate"><span class="pre">has</span></code> is a structural algorithm with no knowledge of
mathematics. Consider the following half-open interval:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.sets</span> <span class="k">import</span> <span class="n">Interval</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">Interval</span><span class="o">.</span><span class="n">Lopen</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span> <span class="n">i</span>
<span class="go">Interval.Lopen(0, 5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">args</span>
<span class="go">(0, 5, True, False)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># there is no &quot;4&quot; in the arguments</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># there *is* a &quot;0&quot; in the arguments</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Instead, use <code class="docutils literal notranslate"><span class="pre">contains</span></code> to determine whether a number is in the
interval or not:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">expr.has(*patterns)</span></code> is exactly equivalent to
<code class="docutils literal notranslate"><span class="pre">any(expr.has(p)</span> <span class="pre">for</span> <span class="pre">p</span> <span class="pre">in</span> <span class="pre">patterns)</span></code>. In particular, <code class="docutils literal notranslate"><span class="pre">False</span></code> is
returned when the list of patterns is empty.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">has</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.integrate">
<code class="sig-name descname">integrate</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.integrate" title="Permalink to this definition">¶</a></dt>
<dd><p>See the integrate function in sympy.integrals</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.invert">
<code class="sig-name descname">invert</code><span class="sig-paren">(</span><em class="sig-param">g</em>, <em class="sig-param">*gens</em>, <em class="sig-param">**args</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.invert" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the multiplicative inverse of <code class="docutils literal notranslate"><span class="pre">self</span></code> mod <code class="docutils literal notranslate"><span class="pre">g</span></code>
where <code class="docutils literal notranslate"><span class="pre">self</span></code> (and <code class="docutils literal notranslate"><span class="pre">g</span></code>) may be symbolic expressions).</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.core.numbers.mod_inverse</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.polys.polytools.invert</span></code></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_Add">
<code class="sig-name descname">is_Add</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_Add" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_AlgebraicNumber">
<code class="sig-name descname">is_AlgebraicNumber</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_AlgebraicNumber" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_Atom">
<code class="sig-name descname">is_Atom</code><em class="property"> = True</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_Atom" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_Boolean">
<code class="sig-name descname">is_Boolean</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_Boolean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_Derivative">
<code class="sig-name descname">is_Derivative</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_Derivative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_Dummy">
<code class="sig-name descname">is_Dummy</code><em class="property"> = True</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_Dummy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_Equality">
<code class="sig-name descname">is_Equality</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_Equality" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_Float">
<code class="sig-name descname">is_Float</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_Float" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_Function">
<code class="sig-name descname">is_Function</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_Function" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_Indexed">
<code class="sig-name descname">is_Indexed</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_Indexed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_Integer">
<code class="sig-name descname">is_Integer</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_Integer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_MatAdd">
<code class="sig-name descname">is_MatAdd</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_MatAdd" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_MatMul">
<code class="sig-name descname">is_MatMul</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_MatMul" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_Matrix">
<code class="sig-name descname">is_Matrix</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_Matrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_Mul">
<code class="sig-name descname">is_Mul</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_Mul" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_Not">
<code class="sig-name descname">is_Not</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_Not" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_Number">
<code class="sig-name descname">is_Number</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_Number" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_NumberSymbol">
<code class="sig-name descname">is_NumberSymbol</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_NumberSymbol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_Order">
<code class="sig-name descname">is_Order</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_Order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_Piecewise">
<code class="sig-name descname">is_Piecewise</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_Piecewise" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_Point">
<code class="sig-name descname">is_Point</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_Point" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_Poly">
<code class="sig-name descname">is_Poly</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_Poly" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_Pow">
<code class="sig-name descname">is_Pow</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_Pow" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_Rational">
<code class="sig-name descname">is_Rational</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_Rational" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_Relational">
<code class="sig-name descname">is_Relational</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_Relational" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_Symbol">
<code class="sig-name descname">is_Symbol</code><em class="property"> = True</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_Symbol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_Vector">
<code class="sig-name descname">is_Vector</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_Vector" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_Wild">
<code class="sig-name descname">is_Wild</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_Wild" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_algebraic">
<em class="property">property </em><code class="sig-name descname">is_algebraic</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_algebraic" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_algebraic_expr">
<code class="sig-name descname">is_algebraic_expr</code><span class="sig-paren">(</span><em class="sig-param">*syms</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_algebraic_expr" title="Permalink to this definition">¶</a></dt>
<dd><p>This tests whether a given expression is algebraic or not, in the
given symbols, syms. When syms is not given, all free symbols
will be used. The rational function does not have to be in expanded
or in any kind of canonical form.</p>
<p>This function returns False for expressions that are “algebraic
expressions” with symbolic exponents. This is a simple extension to the
is_rational_function, including rational exponentiation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_rational_function" title="nipy.algorithms.statistics.formula.formulae.Beta.is_rational_function"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_rational_function</span></code></a></p>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Algebraic_expression">https://en.wikipedia.org/wiki/Algebraic_expression</a></p></li>
</ul>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">sqrt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">is_rational_function</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">is_algebraic_expr</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>This function does not attempt any nontrivial simplifications that may
result in an expression that does not appear to be an algebraic
expression to become one.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">exp</span><span class="p">,</span> <span class="n">factor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">is_algebraic_expr</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factor</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">is_algebraic_expr</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_antihermitian">
<em class="property">property </em><code class="sig-name descname">is_antihermitian</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_antihermitian" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_commutative">
<em class="property">property </em><code class="sig-name descname">is_commutative</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_commutative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_comparable">
<code class="sig-name descname">is_comparable</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_comparable" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_complex">
<em class="property">property </em><code class="sig-name descname">is_complex</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_complex" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_composite">
<em class="property">property </em><code class="sig-name descname">is_composite</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_composite" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_constant">
<code class="sig-name descname">is_constant</code><span class="sig-paren">(</span><em class="sig-param">*wrt</em>, <em class="sig-param">**flags</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_constant" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if self is constant, False if not, or None if
the constancy could not be determined conclusively.</p>
<p>If an expression has no free symbols then it is a constant. If
there are free symbols it is possible that the expression is a
constant, perhaps (but not necessarily) zero. To test such
expressions, two strategies are tried:</p>
<p>1) numerical evaluation at two random points. If two such evaluations
give two different values and the values have a precision greater than
1 then self is not constant. If the evaluations agree or could not be
obtained with any precision, no decision is made. The numerical testing
is done only if <code class="docutils literal notranslate"><span class="pre">wrt</span></code> is different than the free symbols.</p>
<p>2) differentiation with respect to variables in ‘wrt’ (or all free
symbols if omitted) to see if the expression is constant or not. This
will not always lead to an expression that is zero even though an
expression is constant (see added test in test_expr.py). If
all derivatives are zero then self is constant with respect to the
given symbols.</p>
<p>If neither evaluation nor differentiation can prove the expression is
constant, None is returned unless two numerical values happened to be
the same and the flag <code class="docutils literal notranslate"><span class="pre">failing_number</span></code> is True – in that case the
numerical value will be returned.</p>
<p>If flag simplify=False is passed, self will not be simplified;
the default is True since self should be simplified before testing.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">cos</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">Sum</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">pi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">a</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">is_constant</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">is_constant</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span><span class="o">.</span><span class="n">is_constant</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span><span class="o">.</span><span class="n">is_constant</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span><span class="o">.</span><span class="n">is_constant</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span><span class="o">.</span><span class="n">is_constant</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span><span class="o">.</span><span class="n">is_constant</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span><span class="o">.</span><span class="n">is_constant</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">pi</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span> <span class="o">==</span> <span class="n">eq</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">pi</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="mi">3</span><span class="p">})</span> <span class="o">==</span> <span class="mi">0</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">0</span><span class="o">**</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">is_constant</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">is_constant</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">is_constant</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">one</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">one</span><span class="o">.</span><span class="n">is_constant</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="n">one</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">is_constant</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="c1"># could be 0 or 1</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_even">
<em class="property">property </em><code class="sig-name descname">is_even</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_even" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_finite">
<em class="property">property </em><code class="sig-name descname">is_finite</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_finite" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_hermitian">
<em class="property">property </em><code class="sig-name descname">is_hermitian</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_hermitian" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_hypergeometric">
<code class="sig-name descname">is_hypergeometric</code><span class="sig-paren">(</span><em class="sig-param">k</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_hypergeometric" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_imaginary">
<em class="property">property </em><code class="sig-name descname">is_imaginary</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_imaginary" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_infinite">
<em class="property">property </em><code class="sig-name descname">is_infinite</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_infinite" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_integer">
<em class="property">property </em><code class="sig-name descname">is_integer</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_integer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_irrational">
<em class="property">property </em><code class="sig-name descname">is_irrational</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_irrational" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_negative">
<em class="property">property </em><code class="sig-name descname">is_negative</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_negative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_noninteger">
<em class="property">property </em><code class="sig-name descname">is_noninteger</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_noninteger" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_nonnegative">
<em class="property">property </em><code class="sig-name descname">is_nonnegative</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_nonnegative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_nonpositive">
<em class="property">property </em><code class="sig-name descname">is_nonpositive</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_nonpositive" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_nonzero">
<em class="property">property </em><code class="sig-name descname">is_nonzero</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_nonzero" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_number">
<code class="sig-name descname">is_number</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_number" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_odd">
<em class="property">property </em><code class="sig-name descname">is_odd</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_odd" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_polar">
<em class="property">property </em><code class="sig-name descname">is_polar</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_polar" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_polynomial">
<code class="sig-name descname">is_polynomial</code><span class="sig-paren">(</span><em class="sig-param">*syms</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if self is a polynomial in syms and False otherwise.</p>
<p>This checks if self is an exact polynomial in syms.  This function
returns False for expressions that are “polynomials” with symbolic
exponents.  Thus, you should be able to apply polynomial algorithms to
expressions for which this returns True, and Poly(expr, *syms) should
work if and only if expr.is_polynomial(*syms) returns True. The
polynomial does not have to be in expanded form.  If no symbols are
given, all free symbols in the expression will be used.</p>
<p>This is not part of the assumptions system.  You cannot do
Symbol(‘z’, polynomial=True).</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Symbol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">is_polynomial</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">is_polynomial</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">is_polynomial</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="n">nonnegative</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">is_polynomial</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>This function does not attempt any nontrivial simplifications that may
result in an expression that does not appear to be a polynomial to
become one.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">factor</span><span class="p">,</span> <span class="n">cancel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">is_polynomial</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factor</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">y + 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factor</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">is_polynomial</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">is_polynomial</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cancel</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">y + 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cancel</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">is_polynomial</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>See also .is_rational_function()</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_positive">
<em class="property">property </em><code class="sig-name descname">is_positive</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_positive" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_prime">
<em class="property">property </em><code class="sig-name descname">is_prime</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_prime" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_rational">
<em class="property">property </em><code class="sig-name descname">is_rational</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_rational" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_rational_function">
<code class="sig-name descname">is_rational_function</code><span class="sig-paren">(</span><em class="sig-param">*syms</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_rational_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether function is a ratio of two polynomials in the given
symbols, syms. When syms is not given, all free symbols will be used.
The rational function does not have to be in expanded or in any kind of
canonical form.</p>
<p>This function returns False for expressions that are “rational
functions” with symbolic exponents.  Thus, you should be able to call
.as_numer_denom() and apply polynomial algorithms to the result for
expressions for which this returns True.</p>
<p>This is not part of the assumptions system.  You cannot do
Symbol(‘z’, rational_function=True).</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">sin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">is_rational_function</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">is_rational_function</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">is_rational_function</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">is_rational_function</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>This function does not attempt any nontrivial simplifications that may
result in an expression that does not appear to be a rational function
to become one.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">factor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">is_rational_function</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factor</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">(y + 1)/y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factor</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">is_rational_function</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>See also is_algebraic_expr().</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_real">
<em class="property">property </em><code class="sig-name descname">is_real</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_real" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_scalar">
<code class="sig-name descname">is_scalar</code><em class="property"> = True</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_scalar" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_symbol">
<code class="sig-name descname">is_symbol</code><em class="property"> = True</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_symbol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_transcendental">
<em class="property">property </em><code class="sig-name descname">is_transcendental</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_transcendental" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.is_zero">
<em class="property">property </em><code class="sig-name descname">is_zero</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.is_zero" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.leadterm">
<code class="sig-name descname">leadterm</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.leadterm" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the leading term a*x**b as a tuple (a, b).</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">x</span><span class="o">+</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">leadterm</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">(1, 0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">x</span><span class="o">+</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">leadterm</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">(1, -2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.limit">
<code class="sig-name descname">limit</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">xlim</em>, <em class="sig-param">dir='+'</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute limit x-&gt;xlim.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.lseries">
<code class="sig-name descname">lseries</code><span class="sig-paren">(</span><em class="sig-param">x=None</em>, <em class="sig-param">x0=0</em>, <em class="sig-param">dir='+'</em>, <em class="sig-param">logx=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.lseries" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper for series yielding an iterator of the terms of the series.</p>
<p>Note: an infinite series will yield an infinite iterator. The following,
for exaxmple, will never terminate. It will just keep printing terms
of the sin(x) series:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">lseries</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="nb">print</span> <span class="n">term</span>
</pre></div>
</div>
<p>The advantage of lseries() over nseries() is that many times you are
just interested in the next term in the series (i.e. the first term for
example), but you don’t know how many you should ask for in nseries()
using the “n” parameter.</p>
<p>See also nseries().</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.match">
<code class="sig-name descname">match</code><span class="sig-paren">(</span><em class="sig-param">pattern</em>, <em class="sig-param">old=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.match" title="Permalink to this definition">¶</a></dt>
<dd><p>Pattern matching.</p>
<p>Wild symbols match all.</p>
<p>Return <code class="docutils literal notranslate"><span class="pre">None</span></code> when expression (self) does not match
with pattern. Otherwise return a dictionary such that:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pattern</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">pattern</span><span class="p">))</span> <span class="o">==</span> <span class="bp">self</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Wild</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s2">&quot;q&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="n">p</span><span class="p">)</span>
<span class="go">{p_: x + y}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="n">q</span><span class="p">)</span>
<span class="go">{p_: x + y, q_: x + y}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">q</span><span class="o">**</span><span class="n">r</span><span class="p">)</span>
<span class="go">{p_: 4, q_: x, r_: 2}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">q</span><span class="o">**</span><span class="n">r</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">q</span><span class="o">**</span><span class="n">r</span><span class="p">))</span>
<span class="go">4*x**2</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">old</span></code> flag will give the old-style pattern matching where
expressions and patterns are essentially solved to give the
match. Both of the following give None unless <code class="docutils literal notranslate"><span class="pre">old=True</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">x</span><span class="p">,</span> <span class="n">old</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{p_: 2*x - 2}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">old</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{p_: 2/x**2}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.matches">
<code class="sig-name descname">matches</code><span class="sig-paren">(</span><em class="sig-param">expr</em>, <em class="sig-param">repl_dict={}</em>, <em class="sig-param">old=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.matches" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper method for match() that looks for a match between Wild symbols
in self and expressions in expr.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">Wild</span><span class="p">,</span> <span class="n">Basic</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;a b c&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Basic</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">Basic</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Basic</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">Basic</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">))</span>
<span class="go">{x_: b + c}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.n">
<code class="sig-name descname">n</code><span class="sig-paren">(</span><em class="sig-param">n=15</em>, <em class="sig-param">subs=None</em>, <em class="sig-param">maxn=100</em>, <em class="sig-param">chop=False</em>, <em class="sig-param">strict=False</em>, <em class="sig-param">quad=None</em>, <em class="sig-param">verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.n" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the given formula to an accuracy of n digits.
Optional keyword arguments:</p>
<blockquote>
<div><dl class="simple">
<dt>subs=&lt;dict&gt;</dt><dd><p>Substitute numerical values for symbols, e.g.
subs={x:3, y:1+pi}. The substitutions must be given as a
dictionary.</p>
</dd>
<dt>maxn=&lt;integer&gt;</dt><dd><p>Allow a maximum temporary working precision of maxn digits
(default=100)</p>
</dd>
<dt>chop=&lt;bool&gt;</dt><dd><p>Replace tiny real or imaginary parts in subresults
by exact zeros (default=False)</p>
</dd>
<dt>strict=&lt;bool&gt;</dt><dd><p>Raise PrecisionExhausted if any subresult fails to evaluate
to full accuracy, given the available maxprec
(default=False)</p>
</dd>
<dt>quad=&lt;str&gt;</dt><dd><p>Choose algorithm for numerical quadrature. By default,
tanh-sinh quadrature is used. For oscillatory
integrals on an infinite interval, try quad=’osc’.</p>
</dd>
<dt>verbose=&lt;bool&gt;</dt><dd><p>Print debug information (default=False)</p>
</dd>
</dl>
</div></blockquote>
<p class="rubric">Notes</p>
<p>When Floats are naively substituted into an expression, precision errors
may adversely affect the result. For example, adding 1e16 (a Float) to 1
will truncate to 1e16; if 1e16 is then subtracted, the result will be 0.
That is exactly what happens in the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="mf">1e16</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="mf">1e16</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">-</span> <span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<p>Using the subs argument for evalf is the accurate way to evaluate such an
expression:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">-</span> <span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="n">subs</span><span class="o">=</span><span class="n">values</span><span class="p">)</span>
<span class="go">1.00000000000000</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.name">
<code class="sig-name descname">name</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.normal">
<code class="sig-name descname">normal</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.normal" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.nseries">
<code class="sig-name descname">nseries</code><span class="sig-paren">(</span><em class="sig-param">x=None</em>, <em class="sig-param">x0=0</em>, <em class="sig-param">n=6</em>, <em class="sig-param">dir='+'</em>, <em class="sig-param">logx=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.nseries" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper to _eval_nseries if assumptions allow, else to series.</p>
<p>If x is given, x0 is 0, dir=’+’, and self has x, then _eval_nseries is
called. This calculates “n” terms in the innermost expressions and
then builds up the final series just by “cross-multiplying” everything
out.</p>
<p>The optional <code class="docutils literal notranslate"><span class="pre">logx</span></code> parameter can be used to replace any log(x) in the
returned series with a symbolic value to avoid evaluating log(x) at 0. A
symbol to use in place of log(x) should be provided.</p>
<p>Advantage – it’s fast, because we don’t have to determine how many
terms we need to calculate in advance.</p>
<p>Disadvantage – you may end up with less terms than you may have
expected, but the O(x**n) term appended will always be correct and
so the result, though perhaps shorter, will also be correct.</p>
<p>If any of those assumptions is not met, this is treated like a
wrapper to series which will try harder to return the correct
number of terms.</p>
<p>See also lseries().</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">sin</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">Symbol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">nseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="go">x - x**3/6 + x**5/120 + O(x**6)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">nseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">x - x**2/2 + x**3/3 - x**4/4 + O(x**5)</span>
</pre></div>
</div>
<p>Handling of the <code class="docutils literal notranslate"><span class="pre">logx</span></code> parameter — in the following example the
expansion fails since <code class="docutils literal notranslate"><span class="pre">sin</span></code> does not have an asymptotic expansion
at -oo (the limit of log(x) as x approaches 0):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">nseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">PoleError</span>: <span class="n">...</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">logx</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;logx&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">nseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="n">logx</span><span class="p">)</span>
<span class="go">sin(logx)</span>
</pre></div>
</div>
<p>In the following example, the expansion works but gives only an Order term
unless the <code class="docutils literal notranslate"><span class="pre">logx</span></code> parameter is used:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">nseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">O(log(x)**2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">nseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="n">logx</span><span class="p">)</span>
<span class="go">exp(logx*y)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.nsimplify">
<code class="sig-name descname">nsimplify</code><span class="sig-paren">(</span><em class="sig-param">constants=[]</em>, <em class="sig-param">tolerance=None</em>, <em class="sig-param">full=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.nsimplify" title="Permalink to this definition">¶</a></dt>
<dd><p>See the nsimplify function in sympy.simplify</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.powsimp">
<code class="sig-name descname">powsimp</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.powsimp" title="Permalink to this definition">¶</a></dt>
<dd><p>See the powsimp function in sympy.simplify</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.primitive">
<code class="sig-name descname">primitive</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.primitive" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the positive Rational that can be extracted non-recursively
from every term of self (i.e., self is treated like an Add). This is
like the as_coeff_Mul() method but primitive always extracts a positive
Rational (never a negative or a Float).</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">primitive</span><span class="p">()</span>
<span class="go">(3, (x + 1)**2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="mi">6</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span> <span class="n">a</span><span class="o">.</span><span class="n">primitive</span><span class="p">()</span>
<span class="go">(2, 3*x + 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="p">);</span> <span class="n">b</span><span class="o">.</span><span class="n">primitive</span><span class="p">()</span>
<span class="go">(1/2, x + 6)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">primitive</span><span class="p">()</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.radsimp">
<code class="sig-name descname">radsimp</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.radsimp" title="Permalink to this definition">¶</a></dt>
<dd><p>See the radsimp function in sympy.simplify</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.ratsimp">
<code class="sig-name descname">ratsimp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.ratsimp" title="Permalink to this definition">¶</a></dt>
<dd><p>See the ratsimp function in sympy.simplify</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.rcall">
<code class="sig-name descname">rcall</code><span class="sig-paren">(</span><em class="sig-param">*args</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.rcall" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply on the argument recursively through the expression tree.</p>
<p>This method is used to simulate a common abuse of notation for
operators. For instance in SymPy the the following will not work:</p>
<p><code class="docutils literal notranslate"><span class="pre">(x+Lambda(y,</span> <span class="pre">2*y))(z)</span> <span class="pre">==</span> <span class="pre">x+2*z</span></code>,</p>
<p>however you can use</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Lambda</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">Lambda</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">rcall</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
<span class="go">x + 2*z</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.refine">
<code class="sig-name descname">refine</code><span class="sig-paren">(</span><em class="sig-param">assumption=True</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.refine" title="Permalink to this definition">¶</a></dt>
<dd><p>See the refine function in sympy.assumptions</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.removeO">
<code class="sig-name descname">removeO</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.removeO" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes the additive O(..) symbol if there is one</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.replace">
<code class="sig-name descname">replace</code><span class="sig-paren">(</span><em class="sig-param">query</em>, <em class="sig-param">value</em>, <em class="sig-param">map=False</em>, <em class="sig-param">simultaneous=True</em>, <em class="sig-param">exact=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.replace" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace matching subexpressions of <code class="docutils literal notranslate"><span class="pre">self</span></code> with <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">map</span> <span class="pre">=</span> <span class="pre">True</span></code> then also return the mapping {old: new} where <code class="docutils literal notranslate"><span class="pre">old</span></code>
was a sub-expression found with query and <code class="docutils literal notranslate"><span class="pre">new</span></code> is the replacement
value for it. If the expression itself doesn’t match the query, then
the returned value will be <code class="docutils literal notranslate"><span class="pre">self.xreplace(map)</span></code> otherwise it should
be <code class="docutils literal notranslate"><span class="pre">self.subs(ordered(map.items()))</span></code>.</p>
<p>Traverses an expression tree and performs replacement of matching
subexpressions from the bottom to the top of the tree. The default
approach is to do the replacement in a simultaneous fashion so
changes made are targeted only once. If this is not desired or causes
problems, <code class="docutils literal notranslate"><span class="pre">simultaneous</span></code> can be set to False. In addition, if an
expression containing more than one Wild symbol is being used to match
subexpressions and  the <code class="docutils literal notranslate"><span class="pre">exact</span></code> flag is True, then the match will only
succeed if non-zero values are received for each Wild that appears in
the match pattern.</p>
<p>The list of possible combinations of queries and replacement values
is listed below:</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Beta.subs" title="nipy.algorithms.statistics.formula.formulae.Beta.subs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subs</span></code></a></dt><dd><p>substitution of subexpressions as defined by the objects themselves.</p>
</dd>
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Beta.xreplace" title="nipy.algorithms.statistics.formula.formulae.Beta.xreplace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">xreplace</span></code></a></dt><dd><p>exact node replacement in expr tree; also capable of using matching rules</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>Initial setup</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">log</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">tan</span><span class="p">,</span> <span class="n">Wild</span><span class="p">,</span> <span class="n">Mul</span><span class="p">,</span> <span class="n">Add</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">+</span> <span class="n">tan</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<dl>
<dt>1.1. type -&gt; type</dt><dd><p>obj.replace(type, newtype)</p>
<p>When object of type <code class="docutils literal notranslate"><span class="pre">type</span></code> is found, replace it with the
result of passing its argument(s) to <code class="docutils literal notranslate"><span class="pre">newtype</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">)</span>
<span class="go">log(cos(x)) + tan(cos(x**2))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="nb">map</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(cos(x), {sin(x): cos(x)})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">Mul</span><span class="p">,</span> <span class="n">Add</span><span class="p">)</span>
<span class="go">x + y</span>
</pre></div>
</div>
</dd>
<dt>1.2. type -&gt; func</dt><dd><p>obj.replace(type, func)</p>
<p>When object of type <code class="docutils literal notranslate"><span class="pre">type</span></code> is found, apply <code class="docutils literal notranslate"><span class="pre">func</span></code> to its
argument(s). <code class="docutils literal notranslate"><span class="pre">func</span></code> must be written to handle the number
of arguments of <code class="docutils literal notranslate"><span class="pre">type</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">arg</span><span class="p">:</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">arg</span><span class="p">))</span>
<span class="go">log(sin(2*x)) + tan(sin(2*x**2))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">Mul</span><span class="p">,</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)))</span>
<span class="go">sin(2*x*y)</span>
</pre></div>
</div>
</dd>
<dt>2.1. pattern -&gt; expr</dt><dd><p>obj.replace(pattern(wild), expr(wild))</p>
<p>Replace subexpressions matching <code class="docutils literal notranslate"><span class="pre">pattern</span></code> with the expression
written in terms of the Wild symbols in <code class="docutils literal notranslate"><span class="pre">pattern</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Wild</span><span class="p">,</span> <span class="s1">&#39;ab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">tan</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
<span class="go">log(tan(x)) + tan(tan(x**2))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">tan</span><span class="p">(</span><span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
<span class="go">log(tan(x/2)) + tan(tan(x**2/2))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">a</span><span class="p">)</span>
<span class="go">log(x) + tan(x**2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="go">y</span>
</pre></div>
</div>
<p>Matching is exact by default when more than one Wild symbol
is used: matching fails unless the match gives non-zero
values for all Wild symbols:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span>
<span class="go">y - 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span>
<span class="go">2*x</span>
</pre></div>
</div>
<p>When set to False, the results may be non-intuitive:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">2/x</span>
</pre></div>
</div>
</dd>
<dt>2.2. pattern -&gt; func</dt><dd><p>obj.replace(pattern(wild), lambda wild: expr(wild))</p>
<p>All behavior is the same as in 2.1 but now a function in terms of
pattern variables is used rather than an expression:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="p">))</span>
<span class="go">log(sin(2*x)) + tan(sin(2*x**2))</span>
</pre></div>
</div>
</dd>
<dt>3.1. func -&gt; func</dt><dd><p>obj.replace(filter, func)</p>
<p>Replace subexpression <code class="docutils literal notranslate"><span class="pre">e</span></code> with <code class="docutils literal notranslate"><span class="pre">func(e)</span></code> if <code class="docutils literal notranslate"><span class="pre">filter(e)</span></code>
is True.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="k">lambda</span> <span class="n">expr</span><span class="p">:</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Number</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">expr</span><span class="p">:</span> <span class="n">expr</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="go">4*sin(x**9)</span>
</pre></div>
</div>
</dd>
</dl>
<p>The expression itself is also targeted by the query but is done in
such a fashion that changes are not made twice.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="go">2*x*(2*x*y + 1)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.rewrite">
<code class="sig-name descname">rewrite</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**hints</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.rewrite" title="Permalink to this definition">¶</a></dt>
<dd><p>Rewrite functions in terms of other functions.</p>
<p>Rewrites expression containing applications of functions
of one kind in terms of functions of different kind. For
example you can rewrite trigonometric functions as complex
exponentials or combinatorial functions as gamma function.</p>
<p>As a pattern this function accepts a list of functions to
to rewrite (instances of DefinedFunction class). As rule
you can use string or a destination function instance (in
this case rewrite() will use the str() function).</p>
<p>There is also the possibility to pass hints on how to rewrite
the given expressions. For now there is only one such hint
defined called ‘deep’. When ‘deep’ is set to False it will
forbid functions to rewrite their contents.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">sin</span><span class="p">,</span> <span class="n">exp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
</pre></div>
</div>
<p>Unspecified pattern:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span>
<span class="go">-I*(exp(I*x) - exp(-I*x))/2</span>
</pre></div>
</div>
<p>Pattern as a single function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="n">exp</span><span class="p">)</span>
<span class="go">-I*(exp(I*x) - exp(-I*x))/2</span>
</pre></div>
</div>
<p>Pattern as a list of functions:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">rewrite</span><span class="p">([</span><span class="n">sin</span><span class="p">,</span> <span class="p">],</span> <span class="n">exp</span><span class="p">)</span>
<span class="go">-I*(exp(I*x) - exp(-I*x))/2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.round">
<code class="sig-name descname">round</code><span class="sig-paren">(</span><em class="sig-param">p=0</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.round" title="Permalink to this definition">¶</a></dt>
<dd><p>Return x rounded to the given decimal place.</p>
<p>If a complex number would results, apply round to the real
and imaginary components of the number.</p>
<p class="rubric">Notes</p>
<p>Do not confuse the Python builtin function, round, with the
SymPy method of the same name. The former always returns a float
(or raises an error if applied to a complex value) while the
latter returns either a Number or a complex number:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="mi">123</span><span class="p">),</span> <span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="n">Number</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="n">Number</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">((</span><span class="mi">3</span><span class="o">*</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(),</span> <span class="n">Mul</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">((</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(),</span> <span class="n">Add</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">pi</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">Add</span><span class="p">,</span> <span class="n">Mul</span><span class="p">,</span> <span class="n">Number</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="p">(</span><span class="mf">10.5</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">()</span>
<span class="go">11.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">.</span><span class="n">round</span><span class="p">()</span>
<span class="go">3.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">3.14</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span> <span class="o">+</span> <span class="n">E</span><span class="o">*</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">()</span>
<span class="go">6. + 3.*I</span>
</pre></div>
</div>
<p>The round method has a chopping effect:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span> <span class="o">+</span> <span class="n">I</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">()</span>
<span class="go">6.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">10</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">()</span>
<span class="go">2.*I</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">10</span> <span class="o">+</span> <span class="n">E</span><span class="o">*</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0.31 + 2.72*I</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.separate">
<code class="sig-name descname">separate</code><span class="sig-paren">(</span><em class="sig-param">deep=False</em>, <em class="sig-param">force=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.separate" title="Permalink to this definition">¶</a></dt>
<dd><p>See the separate function in sympy.simplify</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.series">
<code class="sig-name descname">series</code><span class="sig-paren">(</span><em class="sig-param">x=None</em>, <em class="sig-param">x0=0</em>, <em class="sig-param">n=6</em>, <em class="sig-param">dir='+'</em>, <em class="sig-param">logx=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.series" title="Permalink to this definition">¶</a></dt>
<dd><p>Series expansion of “self” around <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">x0</span></code> yielding either terms of
the series one by one (the lazy series given when n=None), else
all the terms at once when n != None.</p>
<p>Returns the series expansion of “self” around the point <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">x0</span></code>
with respect to <code class="docutils literal notranslate"><span class="pre">x</span></code> up to <code class="docutils literal notranslate"><span class="pre">O((x</span> <span class="pre">-</span> <span class="pre">x0)**n,</span> <span class="pre">x,</span> <span class="pre">x0)</span></code> (default n is 6).</p>
<p>If <code class="docutils literal notranslate"><span class="pre">x=None</span></code> and <code class="docutils literal notranslate"><span class="pre">self</span></code> is univariate, the univariate symbol will
be supplied, otherwise an error will be raised.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">cos</span><span class="p">,</span> <span class="n">exp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">()</span>
<span class="go">1 - x**2/2 + x**4/24 + O(x**6)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="go">1 - x**2/2 + O(x**4)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">cos(1) - (x - 1)*sin(1) + O((x - 1)**2, (x, 1))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">exp</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">cos(x + 1) - y*sin(x + 1) + O(y**2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">cos(exp(y)) - x*sin(exp(y)) + O(x**2)</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">n=None</span></code> then a generator of the series terms will be returned.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">term</span><span class="o">=</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">term</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>
<span class="go">[1, -x**2/2]</span>
</pre></div>
</div>
<p>For <code class="docutils literal notranslate"><span class="pre">dir=+</span></code> (default) the series is calculated from the right and
for <code class="docutils literal notranslate"><span class="pre">dir=-</span></code> the series from the left. For smooth functions this
flag will not alter the results.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="nb">dir</span><span class="o">=</span><span class="s2">&quot;+&quot;</span><span class="p">)</span>
<span class="go">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="nb">dir</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">)</span>
<span class="go">-x</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.simplify">
<code class="sig-name descname">simplify</code><span class="sig-paren">(</span><em class="sig-param">ratio=1.7</em>, <em class="sig-param">measure=None</em>, <em class="sig-param">rational=False</em>, <em class="sig-param">inverse=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.simplify" title="Permalink to this definition">¶</a></dt>
<dd><p>See the simplify function in sympy.simplify</p>
</dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.sort_key">
<code class="sig-name descname">sort_key</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.sort_key" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.subs">
<code class="sig-name descname">subs</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.subs" title="Permalink to this definition">¶</a></dt>
<dd><p>Substitutes old for new in an expression after sympifying args.</p>
<dl class="simple">
<dt><cite>args</cite> is either:</dt><dd><ul class="simple">
<li><p>two arguments, e.g. foo.subs(old, new)</p></li>
<li><dl class="simple">
<dt>one iterable argument, e.g. foo.subs(iterable). The iterable may be</dt><dd><dl class="simple">
<dt>o an iterable container with (old, new) pairs. In this case the</dt><dd><p>replacements are processed in the order given with successive
patterns possibly affecting replacements already made.</p>
</dd>
<dt>o a dict or set whose key/value items correspond to old/new pairs.</dt><dd><p>In this case the old/new pairs will be sorted by op count and in
case of a tie, by number of args and the default_sort_key. The
resulting sorted list is then processed as an iterable container
(see previous).</p>
</dd>
</dl>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p>If the keyword <code class="docutils literal notranslate"><span class="pre">simultaneous</span></code> is True, the subexpressions will not be
evaluated until all the substitutions have been made.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Beta.replace" title="nipy.algorithms.statistics.formula.formulae.Beta.replace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">replace</span></code></a></dt><dd><p>replacement capable of doing wildcard-like matching, parsing of match, and conditional replacements</p>
</dd>
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Beta.xreplace" title="nipy.algorithms.statistics.formula.formulae.Beta.xreplace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">xreplace</span></code></a></dt><dd><p>exact node replacement in expr tree; also capable of using matching rules</p>
</dd>
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Beta.evalf" title="nipy.algorithms.statistics.formula.formulae.Beta.evalf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">evalf</span></code></a></dt><dd><p>calculates the given formula to a desired level of precision</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">pi</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">oo</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pi</span><span class="p">)</span>
<span class="go">pi*y + 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span><span class="n">pi</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span><span class="mi">2</span><span class="p">})</span>
<span class="go">1 + 2*pi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="n">pi</span><span class="p">),</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="go">1 + 2*pi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reps</span> <span class="o">=</span> <span class="p">[(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">reps</span><span class="p">))</span>
<span class="go">x**2 + 2</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">y**2 + y</span>
</pre></div>
</div>
<p>To replace only the x**2 but not the x**4, use xreplace:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">:</span> <span class="n">y</span><span class="p">})</span>
<span class="go">x**4 + y</span>
</pre></div>
</div>
<p>To delay evaluation until all substitutions have been made,
set the keyword <code class="docutils literal notranslate"><span class="pre">simultaneous</span></code> to True:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span> <span class="n">simultaneous</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
<p>This has the added feature of not allowing subsequent substitutions
to affect those already made:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">})</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">},</span> <span class="n">simultaneous</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">y/(x + y)</span>
</pre></div>
</div>
<p>In order to obtain a canonical result, unordered iterables are
sorted by count_op length, number of arguments and by the
default_sort_key to break any ties. All other iterables are left
unsorted.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)),</span> <span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">),</span> <span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">),</span> <span class="n">c</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">E</span> <span class="o">=</span> <span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">e</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="nb">dict</span><span class="p">([</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">E</span><span class="p">]))</span>
<span class="go">a*c*sin(d*e) + b</span>
</pre></div>
</div>
<p>The resulting expression represents a literal replacement of the
old arguments with the new arguments. This may not reflect the
limiting behavior of the expression:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">oo</span><span class="p">})</span>
<span class="go">nan</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">limit</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">oo</span><span class="p">)</span>
<span class="go">oo</span>
</pre></div>
</div>
<p>If the substitution will be followed by numerical
evaluation, it is better to pass the substitution to
evalf as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="n">subs</span><span class="o">=</span><span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">},</span> <span class="n">n</span><span class="o">=</span><span class="mi">21</span><span class="p">)</span>
<span class="go">0.333333333333333333333</span>
</pre></div>
</div>
<p>rather than</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">})</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="mi">21</span><span class="p">)</span>
<span class="go">0.333333333333333314830</span>
</pre></div>
</div>
<p>as the former will ensure that the desired level of precision is
obtained.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.taylor_term">
<code class="sig-name descname">taylor_term</code><span class="sig-paren">(</span><em class="sig-param">n</em>, <em class="sig-param">x</em>, <em class="sig-param">*previous_terms</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.taylor_term" title="Permalink to this definition">¶</a></dt>
<dd><p>General method for the taylor term.</p>
<p>This method is slow, because it differentiates n-times. Subclasses can
redefine it to make it faster by using the “previous_terms”.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.to_nnf">
<code class="sig-name descname">to_nnf</code><span class="sig-paren">(</span><em class="sig-param">simplify=True</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.to_nnf" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.together">
<code class="sig-name descname">together</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.together" title="Permalink to this definition">¶</a></dt>
<dd><p>See the together function in sympy.polys</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.transpose">
<code class="sig-name descname">transpose</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.transpose" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.trigsimp">
<code class="sig-name descname">trigsimp</code><span class="sig-paren">(</span><em class="sig-param">**args</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.trigsimp" title="Permalink to this definition">¶</a></dt>
<dd><p>See the trigsimp function in sympy.simplify</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Beta.xreplace">
<code class="sig-name descname">xreplace</code><span class="sig-paren">(</span><em class="sig-param">rule</em>, <em class="sig-param">hack2=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Beta.xreplace" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace occurrences of objects within the expression.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>rule</strong> : dict-like</p>
<blockquote>
<div><p>Expresses a replacement rule</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>xreplace</strong> : the result of the replacement</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Beta.replace" title="nipy.algorithms.statistics.formula.formulae.Beta.replace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">replace</span></code></a></dt><dd><p>replacement capable of doing wildcard-like matching, parsing of match, and conditional replacements</p>
</dd>
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Beta.subs" title="nipy.algorithms.statistics.formula.formulae.Beta.subs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subs</span></code></a></dt><dd><p>substitution of subexpressions as defined by the objects themselves.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">exp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x y z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">pi</span><span class="p">})</span>
<span class="go">pi*y + 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">pi</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="go">1 + 2*pi</span>
</pre></div>
</div>
<p>Replacements occur only if an entire node in the expression tree is
matched:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">:</span> <span class="n">pi</span><span class="p">})</span>
<span class="go">z + pi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">:</span> <span class="n">pi</span><span class="p">})</span>
<span class="go">x*y*z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">:</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">z</span><span class="p">})</span>
<span class="go">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">:</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">z</span><span class="p">})</span>
<span class="go">4*z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="go">x + y + 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">:</span> <span class="n">y</span><span class="p">})</span>
<span class="go">x + exp(y) + 2</span>
</pre></div>
</div>
<p>xreplace doesn’t differentiate between free and bound symbols. In the
following, subs(x, y) would not change x since it is a bound symbol,
but xreplace does:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Integral</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Integral</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">y</span><span class="p">})</span>
<span class="go">Integral(y, (y, 1, 2*y))</span>
</pre></div>
</div>
<p>Trying to replace x with an expression raises an error:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Integral</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">})</span> 
<span class="go">ValueError: Invalid limits given: ((2*y, 1, 4*y),)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="factor">
<h3><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Factor" title="nipy.algorithms.statistics.formula.formulae.Factor"><code class="xref py py-class docutils literal notranslate"><span class="pre">Factor</span></code></a><a class="headerlink" href="#factor" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="nipy.algorithms.statistics.formula.formulae.Factor">
<em class="property">class </em><code class="sig-prename descclassname">nipy.algorithms.statistics.formula.formulae.</code><code class="sig-name descname">Factor</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">levels</em>, <em class="sig-param">char='b'</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/nipy/algorithms/statistics/formula/formulae.html#Factor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Formula" title="nipy.algorithms.statistics.formula.formulae.Formula"><code class="xref py py-class docutils literal notranslate"><span class="pre">nipy.algorithms.statistics.formula.formulae.Formula</span></code></a></p>
<p>A qualitative variable in a regression model</p>
<p>A Factor is similar to R’s factor. The levels of the Factor can be
either strings or ints.</p>
<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Factor.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">levels</em>, <em class="sig-param">char='b'</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/nipy/algorithms/statistics/formula/formulae.html#Factor.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Factor.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize Factor</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>name</strong> : str</p>
<p><strong>levels</strong> : [str or int]</p>
<blockquote>
<div><p>A sequence of strings or ints.</p>
</div></blockquote>
<p><strong>char</strong> : str, optional</p>
<blockquote>
<div><p>prefix character for regression coefficients</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Factor.get_term">
<code class="sig-name descname">get_term</code><span class="sig-paren">(</span><em class="sig-param">level</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/nipy/algorithms/statistics/formula/formulae.html#Factor.get_term"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Factor.get_term" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a term of the Factor…</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Factor.main_effect">
<em class="property">property </em><code class="sig-name descname">main_effect</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Factor.main_effect" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Factor.stratify">
<code class="sig-name descname">stratify</code><span class="sig-paren">(</span><em class="sig-param">variable</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/nipy/algorithms/statistics/formula/formulae.html#Factor.stratify"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Factor.stratify" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new variable, stratified by the levels of a Factor.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>variable</strong> : str or simple sympy expression</p>
<blockquote>
<div><p>If sympy expression, then string representation must be all lower
or upper case letters, i.e. it can be interpreted as a name.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>formula</strong> : Formula</p>
<blockquote>
<div><p>Formula whose mean has one parameter named variable%d, for each
level in self.levels</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Factor</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sf</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">stratify</span><span class="p">(</span><span class="s1">&#39;theta&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sf</span><span class="o">.</span><span class="n">mean</span>
<span class="go">_theta0*a_x + _theta1*a_y</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Factor.fromcol">
<em class="property">static </em><code class="sig-name descname">fromcol</code><span class="sig-paren">(</span><em class="sig-param">col</em>, <em class="sig-param">name</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/nipy/algorithms/statistics/formula/formulae.html#Factor.fromcol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Factor.fromcol" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Factor from a column array.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>col</strong> : ndarray</p>
<blockquote>
<div><p>an array with ndim==1</p>
</div></blockquote>
<p><strong>name</strong> : str</p>
<blockquote>
<div><p>name of the Factor</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>factor</strong> : Factor</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mi">3</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">)],</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">([(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;S1&#39;</span><span class="p">)]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Factor</span><span class="o">.</span><span class="n">fromcol</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">],</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">Factor</span><span class="o">.</span><span class="n">fromcol</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">],</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">f1</span><span class="o">.</span><span class="n">design</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">descr</span><span class="p">)</span>
<span class="go">[(&#39;y_a&#39;, &#39;&lt;f8&#39;), (&#39;y_b&#39;, &#39;&lt;f8&#39;)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">f2</span><span class="o">.</span><span class="n">design</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">descr</span><span class="p">)</span>
<span class="go">[(&#39;x_3&#39;, &#39;&lt;f8&#39;), (&#39;x_4&#39;, &#39;&lt;f8&#39;), (&#39;x_5&#39;, &#39;&lt;f8&#39;)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Factor.coefs">
<em class="property">property </em><code class="sig-name descname">coefs</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Factor.coefs" title="Permalink to this definition">¶</a></dt>
<dd><p>Coefficients in the linear regression formula.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Factor.design">
<code class="sig-name descname">design</code><span class="sig-paren">(</span><em class="sig-param">input</em>, <em class="sig-param">param=None</em>, <em class="sig-param">return_float=False</em>, <em class="sig-param">contrasts=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Factor.design" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct the design matrix, and optional contrast matrices.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>input</strong> : np.recarray</p>
<blockquote>
<div><p>Recarray including fields needed to compute the Terms in
getparams(self.design_expr).</p>
</div></blockquote>
<p><strong>param</strong> : None or np.recarray</p>
<blockquote>
<div><p>Recarray including fields that are not Terms in
getparams(self.design_expr)</p>
</div></blockquote>
<p><strong>return_float</strong> : bool, optional</p>
<blockquote>
<div><p>If True, return a np.float array rather than a np.recarray</p>
</div></blockquote>
<p><strong>contrasts</strong> : None or dict, optional</p>
<blockquote>
<div><p>Contrasts. The items in this dictionary should be (str,
Formula) pairs where a contrast matrix is constructed for
each Formula by evaluating its design at the same parameters
as self.design. If not None, then the return_float is set to True.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>des</strong> : 2D array</p>
<blockquote>
<div><p>design matrix</p>
</div></blockquote>
<p><strong>cmatrices</strong> : dict, optional</p>
<blockquote>
<div><p>Dictionary with keys from <cite>contrasts</cite> input, and contrast matrices
corresponding to <cite>des</cite> design matrix.  Returned only if <cite>contrasts</cite>
input is not None</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Factor.design_expr">
<em class="property">property </em><code class="sig-name descname">design_expr</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Factor.design_expr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Factor.dtype">
<em class="property">property </em><code class="sig-name descname">dtype</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Factor.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>The dtype of the design matrix of the Formula.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Factor.fromrec">
<em class="property">static </em><code class="sig-name descname">fromrec</code><span class="sig-paren">(</span><em class="sig-param">rec</em>, <em class="sig-param">keep=[]</em>, <em class="sig-param">drop=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Factor.fromrec" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct Formula from recarray</p>
<p>For fields with a string-dtype, it is assumed that these are
qualtiatitve regressors, i.e. Factors.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>rec: recarray</strong></p>
<blockquote>
<div><p>Recarray whose field names will be used to create a formula.</p>
</div></blockquote>
<p><strong>keep: []</strong></p>
<blockquote>
<div><p>Field names to explicitly keep, dropping all others.</p>
</div></blockquote>
<p><strong>drop: []</strong></p>
<blockquote>
<div><p>Field names to drop.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Factor.mean">
<em class="property">property </em><code class="sig-name descname">mean</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Factor.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Expression for the mean, expressed as a linear combination of terms, each with dummy variables in front.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Factor.params">
<em class="property">property </em><code class="sig-name descname">params</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Factor.params" title="Permalink to this definition">¶</a></dt>
<dd><p>The parameters in the Formula.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Factor.subs">
<code class="sig-name descname">subs</code><span class="sig-paren">(</span><em class="sig-param">old</em>, <em class="sig-param">new</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Factor.subs" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a sympy substitution on all terms in the Formula</p>
<p>Returns a new instance of the same class</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>old</strong> : sympy.Basic</p>
<blockquote>
<div><p>The expression to be changed</p>
</div></blockquote>
<p><strong>new</strong> : sympy.Basic</p>
<blockquote>
<div><p>The value to change it to.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>newf</strong> : Formula</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="p">[</span><span class="n">Term</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="s1">&#39;st&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="p">[</span><span class="n">sympy</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="s1">&#39;fg&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">form</span> <span class="o">=</span> <span class="n">Formula</span><span class="p">([</span><span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="n">g</span><span class="p">(</span><span class="n">s</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">newform</span> <span class="o">=</span> <span class="n">form</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="s1">&#39;h&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">newform</span><span class="o">.</span><span class="n">terms</span>
<span class="go">array([f(t), h(s)], dtype=object)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">form</span><span class="o">.</span><span class="n">terms</span>
<span class="go">array([f(t), g(s)], dtype=object)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Factor.terms">
<em class="property">property </em><code class="sig-name descname">terms</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Factor.terms" title="Permalink to this definition">¶</a></dt>
<dd><p>Terms in the linear regression formula.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="factorterm">
<h3><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm" title="nipy.algorithms.statistics.formula.formulae.FactorTerm"><code class="xref py py-class docutils literal notranslate"><span class="pre">FactorTerm</span></code></a><a class="headerlink" href="#factorterm" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm">
<em class="property">class </em><code class="sig-prename descclassname">nipy.algorithms.statistics.formula.formulae.</code><code class="sig-name descname">FactorTerm</code><a class="reference internal" href="../../_modules/nipy/algorithms/statistics/formula/formulae.html#FactorTerm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Term" title="nipy.algorithms.statistics.formula.formulae.Term"><code class="xref py py-class docutils literal notranslate"><span class="pre">nipy.algorithms.statistics.formula.formulae.Term</span></code></a></p>
<p>Boolean Term derived from a Factor.</p>
<p>Its properties are the same as a Term except that its product with
itself is itself.</p>
<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">$self</em>, <em class="sig-param">/</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.adjoint">
<code class="sig-name descname">adjoint</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.adjoint" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.apart">
<code class="sig-name descname">apart</code><span class="sig-paren">(</span><em class="sig-param">x=None</em>, <em class="sig-param">**args</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.apart" title="Permalink to this definition">¶</a></dt>
<dd><p>See the apart function in sympy.polys</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.args">
<em class="property">property </em><code class="sig-name descname">args</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.args" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a tuple of arguments of ‘self’.</p>
<p class="rubric">Notes</p>
<p>Never use self._args, always use self.args.
Only use _args in __new__ when creating a new function.
Don’t override .args() from Basic (so that it’s easy to
change the interface in the future if needed).</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">cot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">args</span>
<span class="go">(x,)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">x</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">args</span>
<span class="go">(x, y)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">y</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.args_cnc">
<code class="sig-name descname">args_cnc</code><span class="sig-paren">(</span><em class="sig-param">cset=False</em>, <em class="sig-param">warn=True</em>, <em class="sig-param">split_1=True</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.args_cnc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return [commutative factors, non-commutative factors] of self.</p>
<p>self is treated as a Mul and the ordering of the factors is maintained.
If <code class="docutils literal notranslate"><span class="pre">cset</span></code> is True the commutative factors will be returned in a set.
If there were repeated factors (as may happen with an unevaluated Mul)
then an error will be raised unless it is explicitly suppressed by
setting <code class="docutils literal notranslate"><span class="pre">warn</span></code> to False.</p>
<p>Note: -1 is always separated from a Number unless split_1 is False.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">oo</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;A B&#39;</span><span class="p">,</span> <span class="n">commutative</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x y&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">()</span>
<span class="go">[[-1, 2, x, y], []]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">-</span><span class="mf">2.5</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">()</span>
<span class="go">[[-1, 2.5, x], []]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">A</span><span class="o">*</span><span class="n">B</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">()</span>
<span class="go">[[-1, 2, x, y], [A, B]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">A</span><span class="o">*</span><span class="n">B</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">(</span><span class="n">split_1</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[[-2, x, y], [A, B]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">(</span><span class="n">cset</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[{-1, 2, x, y}, []]</span>
</pre></div>
</div>
<p>The arg is always treated as a Mul:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">()</span>
<span class="go">[[], [x - 2 + A]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">-</span><span class="n">oo</span><span class="p">)</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">()</span> <span class="c1"># -oo is a singleton</span>
<span class="go">[[-1, oo], []]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.as_base_exp">
<code class="sig-name descname">as_base_exp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.as_base_exp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.as_coeff_Add">
<code class="sig-name descname">as_coeff_Add</code><span class="sig-paren">(</span><em class="sig-param">rational=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.as_coeff_Add" title="Permalink to this definition">¶</a></dt>
<dd><p>Efficiently extract the coefficient of a summation.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.as_coeff_Mul">
<code class="sig-name descname">as_coeff_Mul</code><span class="sig-paren">(</span><em class="sig-param">rational=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.as_coeff_Mul" title="Permalink to this definition">¶</a></dt>
<dd><p>Efficiently extract the coefficient of a product.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.as_coeff_add">
<code class="sig-name descname">as_coeff_add</code><span class="sig-paren">(</span><em class="sig-param">*deps</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.as_coeff_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the tuple (c, args) where self is written as an Add, <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
<p>c should be a Rational added to any terms of the Add that are
independent of deps.</p>
<p>args should be a tuple of all other terms of <code class="docutils literal notranslate"><span class="pre">a</span></code>; args is empty
if self is a Number or if self is independent of deps (when given).</p>
<p>This should be used when you don’t know if self is an Add or not but
you want to treat self as an Add or if you want to process the
individual arguments of the tail of self as an Add.</p>
<ul class="simple">
<li><p>if you know self is an Add and want only the head, use self.args[0];</p></li>
<li><p>if you don’t want to process the arguments of the tail but need the
tail then use self.as_two_terms() which gives the head and tail.</p></li>
<li><p>if you want to split self into an independent and dependent parts
use <code class="docutils literal notranslate"><span class="pre">self.as_independent(*deps)</span></code></p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">S</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">as_coeff_add</span><span class="p">()</span>
<span class="go">(3, ())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">as_coeff_add</span><span class="p">()</span>
<span class="go">(3, (x,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">as_coeff_add</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">(y + 3, (x,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">as_coeff_add</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">(y + 3, ())</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.as_coeff_exponent">
<code class="sig-name descname">as_coeff_exponent</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.as_coeff_exponent" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">c*x**e</span> <span class="pre">-&gt;</span> <span class="pre">c,e</span></code> where x can be any symbolic expression.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.as_coeff_mul">
<code class="sig-name descname">as_coeff_mul</code><span class="sig-paren">(</span><em class="sig-param">*deps</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.as_coeff_mul" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the tuple (c, args) where self is written as a Mul, <code class="docutils literal notranslate"><span class="pre">m</span></code>.</p>
<p>c should be a Rational multiplied by any factors of the Mul that are
independent of deps.</p>
<p>args should be a tuple of all other factors of m; args is empty
if self is a Number or if self is independent of deps (when given).</p>
<p>This should be used when you don’t know if self is a Mul or not but
you want to treat self as a Mul or if you want to process the
individual arguments of the tail of self as a Mul.</p>
<ul class="simple">
<li><p>if you know self is a Mul and want only the head, use self.args[0];</p></li>
<li><p>if you don’t want to process the arguments of the tail but need the
tail then use self.as_two_terms() which gives the head and tail;</p></li>
<li><p>if you want to split self into an independent and dependent parts
use <code class="docutils literal notranslate"><span class="pre">self.as_independent(*deps)</span></code></p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">S</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">as_coeff_mul</span><span class="p">()</span>
<span class="go">(3, ())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">as_coeff_mul</span><span class="p">()</span>
<span class="go">(3, (x, y))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">as_coeff_mul</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">(3*y, (x,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">as_coeff_mul</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">(3*y, ())</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.as_coefficient">
<code class="sig-name descname">as_coefficient</code><span class="sig-paren">(</span><em class="sig-param">expr</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.as_coefficient" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts symbolic coefficient at the given expression. In
other words, this functions separates ‘self’ into the product
of ‘expr’ and ‘expr’-free coefficient. If such separation
is not possible it will return None.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.coeff" title="nipy.algorithms.statistics.formula.formulae.FactorTerm.coeff"><code class="xref py py-obj docutils literal notranslate"><span class="pre">coeff</span></code></a></dt><dd><p>return sum of terms have a given factor</p>
</dd>
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.as_coeff_Add" title="nipy.algorithms.statistics.formula.formulae.FactorTerm.as_coeff_Add"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_coeff_Add</span></code></a></dt><dd><p>separate the additive constant from an expression</p>
</dd>
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.as_coeff_Mul" title="nipy.algorithms.statistics.formula.formulae.FactorTerm.as_coeff_Mul"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_coeff_Mul</span></code></a></dt><dd><p>separate the multiplicative constant from an expression</p>
</dd>
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.as_independent" title="nipy.algorithms.statistics.formula.formulae.FactorTerm.as_independent"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_independent</span></code></a></dt><dd><p>separate x-dependent terms/factors from others</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.polys.polytools.coeff_monomial</span></code></dt><dd><p>efficiently find the single coefficient of a monomial in Poly</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.polys.polytools.nth</span></code></dt><dd><p>like coeff_monomial but powers of monomial terms are used</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">E</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">Poly</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">E</span><span class="o">.</span><span class="n">as_coefficient</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">E</span><span class="p">)</span><span class="o">.</span><span class="n">as_coefficient</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">E</span><span class="p">)</span><span class="o">*</span><span class="n">E</span><span class="p">)</span><span class="o">.</span><span class="n">as_coefficient</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
</pre></div>
</div>
<p>Two terms have E in them so a sum is returned. (If one were
desiring the coefficient of the term exactly matching E then
the constant from the returned expression could be selected.
Or, for greater precision, a method of Poly can be used to
indicate the desired term from which the coefficient is
desired.)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">E</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">E</span><span class="p">)</span><span class="o">.</span><span class="n">as_coefficient</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="go">x + 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># just want the exact match</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">E</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">E</span><span class="p">);</span> <span class="n">p</span>
<span class="go">Poly(x*E + 2*E, x, E, domain=&#39;ZZ&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">coeff_monomial</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">nth</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>Since the following cannot be written as a product containing
E as a factor, None is returned. (If the coefficient <code class="docutils literal notranslate"><span class="pre">2*x</span></code> is
desired then the <code class="docutils literal notranslate"><span class="pre">coeff</span></code> method should be used.)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">E</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">as_coefficient</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">E</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="go">2*x</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">E</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">as_coefficient</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">as_coefficient</span><span class="p">(</span><span class="n">pi</span><span class="o">*</span><span class="n">I</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">as_coefficient</span><span class="p">(</span><span class="n">pi</span><span class="o">*</span><span class="n">I</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.as_coefficients_dict">
<code class="sig-name descname">as_coefficients_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.as_coefficients_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dictionary mapping terms to their Rational coefficient.
Since the dictionary is a defaultdict, inquiries about terms which
were not present will return a coefficient of 0. If an expression is
not an Add it is considered to have a single term.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">as_coefficients_dict</span><span class="p">()</span>
<span class="go">{1: 4, x: 3, a*x: 1}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">as_coefficients_dict</span><span class="p">()</span>
<span class="go">{a*x: 3}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.as_content_primitive">
<code class="sig-name descname">as_content_primitive</code><span class="sig-paren">(</span><em class="sig-param">radical=False</em>, <em class="sig-param">clear=True</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.as_content_primitive" title="Permalink to this definition">¶</a></dt>
<dd><p>This method should recursively remove a Rational from all arguments
and return that (content) and the new self (primitive). The content
should always be positive and <code class="docutils literal notranslate"><span class="pre">Mul(*foo.as_content_primitive())</span> <span class="pre">==</span> <span class="pre">foo</span></code>.
The primitive need not be in canonical form and should try to preserve
the underlying structure if possible (i.e. expand_mul should not be
applied to self).</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">sqrt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>The as_content_primitive function is recursive and retains structure:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span><span class="o">.</span><span class="n">as_content_primitive</span><span class="p">()</span>
<span class="go">(2, x + 3*y*(y + 1) + 1)</span>
</pre></div>
</div>
<p>Integer powers will have Rationals extracted from the base:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">6</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">as_content_primitive</span><span class="p">()</span>
<span class="go">(4, (3*x + 1)**2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">6</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">as_content_primitive</span><span class="p">()</span>
<span class="go">(1, (2*(3*x + 1))**(2*y))</span>
</pre></div>
</div>
<p>Terms may end up joining once their as_content_primitives are added:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="mi">5</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="p">))</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">y</span><span class="p">)))</span><span class="o">.</span><span class="n">as_content_primitive</span><span class="p">()</span>
<span class="go">(11, x*(y + 1))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="p">))</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">y</span><span class="p">)))</span><span class="o">.</span><span class="n">as_content_primitive</span><span class="p">()</span>
<span class="go">(9, x*(y + 1))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">z</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="p">))</span> <span class="o">+</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">y</span><span class="p">)))</span><span class="o">.</span><span class="n">as_content_primitive</span><span class="p">()</span>
<span class="go">(1, 6.0*x*(y + 1) + 3*z*(y + 1))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="mi">5</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="p">))</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">y</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">as_content_primitive</span><span class="p">()</span>
<span class="go">(121, x**2*(y + 1)**2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="mi">5</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="p">))</span> <span class="o">+</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">y</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">as_content_primitive</span><span class="p">()</span>
<span class="go">(1, 121.0*x**2*(y + 1)**2)</span>
</pre></div>
</div>
<p>Radical content can also be factored out of the primitive:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span><span class="o">.</span><span class="n">as_content_primitive</span><span class="p">(</span><span class="n">radical</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(2, sqrt(2)*(1 + 2*sqrt(5)))</span>
</pre></div>
</div>
<p>If clear=False (default is True) then content will not be removed
from an Add if it can be distributed to leave one or more
terms with integer coefficients.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">as_content_primitive</span><span class="p">()</span>
<span class="go">(1/2, x + 2*y)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">as_content_primitive</span><span class="p">(</span><span class="n">clear</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">(1, x/2 + y)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.as_dummy">
<code class="sig-name descname">as_dummy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.as_dummy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the expression with any objects having structurally
bound symbols replaced with unique, canonical symbols within
the object in which they appear and having only the default
assumption for commutativity being True.</p>
<p class="rubric">Notes</p>
<p>Any object that has structural dummy variables should have
a property, <cite>bound_symbols</cite> that returns a list of structural
dummy symbols of the object itself.</p>
<p>Lambda and Subs have bound symbols, but because of how they
are cached, they already compare the same regardless of their
bound symbols:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Lambda</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Lambda</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">Lambda</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Integral</span><span class="p">,</span> <span class="n">Symbol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Integral</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">as_dummy</span><span class="p">()</span>
<span class="go">Integral(_0, (_0, x))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_real</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.as_expr">
<code class="sig-name descname">as_expr</code><span class="sig-paren">(</span><em class="sig-param">*gens</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.as_expr" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a polynomial to a SymPy expression.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">sin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">as_poly</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">as_expr</span><span class="p">()</span>
<span class="go">x**2 + x*y</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">as_expr</span><span class="p">()</span>
<span class="go">sin(x)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.as_independent">
<code class="sig-name descname">as_independent</code><span class="sig-paren">(</span><em class="sig-param">*deps</em>, <em class="sig-param">**hint</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.as_independent" title="Permalink to this definition">¶</a></dt>
<dd><p>A mostly naive separation of a Mul or Add into arguments that are not
are dependent on deps. To obtain as complete a separation of variables
as possible, use a separation method first, e.g.:</p>
<ul class="simple">
<li><p>separatevars() to change Mul, Add and Pow (including exp) into Mul</p></li>
<li><p>.expand(mul=True) to change Add or Mul into Add</p></li>
<li><p>.expand(log=True) to change log expr into an Add</p></li>
</ul>
<p>The only non-naive thing that is done here is to respect noncommutative
ordering of variables and to always return (0, 0) for <cite>self</cite> of zero
regardless of hints.</p>
<p>For nonzero <cite>self</cite>, the returned tuple (i, d) has the
following interpretation:</p>
<ul class="simple">
<li><p>i will has no variable that appears in deps</p></li>
<li><p>d will either have terms that contain variables that are in deps, or
be equal to 0 (when self is an Add) or 1 (when self is a Mul)</p></li>
<li><p>if self is an Add then self = i + d</p></li>
<li><p>if self is a Mul then self = i*d</p></li>
<li><p>otherwise (self, S.One) or (S.One, self) is returned.</p></li>
</ul>
<p>To force the expression to be treated as an Add, use the hint as_Add=True</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">separatevars</span></code>, <a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.expand" title="nipy.algorithms.statistics.formula.formulae.FactorTerm.expand"><code class="xref py py-obj docutils literal notranslate"><span class="pre">expand</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">Add.as_two_terms</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">Mul.as_two_terms</span></code>, <a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.as_coeff_add" title="nipy.algorithms.statistics.formula.formulae.FactorTerm.as_coeff_add"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_coeff_add</span></code></a>, <a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.as_coeff_mul" title="nipy.algorithms.statistics.formula.formulae.FactorTerm.as_coeff_mul"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_coeff_mul</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<p>– self is an Add</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">exp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">(0, x*y + x)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">(x, x*y)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">(y + z, 2*x*sin(x) + x)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">(z, 2*x*sin(x) + x + y)</span>
</pre></div>
</div>
<p>– self is a Mul</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">(cos(y), x*sin(x))</span>
</pre></div>
</div>
<p>non-commutative terms cannot always be separated out when self is a Mul</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">n3</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;n1 n2 n3&#39;</span><span class="p">,</span> <span class="n">commutative</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">n1</span> <span class="o">+</span> <span class="n">n1</span><span class="o">*</span><span class="n">n2</span><span class="p">)</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">n2</span><span class="p">)</span>
<span class="go">(n1, n1*n2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">n2</span><span class="o">*</span><span class="n">n1</span> <span class="o">+</span> <span class="n">n1</span><span class="o">*</span><span class="n">n2</span><span class="p">)</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">n2</span><span class="p">)</span>
<span class="go">(0, n1*n2 + n2*n1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">n1</span><span class="o">*</span><span class="n">n2</span><span class="o">*</span><span class="n">n3</span><span class="p">)</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">n1</span><span class="p">)</span>
<span class="go">(1, n1*n2*n3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">n1</span><span class="o">*</span><span class="n">n2</span><span class="o">*</span><span class="n">n3</span><span class="p">)</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">n2</span><span class="p">)</span>
<span class="go">(n1, n2*n3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">n1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">(1, (x - y)*(x - n1))</span>
</pre></div>
</div>
<p>– self is anything else:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">(1, sin(x))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">(sin(x), 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">(1, exp(x + y))</span>
</pre></div>
</div>
<p>– force self to be treated as an Add:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">as_Add</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(0, 3*x)</span>
</pre></div>
</div>
<p>– force self to be treated as a Mul:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span><span class="o">+</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">as_Add</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">(1, x + 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="o">+</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">as_Add</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">(1, x - 3)</span>
</pre></div>
</div>
<p>Note how the below differs from the above in making the
constant on the dep term positive.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">y</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="o">+</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">(y, x - 3)</span>
</pre></div>
</div>
<dl class="simple">
<dt>– use .as_independent() for true independence testing instead</dt><dd><p>of .has(). The former considers only symbols in the free
symbols while the latter considers all symbols</p>
</dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Integral</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span> <span class="o">=</span> <span class="n">Integral</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="ow">in</span> <span class="n">I</span><span class="o">.</span><span class="n">free_symbols</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">I</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Note: when trying to get independent terms, a separation method
might need to be used first. In this case, it is important to keep
track of what you send to this routine so you know how to interpret
the returned values</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">separatevars</span><span class="p">,</span> <span class="n">log</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">separatevars</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">(exp(y), exp(x))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">(x, x*y)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">separatevars</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">(x, y + 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">(x, y + 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">mul</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">(x, x*y)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;a b&#39;</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">(log(a), log(b))</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.as_leading_term">
<code class="sig-name descname">as_leading_term</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.as_leading_term" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the leading (nonzero) term of the series expansion of self.</p>
<p>The _eval_as_leading_term routines are used to do this, and they must
always return a non-zero value.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">as_leading_term</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">as_leading_term</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">x**(-2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.as_numer_denom">
<code class="sig-name descname">as_numer_denom</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.as_numer_denom" title="Permalink to this definition">¶</a></dt>
<dd><p>expression -&gt; a/b -&gt; a, b</p>
<p>This is just a stub that should be defined by
an object’s class methods to get anything else.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.normal" title="nipy.algorithms.statistics.formula.formulae.FactorTerm.normal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">normal</span></code></a></dt><dd><p>return a/b instead of a, b</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.as_ordered_factors">
<code class="sig-name descname">as_ordered_factors</code><span class="sig-paren">(</span><em class="sig-param">order=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.as_ordered_factors" title="Permalink to this definition">¶</a></dt>
<dd><p>Return list of ordered factors (if Mul) else [self].</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.as_ordered_terms">
<code class="sig-name descname">as_ordered_terms</code><span class="sig-paren">(</span><em class="sig-param">order=None</em>, <em class="sig-param">data=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.as_ordered_terms" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform an expression to an ordered list of terms.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">as_ordered_terms</span><span class="p">()</span>
<span class="go">[sin(x)**2*cos(x), sin(x)**2, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.as_poly">
<code class="sig-name descname">as_poly</code><span class="sig-paren">(</span><em class="sig-param">*gens</em>, <em class="sig-param">**args</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.as_poly" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts <code class="docutils literal notranslate"><span class="pre">self</span></code> to a polynomial or returns <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">sin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">((</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">as_poly</span><span class="p">())</span>
<span class="go">Poly(x**2 + x*y, x, y, domain=&#39;ZZ&#39;)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">((</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">as_poly</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
<span class="go">Poly(x**2 + x*y, x, y, domain=&#39;ZZ&#39;)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">((</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">as_poly</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
<span class="go">None</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.as_powers_dict">
<code class="sig-name descname">as_powers_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.as_powers_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self as a dictionary of factors with each factor being
treated as a power. The keys are the bases of the factors and the
values, the corresponding exponents. The resulting dictionary should
be used with caution if the expression is a Mul and contains non-
commutative factors since the order that they appeared will be lost in
the dictionary.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.as_ordered_factors" title="nipy.algorithms.statistics.formula.formulae.FactorTerm.as_ordered_factors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_ordered_factors</span></code></a></dt><dd><p>An alternative for noncommutative applications, returning an ordered list of factors.</p>
</dd>
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.args_cnc" title="nipy.algorithms.statistics.formula.formulae.FactorTerm.args_cnc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">args_cnc</span></code></a></dt><dd><p>Similar to as_ordered_factors, but guarantees separation of commutative and noncommutative factors.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.as_real_imag">
<code class="sig-name descname">as_real_imag</code><span class="sig-paren">(</span><em class="sig-param">deep=True</em>, <em class="sig-param">**hints</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.as_real_imag" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs complex expansion on ‘self’ and returns a tuple
containing collected both real and imaginary parts. This
method can’t be confused with re() and im() functions,
which does not perform complex expansion at evaluation.</p>
<p>However it is possible to expand both re() and im()
functions and get exactly the same results as with
a single call to this function.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">I</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x,y&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">as_real_imag</span><span class="p">()</span>
<span class="go">(x, y)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">z</span><span class="p">,</span> <span class="n">w</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">z</span> <span class="o">+</span> <span class="n">w</span><span class="o">*</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">as_real_imag</span><span class="p">()</span>
<span class="go">(re(z) - im(w), re(w) + im(z))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.as_set">
<code class="sig-name descname">as_set</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.as_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Rewrites Boolean expression in terms of real sets.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">Or</span><span class="p">,</span> <span class="n">And</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Eq</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">as_set</span><span class="p">()</span>
<span class="go">{0}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">as_set</span><span class="p">()</span>
<span class="go">Interval.open(0, oo)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">And</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">as_set</span><span class="p">()</span>
<span class="go">Interval.open(-2, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Or</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">as_set</span><span class="p">()</span>
<span class="go">Union(Interval.open(-oo, -2), Interval.open(2, oo))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.as_terms">
<code class="sig-name descname">as_terms</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.as_terms" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform an expression to a list of terms.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.assumptions0">
<em class="property">property </em><code class="sig-name descname">assumptions0</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.assumptions0" title="Permalink to this definition">¶</a></dt>
<dd><p>Return object <cite>type</cite> assumptions.</p>
<p>For example:</p>
<blockquote>
<div><p>Symbol(‘x’, real=True)
Symbol(‘x’, integer=True)</p>
</div></blockquote>
<p>are different objects. In other words, besides Python type (Symbol in
this case), the initial assumptions are also forming their typeinfo.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Symbol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">assumptions0</span>
<span class="go">{&#39;commutative&#39;: True}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">assumptions0</span>
<span class="go">{&#39;commutative&#39;: True, &#39;complex&#39;: True, &#39;hermitian&#39;: True,</span>
<span class="go">&#39;imaginary&#39;: False, &#39;negative&#39;: False, &#39;nonnegative&#39;: True,</span>
<span class="go">&#39;nonpositive&#39;: False, &#39;nonzero&#39;: True, &#39;positive&#39;: True, &#39;real&#39;: True,</span>
<span class="go">&#39;zero&#39;: False}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.atoms">
<code class="sig-name descname">atoms</code><span class="sig-paren">(</span><em class="sig-param">*types</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.atoms" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the atoms that form the current object.</p>
<p>By default, only objects that are truly atomic and can’t
be divided into smaller pieces are returned: symbols, numbers,
and number symbols like I and pi. It is possible to request
atoms of any type, however, as demonstrated below.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">I</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">sin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">()</span>
<span class="go">{1, 2, I, pi, x, y}</span>
</pre></div>
</div>
<p>If one or more types are given, the results will contain only
those types of atoms.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Number</span><span class="p">,</span> <span class="n">NumberSymbol</span><span class="p">,</span> <span class="n">Symbol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Symbol</span><span class="p">)</span>
<span class="go">{x, y}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Number</span><span class="p">)</span>
<span class="go">{1, 2}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Number</span><span class="p">,</span> <span class="n">NumberSymbol</span><span class="p">)</span>
<span class="go">{1, 2, pi}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Number</span><span class="p">,</span> <span class="n">NumberSymbol</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
<span class="go">{1, 2, I, pi}</span>
</pre></div>
</div>
<p>Note that I (imaginary unit) and zoo (complex infinity) are special
types of number symbols and are not part of the NumberSymbol class.</p>
<p>The type can be given implicitly, too:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c1"># x is a Symbol</span>
<span class="go">{x, y}</span>
</pre></div>
</div>
<p>Be careful to check your assumptions when using the implicit option
since <code class="docutils literal notranslate"><span class="pre">S(1).is_Integer</span> <span class="pre">=</span> <span class="pre">True</span></code> but <code class="docutils literal notranslate"><span class="pre">type(S(1))</span></code> is <code class="docutils literal notranslate"><span class="pre">One</span></code>, a special type
of sympy atom, while <code class="docutils literal notranslate"><span class="pre">type(S(2))</span></code> is type <code class="docutils literal notranslate"><span class="pre">Integer</span></code> and will find all
integers in an expression:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">S</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">{1}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">{1, 2}</span>
</pre></div>
</div>
<p>Finally, arguments to atoms() can select more than atomic atoms: any
sympy type (loaded in core/__init__.py) can be listed as an argument
and those types of “atoms” as found in scanning the arguments of the
expression recursively:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Mul</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.core.function</span> <span class="k">import</span> <span class="n">AppliedUndef</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Function</span><span class="p">)</span>
<span class="go">{f(x), sin(y + I*pi)}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">AppliedUndef</span><span class="p">)</span>
<span class="go">{f(x)}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Mul</span><span class="p">)</span>
<span class="go">{I*pi, 2*sin(y + I*pi)}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.binary_symbols">
<em class="property">property </em><code class="sig-name descname">binary_symbols</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.binary_symbols" title="Permalink to this definition">¶</a></dt>
<dd><p>Return from the atoms of self those which are free symbols.</p>
<p>For most expressions, all symbols are free symbols. For some classes
this is not true. e.g. Integrals use Symbols for the dummy variables
which are bound variables, so Integral has a method to return all
symbols except those. Derivative keeps track of symbols with respect
to which it will perform a derivative; those are
bound variables, too, so it has its own free_symbols method.</p>
<p>Any other method that uses bound variables should implement a
free_symbols method.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.cancel">
<code class="sig-name descname">cancel</code><span class="sig-paren">(</span><em class="sig-param">*gens</em>, <em class="sig-param">**args</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.cancel" title="Permalink to this definition">¶</a></dt>
<dd><p>See the cancel function in sympy.polys</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.canonical_variables">
<em class="property">property </em><code class="sig-name descname">canonical_variables</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.canonical_variables" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dictionary mapping any variable defined in
<code class="docutils literal notranslate"><span class="pre">self.bound_symbols</span></code> to Symbols that do not clash
with any existing symbol in the expression.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Lambda</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Lambda</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">canonical_variables</span>
<span class="go">{x: _0}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.class_key">
<em class="property">classmethod </em><code class="sig-name descname">class_key</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.class_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Nice order of classes.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.coeff">
<code class="sig-name descname">coeff</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">n=1</em>, <em class="sig-param">right=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.coeff" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the coefficient from the term(s) containing <code class="docutils literal notranslate"><span class="pre">x**n</span></code>. If <code class="docutils literal notranslate"><span class="pre">n</span></code>
is zero then all terms independent of <code class="docutils literal notranslate"><span class="pre">x</span></code> will be returned.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">x</span></code> is noncommutative, the coefficient to the left (default) or
right of <code class="docutils literal notranslate"><span class="pre">x</span></code> can be returned. The keyword ‘right’ is ignored when
<code class="docutils literal notranslate"><span class="pre">x</span></code> is commutative.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.as_coefficient" title="nipy.algorithms.statistics.formula.formulae.FactorTerm.as_coefficient"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_coefficient</span></code></a></dt><dd><p>separate the expression into a coefficient and factor</p>
</dd>
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.as_coeff_Add" title="nipy.algorithms.statistics.formula.formulae.FactorTerm.as_coeff_Add"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_coeff_Add</span></code></a></dt><dd><p>separate the additive constant from an expression</p>
</dd>
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.as_coeff_Mul" title="nipy.algorithms.statistics.formula.formulae.FactorTerm.as_coeff_Mul"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_coeff_Mul</span></code></a></dt><dd><p>separate the multiplicative constant from an expression</p>
</dd>
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.as_independent" title="nipy.algorithms.statistics.formula.formulae.FactorTerm.as_independent"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_independent</span></code></a></dt><dd><p>separate x-dependent terms/factors from others</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.polys.polytools.coeff_monomial</span></code></dt><dd><p>efficiently find the single coefficient of a monomial in Poly</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.polys.polytools.nth</span></code></dt><dd><p>like coeff_monomial but powers of monomial terms are used</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
</pre></div>
</div>
<p>You can select terms that have an explicit negative in front of them:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">-</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">2*y</span>
</pre></div>
</div>
<p>You can select terms with no Rational coefficient:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<p>You can select terms independent of x by making n=0; in this case
expr.as_independent(x)[0] is returned (and 0 will be returned instead
of None):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span>
<span class="go">x**3 + 3*x**2 + 3*x + 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">eq</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))]</span>
<span class="go">[1, 3, 3, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">-=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">eq</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))]</span>
<span class="go">[1, 3, 3, 0]</span>
</pre></div>
</div>
<p>You can select terms that have a numerical term in front of them:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">-</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">-y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">sqrt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">x</span>
</pre></div>
</div>
<p>The matching is exact:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">z</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="go">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">z</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<p>In addition, no factoring is done, so 1 + z*(1 + y) is not obtained
from the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">z</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
<p>If such factoring is desired, factor_terms can be used first:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">factor_terms</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factor_terms</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">z</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">z*(y + 1) + 1</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">o</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;n m o&#39;</span><span class="p">,</span> <span class="n">commutative</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">m</span> <span class="o">+</span> <span class="n">m</span><span class="o">*</span><span class="n">n</span><span class="o">*</span><span class="n">m</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="c1"># = (1 + m)*n*m</span>
<span class="go">1 + m</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">m</span> <span class="o">+</span> <span class="n">m</span><span class="o">*</span><span class="n">n</span><span class="o">*</span><span class="n">m</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># = (1 + m)*n*m</span>
<span class="go">m</span>
</pre></div>
</div>
<p>If there is more than one possible coefficient 0 is returned:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">m</span> <span class="o">+</span> <span class="n">m</span><span class="o">*</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<p>If there is only one possible coefficient, it is returned:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">m</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">m</span><span class="o">*</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">m</span><span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="go">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">m</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">m</span><span class="o">*</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">m</span><span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.collect">
<code class="sig-name descname">collect</code><span class="sig-paren">(</span><em class="sig-param">syms</em>, <em class="sig-param">func=None</em>, <em class="sig-param">evaluate=True</em>, <em class="sig-param">exact=False</em>, <em class="sig-param">distribute_order_term=True</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.collect" title="Permalink to this definition">¶</a></dt>
<dd><p>See the collect function in sympy.simplify</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.combsimp">
<code class="sig-name descname">combsimp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.combsimp" title="Permalink to this definition">¶</a></dt>
<dd><p>See the combsimp function in sympy.simplify</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.compare">
<code class="sig-name descname">compare</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.compare" title="Permalink to this definition">¶</a></dt>
<dd><p>Return -1, 0, 1 if the object is smaller, equal, or greater than other.</p>
<p>Not in the mathematical sense. If the object is of a different type
from the “other” then their classes are ordered according to
the sorted_classes list.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">-1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.compute_leading_term">
<code class="sig-name descname">compute_leading_term</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">logx=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.compute_leading_term" title="Permalink to this definition">¶</a></dt>
<dd><p>as_leading_term is only allowed for results of .series()
This is a wrapper to compute a series first.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.conjugate">
<code class="sig-name descname">conjugate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.conjugate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.could_extract_minus_sign">
<code class="sig-name descname">could_extract_minus_sign</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.could_extract_minus_sign" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if self is not in a canonical form with respect
to its sign.</p>
<p>For most expressions, e, there will be a difference in e and -e.
When there is, True will be returned for one and False for the
other; False will be returned if there is no difference.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">{</span><span class="n">i</span><span class="o">.</span><span class="n">could_extract_minus_sign</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="o">-</span><span class="n">e</span><span class="p">)}</span>
<span class="go">{False, True}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.count">
<code class="sig-name descname">count</code><span class="sig-paren">(</span><em class="sig-param">query</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Count the number of matching subexpressions.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.count_ops">
<code class="sig-name descname">count_ops</code><span class="sig-paren">(</span><em class="sig-param">visual=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.count_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper for count_ops that returns the operation count.</p>
</dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.default_assumptions">
<code class="sig-name descname">default_assumptions</code><em class="property"> = {}</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.default_assumptions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.diff">
<code class="sig-name descname">diff</code><span class="sig-paren">(</span><em class="sig-param">*symbols</em>, <em class="sig-param">**assumptions</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.diff" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.doit">
<code class="sig-name descname">doit</code><span class="sig-paren">(</span><em class="sig-param">**hints</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.doit" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate objects that are not evaluated by default like limits,
integrals, sums and products. All objects of this kind will be
evaluated recursively, unless some species were excluded via ‘hints’
or unless the ‘deep’ hint was set to ‘False’.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Integral</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">2</span><span class="o">*</span><span class="n">Integral</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">2*Integral(x, x)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Integral</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">doit</span><span class="p">()</span>
<span class="go">x**2</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Integral</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">doit</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">2*Integral(x, x)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.dummy_eq">
<code class="sig-name descname">dummy_eq</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">symbol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.dummy_eq" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two expressions and handle dummy symbols.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Dummy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s1">&#39;u&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">dummy_eq</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">dummy_eq</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">dummy_eq</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.equals">
<code class="sig-name descname">equals</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">failing_expression=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.equals" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if self == other, False if it doesn’t, or None. If
failing_expression is True then the expression which did not simplify
to a 0 will be returned instead of None.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">self</span></code> is a Number (or complex number) that is not zero, then
the result is False.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">self</span></code> is a number and has not evaluated to zero, evalf will be
used to test whether the expression evaluates to zero. If it does so
and the result has significance (i.e. the precision is either -1, for
a Rational result, or is greater than 1) then the evalf value will be
used to return True or False.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.evalf">
<code class="sig-name descname">evalf</code><span class="sig-paren">(</span><em class="sig-param">n=15</em>, <em class="sig-param">subs=None</em>, <em class="sig-param">maxn=100</em>, <em class="sig-param">chop=False</em>, <em class="sig-param">strict=False</em>, <em class="sig-param">quad=None</em>, <em class="sig-param">verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.evalf" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the given formula to an accuracy of n digits.
Optional keyword arguments:</p>
<blockquote>
<div><dl class="simple">
<dt>subs=&lt;dict&gt;</dt><dd><p>Substitute numerical values for symbols, e.g.
subs={x:3, y:1+pi}. The substitutions must be given as a
dictionary.</p>
</dd>
<dt>maxn=&lt;integer&gt;</dt><dd><p>Allow a maximum temporary working precision of maxn digits
(default=100)</p>
</dd>
<dt>chop=&lt;bool&gt;</dt><dd><p>Replace tiny real or imaginary parts in subresults
by exact zeros (default=False)</p>
</dd>
<dt>strict=&lt;bool&gt;</dt><dd><p>Raise PrecisionExhausted if any subresult fails to evaluate
to full accuracy, given the available maxprec
(default=False)</p>
</dd>
<dt>quad=&lt;str&gt;</dt><dd><p>Choose algorithm for numerical quadrature. By default,
tanh-sinh quadrature is used. For oscillatory
integrals on an infinite interval, try quad=’osc’.</p>
</dd>
<dt>verbose=&lt;bool&gt;</dt><dd><p>Print debug information (default=False)</p>
</dd>
</dl>
</div></blockquote>
<p class="rubric">Notes</p>
<p>When Floats are naively substituted into an expression, precision errors
may adversely affect the result. For example, adding 1e16 (a Float) to 1
will truncate to 1e16; if 1e16 is then subtracted, the result will be 0.
That is exactly what happens in the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="mf">1e16</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="mf">1e16</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">-</span> <span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<p>Using the subs argument for evalf is the accurate way to evaluate such an
expression:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">-</span> <span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="n">subs</span><span class="o">=</span><span class="n">values</span><span class="p">)</span>
<span class="go">1.00000000000000</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.expand">
<code class="sig-name descname">expand</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.expand" title="Permalink to this definition">¶</a></dt>
<dd><p>Expand an expression using hints.</p>
<p>See the docstring of the expand() function in sympy.core.function for
more information.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.expr_free_symbols">
<em class="property">property </em><code class="sig-name descname">expr_free_symbols</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.expr_free_symbols" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <code class="docutils literal notranslate"><span class="pre">free_symbols</span></code>, but returns the free symbols only if they are contained in an expression node.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">expr_free_symbols</span>
<span class="go">{x, y}</span>
</pre></div>
</div>
<p>If the expression is contained in a non-expression object, don’t return
the free symbols. Compare:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Tuple</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">expr_free_symbols</span>
<span class="go">set()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">free_symbols</span>
<span class="go">{x, y}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.extract_additively">
<code class="sig-name descname">extract_additively</code><span class="sig-paren">(</span><em class="sig-param">c</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.extract_additively" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self - c if it’s possible to subtract c from self and
make all matching coefficients move towards zero, else return None.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.extract_multiplicatively" title="nipy.algorithms.statistics.formula.formulae.FactorTerm.extract_multiplicatively"><code class="xref py py-obj docutils literal notranslate"><span class="pre">extract_multiplicatively</span></code></a>, <a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.coeff" title="nipy.algorithms.statistics.formula.formulae.FactorTerm.coeff"><code class="xref py py-obj docutils literal notranslate"><span class="pre">coeff</span></code></a>, <a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.as_coefficient" title="nipy.algorithms.statistics.formula.formulae.FactorTerm.as_coefficient"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_coefficient</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">x + 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">y</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">(x + 1)*(x + 2*y) + 3</span>
</pre></div>
</div>
<p>Sometimes auto-expansion will return a less simplified result
than desired; gcd_terms might be used in such cases:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">gcd_terms</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">4*x*(y + 1) + x*(4*y + 3) - x*(4*y + 4) + y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gcd_terms</span><span class="p">(</span><span class="n">_</span><span class="p">)</span>
<span class="go">x*(4*y + 3) + y</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.extract_branch_factor">
<code class="sig-name descname">extract_branch_factor</code><span class="sig-paren">(</span><em class="sig-param">allow_half=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.extract_branch_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Try to write self as <code class="docutils literal notranslate"><span class="pre">exp_polar(2*pi*I*n)*z</span></code> in a nice way.
Return (z, n).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">exp_polar</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">pi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exp_polar</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span><span class="o">.</span><span class="n">extract_branch_factor</span><span class="p">()</span>
<span class="go">(exp_polar(I*pi), 0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exp_polar</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span><span class="o">.</span><span class="n">extract_branch_factor</span><span class="p">()</span>
<span class="go">(1, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exp_polar</span><span class="p">(</span><span class="o">-</span><span class="n">pi</span><span class="o">*</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">extract_branch_factor</span><span class="p">()</span>
<span class="go">(exp_polar(I*pi), -1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exp_polar</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">extract_branch_factor</span><span class="p">()</span>
<span class="go">(exp_polar(x + I*pi), 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">y</span><span class="o">*</span><span class="n">exp_polar</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">I</span><span class="p">)</span><span class="o">*</span><span class="n">exp_polar</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">extract_branch_factor</span><span class="p">()</span>
<span class="go">(y*exp_polar(2*pi*x), -1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exp_polar</span><span class="p">(</span><span class="o">-</span><span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">extract_branch_factor</span><span class="p">()</span>
<span class="go">(exp_polar(-I*pi/2), 0)</span>
</pre></div>
</div>
<p>If allow_half is True, also extract exp_polar(I*pi):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">exp_polar</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span><span class="o">.</span><span class="n">extract_branch_factor</span><span class="p">(</span><span class="n">allow_half</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(1, 1/2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exp_polar</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span><span class="o">.</span><span class="n">extract_branch_factor</span><span class="p">(</span><span class="n">allow_half</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(1, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exp_polar</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span><span class="o">.</span><span class="n">extract_branch_factor</span><span class="p">(</span><span class="n">allow_half</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(1, 3/2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exp_polar</span><span class="p">(</span><span class="o">-</span><span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span><span class="o">.</span><span class="n">extract_branch_factor</span><span class="p">(</span><span class="n">allow_half</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(1, -1/2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.extract_multiplicatively">
<code class="sig-name descname">extract_multiplicatively</code><span class="sig-paren">(</span><em class="sig-param">c</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.extract_multiplicatively" title="Permalink to this definition">¶</a></dt>
<dd><p>Return None if it’s not possible to make self in the form
c * something in a nice way, i.e. preserving the properties
of arguments of self.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">Rational</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x,y&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">extract_multiplicatively</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span>
<span class="go">x*y**2</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">extract_multiplicatively</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">4</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">extract_multiplicatively</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">x</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">extract_multiplicatively</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">extract_multiplicatively</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">x/6</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.factor">
<code class="sig-name descname">factor</code><span class="sig-paren">(</span><em class="sig-param">*gens</em>, <em class="sig-param">**args</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.factor" title="Permalink to this definition">¶</a></dt>
<dd><p>See the factor() function in sympy.polys.polytools</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.find">
<code class="sig-name descname">find</code><span class="sig-paren">(</span><em class="sig-param">query</em>, <em class="sig-param">group=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.find" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all subexpressions matching a query.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.formula">
<em class="property">property </em><code class="sig-name descname">formula</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.formula" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Formula with only terms=[self].</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.fourier_series">
<code class="sig-name descname">fourier_series</code><span class="sig-paren">(</span><em class="sig-param">limits=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.fourier_series" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute fourier sine/cosine series of self.</p>
<p>See the docstring of the <a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.fourier_series" title="nipy.algorithms.statistics.formula.formulae.FactorTerm.fourier_series"><code class="xref py py-func docutils literal notranslate"><span class="pre">fourier_series()</span></code></a> in sympy.series.fourier
for more information.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.fps">
<code class="sig-name descname">fps</code><span class="sig-paren">(</span><em class="sig-param">x=None</em>, <em class="sig-param">x0=0</em>, <em class="sig-param">dir=1</em>, <em class="sig-param">hyper=True</em>, <em class="sig-param">order=4</em>, <em class="sig-param">rational=True</em>, <em class="sig-param">full=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.fps" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute formal power power series of self.</p>
<p>See the docstring of the <a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.fps" title="nipy.algorithms.statistics.formula.formulae.FactorTerm.fps"><code class="xref py py-func docutils literal notranslate"><span class="pre">fps()</span></code></a> function in sympy.series.formal for
more information.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.free_symbols">
<em class="property">property </em><code class="sig-name descname">free_symbols</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.free_symbols" title="Permalink to this definition">¶</a></dt>
<dd><p>Return from the atoms of self those which are free symbols.</p>
<p>For most expressions, all symbols are free symbols. For some classes
this is not true. e.g. Integrals use Symbols for the dummy variables
which are bound variables, so Integral has a method to return all
symbols except those. Derivative keeps track of symbols with respect
to which it will perform a derivative; those are
bound variables, too, so it has its own free_symbols method.</p>
<p>Any other method that uses bound variables should implement a
free_symbols method.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.fromiter">
<em class="property">classmethod </em><code class="sig-name descname">fromiter</code><span class="sig-paren">(</span><em class="sig-param">args</em>, <em class="sig-param">**assumptions</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.fromiter" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new object from an iterable.</p>
<p>This is a convenience function that allows one to create objects from
any iterable, without having to convert to a list or tuple first.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Tuple</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Tuple</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">(0, 1, 2, 3, 4)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.func">
<em class="property">property </em><code class="sig-name descname">func</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.func" title="Permalink to this definition">¶</a></dt>
<dd><p>The top-level function in an expression.</p>
<p>The following should hold for all objects:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;</span> <span class="n">x</span> <span class="o">==</span> <span class="n">x</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">func</span>
<span class="go">&lt;class &#39;sympy.core.mul.Mul&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">args</span>
<span class="go">(2, x)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
<span class="go">2*x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">==</span> <span class="n">a</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.gammasimp">
<code class="sig-name descname">gammasimp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.gammasimp" title="Permalink to this definition">¶</a></dt>
<dd><p>See the gammasimp function in sympy.simplify</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.getO">
<code class="sig-name descname">getO</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.getO" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the additive O(..) symbol if there is one, else None.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.getn">
<code class="sig-name descname">getn</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.getn" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the order of the expression.</p>
<p>The order is determined either from the O(…) term. If there
is no O(…) term, it returns None.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">O</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="n">O</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">getn</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">getn</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.has">
<code class="sig-name descname">has</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.has" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether any subexpression matches any of the patterns.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">sin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Note <code class="docutils literal notranslate"><span class="pre">has</span></code> is a structural algorithm with no knowledge of
mathematics. Consider the following half-open interval:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.sets</span> <span class="k">import</span> <span class="n">Interval</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">Interval</span><span class="o">.</span><span class="n">Lopen</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span> <span class="n">i</span>
<span class="go">Interval.Lopen(0, 5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">args</span>
<span class="go">(0, 5, True, False)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># there is no &quot;4&quot; in the arguments</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># there *is* a &quot;0&quot; in the arguments</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Instead, use <code class="docutils literal notranslate"><span class="pre">contains</span></code> to determine whether a number is in the
interval or not:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">expr.has(*patterns)</span></code> is exactly equivalent to
<code class="docutils literal notranslate"><span class="pre">any(expr.has(p)</span> <span class="pre">for</span> <span class="pre">p</span> <span class="pre">in</span> <span class="pre">patterns)</span></code>. In particular, <code class="docutils literal notranslate"><span class="pre">False</span></code> is
returned when the list of patterns is empty.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">has</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.integrate">
<code class="sig-name descname">integrate</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.integrate" title="Permalink to this definition">¶</a></dt>
<dd><p>See the integrate function in sympy.integrals</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.invert">
<code class="sig-name descname">invert</code><span class="sig-paren">(</span><em class="sig-param">g</em>, <em class="sig-param">*gens</em>, <em class="sig-param">**args</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.invert" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the multiplicative inverse of <code class="docutils literal notranslate"><span class="pre">self</span></code> mod <code class="docutils literal notranslate"><span class="pre">g</span></code>
where <code class="docutils literal notranslate"><span class="pre">self</span></code> (and <code class="docutils literal notranslate"><span class="pre">g</span></code>) may be symbolic expressions).</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.core.numbers.mod_inverse</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.polys.polytools.invert</span></code></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_Add">
<code class="sig-name descname">is_Add</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_Add" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_AlgebraicNumber">
<code class="sig-name descname">is_AlgebraicNumber</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_AlgebraicNumber" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_Atom">
<code class="sig-name descname">is_Atom</code><em class="property"> = True</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_Atom" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_Boolean">
<code class="sig-name descname">is_Boolean</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_Boolean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_Derivative">
<code class="sig-name descname">is_Derivative</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_Derivative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_Dummy">
<code class="sig-name descname">is_Dummy</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_Dummy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_Equality">
<code class="sig-name descname">is_Equality</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_Equality" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_Float">
<code class="sig-name descname">is_Float</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_Float" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_Function">
<code class="sig-name descname">is_Function</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_Function" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_Indexed">
<code class="sig-name descname">is_Indexed</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_Indexed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_Integer">
<code class="sig-name descname">is_Integer</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_Integer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_MatAdd">
<code class="sig-name descname">is_MatAdd</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_MatAdd" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_MatMul">
<code class="sig-name descname">is_MatMul</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_MatMul" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_Matrix">
<code class="sig-name descname">is_Matrix</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_Matrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_Mul">
<code class="sig-name descname">is_Mul</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_Mul" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_Not">
<code class="sig-name descname">is_Not</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_Not" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_Number">
<code class="sig-name descname">is_Number</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_Number" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_NumberSymbol">
<code class="sig-name descname">is_NumberSymbol</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_NumberSymbol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_Order">
<code class="sig-name descname">is_Order</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_Order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_Piecewise">
<code class="sig-name descname">is_Piecewise</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_Piecewise" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_Point">
<code class="sig-name descname">is_Point</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_Point" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_Poly">
<code class="sig-name descname">is_Poly</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_Poly" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_Pow">
<code class="sig-name descname">is_Pow</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_Pow" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_Rational">
<code class="sig-name descname">is_Rational</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_Rational" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_Relational">
<code class="sig-name descname">is_Relational</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_Relational" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_Symbol">
<code class="sig-name descname">is_Symbol</code><em class="property"> = True</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_Symbol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_Vector">
<code class="sig-name descname">is_Vector</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_Vector" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_Wild">
<code class="sig-name descname">is_Wild</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_Wild" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_algebraic">
<em class="property">property </em><code class="sig-name descname">is_algebraic</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_algebraic" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_algebraic_expr">
<code class="sig-name descname">is_algebraic_expr</code><span class="sig-paren">(</span><em class="sig-param">*syms</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_algebraic_expr" title="Permalink to this definition">¶</a></dt>
<dd><p>This tests whether a given expression is algebraic or not, in the
given symbols, syms. When syms is not given, all free symbols
will be used. The rational function does not have to be in expanded
or in any kind of canonical form.</p>
<p>This function returns False for expressions that are “algebraic
expressions” with symbolic exponents. This is a simple extension to the
is_rational_function, including rational exponentiation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_rational_function" title="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_rational_function"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_rational_function</span></code></a></p>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Algebraic_expression">https://en.wikipedia.org/wiki/Algebraic_expression</a></p></li>
</ul>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">sqrt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">is_rational_function</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">is_algebraic_expr</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>This function does not attempt any nontrivial simplifications that may
result in an expression that does not appear to be an algebraic
expression to become one.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">exp</span><span class="p">,</span> <span class="n">factor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">is_algebraic_expr</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factor</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">is_algebraic_expr</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_antihermitian">
<em class="property">property </em><code class="sig-name descname">is_antihermitian</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_antihermitian" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_commutative">
<em class="property">property </em><code class="sig-name descname">is_commutative</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_commutative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_comparable">
<code class="sig-name descname">is_comparable</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_comparable" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_complex">
<em class="property">property </em><code class="sig-name descname">is_complex</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_complex" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_composite">
<em class="property">property </em><code class="sig-name descname">is_composite</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_composite" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_constant">
<code class="sig-name descname">is_constant</code><span class="sig-paren">(</span><em class="sig-param">*wrt</em>, <em class="sig-param">**flags</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_constant" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if self is constant, False if not, or None if
the constancy could not be determined conclusively.</p>
<p>If an expression has no free symbols then it is a constant. If
there are free symbols it is possible that the expression is a
constant, perhaps (but not necessarily) zero. To test such
expressions, two strategies are tried:</p>
<p>1) numerical evaluation at two random points. If two such evaluations
give two different values and the values have a precision greater than
1 then self is not constant. If the evaluations agree or could not be
obtained with any precision, no decision is made. The numerical testing
is done only if <code class="docutils literal notranslate"><span class="pre">wrt</span></code> is different than the free symbols.</p>
<p>2) differentiation with respect to variables in ‘wrt’ (or all free
symbols if omitted) to see if the expression is constant or not. This
will not always lead to an expression that is zero even though an
expression is constant (see added test in test_expr.py). If
all derivatives are zero then self is constant with respect to the
given symbols.</p>
<p>If neither evaluation nor differentiation can prove the expression is
constant, None is returned unless two numerical values happened to be
the same and the flag <code class="docutils literal notranslate"><span class="pre">failing_number</span></code> is True – in that case the
numerical value will be returned.</p>
<p>If flag simplify=False is passed, self will not be simplified;
the default is True since self should be simplified before testing.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">cos</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">Sum</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">pi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">a</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">is_constant</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">is_constant</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span><span class="o">.</span><span class="n">is_constant</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span><span class="o">.</span><span class="n">is_constant</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span><span class="o">.</span><span class="n">is_constant</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span><span class="o">.</span><span class="n">is_constant</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span><span class="o">.</span><span class="n">is_constant</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span><span class="o">.</span><span class="n">is_constant</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">pi</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span> <span class="o">==</span> <span class="n">eq</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">pi</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="mi">3</span><span class="p">})</span> <span class="o">==</span> <span class="mi">0</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">0</span><span class="o">**</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">is_constant</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">is_constant</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">is_constant</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">one</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">one</span><span class="o">.</span><span class="n">is_constant</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="n">one</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">is_constant</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="c1"># could be 0 or 1</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_even">
<em class="property">property </em><code class="sig-name descname">is_even</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_even" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_finite">
<em class="property">property </em><code class="sig-name descname">is_finite</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_finite" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_hermitian">
<em class="property">property </em><code class="sig-name descname">is_hermitian</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_hermitian" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_hypergeometric">
<code class="sig-name descname">is_hypergeometric</code><span class="sig-paren">(</span><em class="sig-param">k</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_hypergeometric" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_imaginary">
<em class="property">property </em><code class="sig-name descname">is_imaginary</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_imaginary" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_infinite">
<em class="property">property </em><code class="sig-name descname">is_infinite</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_infinite" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_integer">
<em class="property">property </em><code class="sig-name descname">is_integer</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_integer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_irrational">
<em class="property">property </em><code class="sig-name descname">is_irrational</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_irrational" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_negative">
<em class="property">property </em><code class="sig-name descname">is_negative</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_negative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_noninteger">
<em class="property">property </em><code class="sig-name descname">is_noninteger</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_noninteger" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_nonnegative">
<em class="property">property </em><code class="sig-name descname">is_nonnegative</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_nonnegative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_nonpositive">
<em class="property">property </em><code class="sig-name descname">is_nonpositive</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_nonpositive" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_nonzero">
<em class="property">property </em><code class="sig-name descname">is_nonzero</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_nonzero" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_number">
<code class="sig-name descname">is_number</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_number" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_odd">
<em class="property">property </em><code class="sig-name descname">is_odd</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_odd" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_polar">
<em class="property">property </em><code class="sig-name descname">is_polar</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_polar" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_polynomial">
<code class="sig-name descname">is_polynomial</code><span class="sig-paren">(</span><em class="sig-param">*syms</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if self is a polynomial in syms and False otherwise.</p>
<p>This checks if self is an exact polynomial in syms.  This function
returns False for expressions that are “polynomials” with symbolic
exponents.  Thus, you should be able to apply polynomial algorithms to
expressions for which this returns True, and Poly(expr, *syms) should
work if and only if expr.is_polynomial(*syms) returns True. The
polynomial does not have to be in expanded form.  If no symbols are
given, all free symbols in the expression will be used.</p>
<p>This is not part of the assumptions system.  You cannot do
Symbol(‘z’, polynomial=True).</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Symbol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">is_polynomial</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">is_polynomial</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">is_polynomial</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="n">nonnegative</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">is_polynomial</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>This function does not attempt any nontrivial simplifications that may
result in an expression that does not appear to be a polynomial to
become one.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">factor</span><span class="p">,</span> <span class="n">cancel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">is_polynomial</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factor</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">y + 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factor</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">is_polynomial</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">is_polynomial</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cancel</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">y + 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cancel</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">is_polynomial</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>See also .is_rational_function()</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_positive">
<em class="property">property </em><code class="sig-name descname">is_positive</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_positive" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_prime">
<em class="property">property </em><code class="sig-name descname">is_prime</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_prime" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_rational">
<em class="property">property </em><code class="sig-name descname">is_rational</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_rational" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_rational_function">
<code class="sig-name descname">is_rational_function</code><span class="sig-paren">(</span><em class="sig-param">*syms</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_rational_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether function is a ratio of two polynomials in the given
symbols, syms. When syms is not given, all free symbols will be used.
The rational function does not have to be in expanded or in any kind of
canonical form.</p>
<p>This function returns False for expressions that are “rational
functions” with symbolic exponents.  Thus, you should be able to call
.as_numer_denom() and apply polynomial algorithms to the result for
expressions for which this returns True.</p>
<p>This is not part of the assumptions system.  You cannot do
Symbol(‘z’, rational_function=True).</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">sin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">is_rational_function</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">is_rational_function</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">is_rational_function</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">is_rational_function</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>This function does not attempt any nontrivial simplifications that may
result in an expression that does not appear to be a rational function
to become one.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">factor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">is_rational_function</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factor</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">(y + 1)/y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factor</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">is_rational_function</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>See also is_algebraic_expr().</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_real">
<em class="property">property </em><code class="sig-name descname">is_real</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_real" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_scalar">
<code class="sig-name descname">is_scalar</code><em class="property"> = True</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_scalar" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_symbol">
<code class="sig-name descname">is_symbol</code><em class="property"> = True</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_symbol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_transcendental">
<em class="property">property </em><code class="sig-name descname">is_transcendental</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_transcendental" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.is_zero">
<em class="property">property </em><code class="sig-name descname">is_zero</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.is_zero" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.leadterm">
<code class="sig-name descname">leadterm</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.leadterm" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the leading term a*x**b as a tuple (a, b).</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">x</span><span class="o">+</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">leadterm</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">(1, 0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">x</span><span class="o">+</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">leadterm</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">(1, -2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.limit">
<code class="sig-name descname">limit</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">xlim</em>, <em class="sig-param">dir='+'</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute limit x-&gt;xlim.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.lseries">
<code class="sig-name descname">lseries</code><span class="sig-paren">(</span><em class="sig-param">x=None</em>, <em class="sig-param">x0=0</em>, <em class="sig-param">dir='+'</em>, <em class="sig-param">logx=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.lseries" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper for series yielding an iterator of the terms of the series.</p>
<p>Note: an infinite series will yield an infinite iterator. The following,
for exaxmple, will never terminate. It will just keep printing terms
of the sin(x) series:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">lseries</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="nb">print</span> <span class="n">term</span>
</pre></div>
</div>
<p>The advantage of lseries() over nseries() is that many times you are
just interested in the next term in the series (i.e. the first term for
example), but you don’t know how many you should ask for in nseries()
using the “n” parameter.</p>
<p>See also nseries().</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.match">
<code class="sig-name descname">match</code><span class="sig-paren">(</span><em class="sig-param">pattern</em>, <em class="sig-param">old=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.match" title="Permalink to this definition">¶</a></dt>
<dd><p>Pattern matching.</p>
<p>Wild symbols match all.</p>
<p>Return <code class="docutils literal notranslate"><span class="pre">None</span></code> when expression (self) does not match
with pattern. Otherwise return a dictionary such that:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pattern</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">pattern</span><span class="p">))</span> <span class="o">==</span> <span class="bp">self</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Wild</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s2">&quot;q&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="n">p</span><span class="p">)</span>
<span class="go">{p_: x + y}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="n">q</span><span class="p">)</span>
<span class="go">{p_: x + y, q_: x + y}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">q</span><span class="o">**</span><span class="n">r</span><span class="p">)</span>
<span class="go">{p_: 4, q_: x, r_: 2}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">q</span><span class="o">**</span><span class="n">r</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">q</span><span class="o">**</span><span class="n">r</span><span class="p">))</span>
<span class="go">4*x**2</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">old</span></code> flag will give the old-style pattern matching where
expressions and patterns are essentially solved to give the
match. Both of the following give None unless <code class="docutils literal notranslate"><span class="pre">old=True</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">x</span><span class="p">,</span> <span class="n">old</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{p_: 2*x - 2}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">old</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{p_: 2/x**2}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.matches">
<code class="sig-name descname">matches</code><span class="sig-paren">(</span><em class="sig-param">expr</em>, <em class="sig-param">repl_dict={}</em>, <em class="sig-param">old=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.matches" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper method for match() that looks for a match between Wild symbols
in self and expressions in expr.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">Wild</span><span class="p">,</span> <span class="n">Basic</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;a b c&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Basic</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">Basic</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Basic</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">Basic</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">))</span>
<span class="go">{x_: b + c}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.n">
<code class="sig-name descname">n</code><span class="sig-paren">(</span><em class="sig-param">n=15</em>, <em class="sig-param">subs=None</em>, <em class="sig-param">maxn=100</em>, <em class="sig-param">chop=False</em>, <em class="sig-param">strict=False</em>, <em class="sig-param">quad=None</em>, <em class="sig-param">verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.n" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the given formula to an accuracy of n digits.
Optional keyword arguments:</p>
<blockquote>
<div><dl class="simple">
<dt>subs=&lt;dict&gt;</dt><dd><p>Substitute numerical values for symbols, e.g.
subs={x:3, y:1+pi}. The substitutions must be given as a
dictionary.</p>
</dd>
<dt>maxn=&lt;integer&gt;</dt><dd><p>Allow a maximum temporary working precision of maxn digits
(default=100)</p>
</dd>
<dt>chop=&lt;bool&gt;</dt><dd><p>Replace tiny real or imaginary parts in subresults
by exact zeros (default=False)</p>
</dd>
<dt>strict=&lt;bool&gt;</dt><dd><p>Raise PrecisionExhausted if any subresult fails to evaluate
to full accuracy, given the available maxprec
(default=False)</p>
</dd>
<dt>quad=&lt;str&gt;</dt><dd><p>Choose algorithm for numerical quadrature. By default,
tanh-sinh quadrature is used. For oscillatory
integrals on an infinite interval, try quad=’osc’.</p>
</dd>
<dt>verbose=&lt;bool&gt;</dt><dd><p>Print debug information (default=False)</p>
</dd>
</dl>
</div></blockquote>
<p class="rubric">Notes</p>
<p>When Floats are naively substituted into an expression, precision errors
may adversely affect the result. For example, adding 1e16 (a Float) to 1
will truncate to 1e16; if 1e16 is then subtracted, the result will be 0.
That is exactly what happens in the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="mf">1e16</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="mf">1e16</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">-</span> <span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<p>Using the subs argument for evalf is the accurate way to evaluate such an
expression:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">-</span> <span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="n">subs</span><span class="o">=</span><span class="n">values</span><span class="p">)</span>
<span class="go">1.00000000000000</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.name">
<code class="sig-name descname">name</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.normal">
<code class="sig-name descname">normal</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.normal" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.nseries">
<code class="sig-name descname">nseries</code><span class="sig-paren">(</span><em class="sig-param">x=None</em>, <em class="sig-param">x0=0</em>, <em class="sig-param">n=6</em>, <em class="sig-param">dir='+'</em>, <em class="sig-param">logx=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.nseries" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper to _eval_nseries if assumptions allow, else to series.</p>
<p>If x is given, x0 is 0, dir=’+’, and self has x, then _eval_nseries is
called. This calculates “n” terms in the innermost expressions and
then builds up the final series just by “cross-multiplying” everything
out.</p>
<p>The optional <code class="docutils literal notranslate"><span class="pre">logx</span></code> parameter can be used to replace any log(x) in the
returned series with a symbolic value to avoid evaluating log(x) at 0. A
symbol to use in place of log(x) should be provided.</p>
<p>Advantage – it’s fast, because we don’t have to determine how many
terms we need to calculate in advance.</p>
<p>Disadvantage – you may end up with less terms than you may have
expected, but the O(x**n) term appended will always be correct and
so the result, though perhaps shorter, will also be correct.</p>
<p>If any of those assumptions is not met, this is treated like a
wrapper to series which will try harder to return the correct
number of terms.</p>
<p>See also lseries().</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">sin</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">Symbol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">nseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="go">x - x**3/6 + x**5/120 + O(x**6)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">nseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">x - x**2/2 + x**3/3 - x**4/4 + O(x**5)</span>
</pre></div>
</div>
<p>Handling of the <code class="docutils literal notranslate"><span class="pre">logx</span></code> parameter — in the following example the
expansion fails since <code class="docutils literal notranslate"><span class="pre">sin</span></code> does not have an asymptotic expansion
at -oo (the limit of log(x) as x approaches 0):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">nseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">PoleError</span>: <span class="n">...</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">logx</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;logx&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">nseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="n">logx</span><span class="p">)</span>
<span class="go">sin(logx)</span>
</pre></div>
</div>
<p>In the following example, the expansion works but gives only an Order term
unless the <code class="docutils literal notranslate"><span class="pre">logx</span></code> parameter is used:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">nseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">O(log(x)**2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">nseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="n">logx</span><span class="p">)</span>
<span class="go">exp(logx*y)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.nsimplify">
<code class="sig-name descname">nsimplify</code><span class="sig-paren">(</span><em class="sig-param">constants=[]</em>, <em class="sig-param">tolerance=None</em>, <em class="sig-param">full=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.nsimplify" title="Permalink to this definition">¶</a></dt>
<dd><p>See the nsimplify function in sympy.simplify</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.powsimp">
<code class="sig-name descname">powsimp</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.powsimp" title="Permalink to this definition">¶</a></dt>
<dd><p>See the powsimp function in sympy.simplify</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.primitive">
<code class="sig-name descname">primitive</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.primitive" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the positive Rational that can be extracted non-recursively
from every term of self (i.e., self is treated like an Add). This is
like the as_coeff_Mul() method but primitive always extracts a positive
Rational (never a negative or a Float).</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">primitive</span><span class="p">()</span>
<span class="go">(3, (x + 1)**2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="mi">6</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span> <span class="n">a</span><span class="o">.</span><span class="n">primitive</span><span class="p">()</span>
<span class="go">(2, 3*x + 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="p">);</span> <span class="n">b</span><span class="o">.</span><span class="n">primitive</span><span class="p">()</span>
<span class="go">(1/2, x + 6)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">primitive</span><span class="p">()</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.radsimp">
<code class="sig-name descname">radsimp</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.radsimp" title="Permalink to this definition">¶</a></dt>
<dd><p>See the radsimp function in sympy.simplify</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.ratsimp">
<code class="sig-name descname">ratsimp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.ratsimp" title="Permalink to this definition">¶</a></dt>
<dd><p>See the ratsimp function in sympy.simplify</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.rcall">
<code class="sig-name descname">rcall</code><span class="sig-paren">(</span><em class="sig-param">*args</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.rcall" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply on the argument recursively through the expression tree.</p>
<p>This method is used to simulate a common abuse of notation for
operators. For instance in SymPy the the following will not work:</p>
<p><code class="docutils literal notranslate"><span class="pre">(x+Lambda(y,</span> <span class="pre">2*y))(z)</span> <span class="pre">==</span> <span class="pre">x+2*z</span></code>,</p>
<p>however you can use</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Lambda</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">Lambda</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">rcall</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
<span class="go">x + 2*z</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.refine">
<code class="sig-name descname">refine</code><span class="sig-paren">(</span><em class="sig-param">assumption=True</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.refine" title="Permalink to this definition">¶</a></dt>
<dd><p>See the refine function in sympy.assumptions</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.removeO">
<code class="sig-name descname">removeO</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.removeO" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes the additive O(..) symbol if there is one</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.replace">
<code class="sig-name descname">replace</code><span class="sig-paren">(</span><em class="sig-param">query</em>, <em class="sig-param">value</em>, <em class="sig-param">map=False</em>, <em class="sig-param">simultaneous=True</em>, <em class="sig-param">exact=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.replace" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace matching subexpressions of <code class="docutils literal notranslate"><span class="pre">self</span></code> with <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">map</span> <span class="pre">=</span> <span class="pre">True</span></code> then also return the mapping {old: new} where <code class="docutils literal notranslate"><span class="pre">old</span></code>
was a sub-expression found with query and <code class="docutils literal notranslate"><span class="pre">new</span></code> is the replacement
value for it. If the expression itself doesn’t match the query, then
the returned value will be <code class="docutils literal notranslate"><span class="pre">self.xreplace(map)</span></code> otherwise it should
be <code class="docutils literal notranslate"><span class="pre">self.subs(ordered(map.items()))</span></code>.</p>
<p>Traverses an expression tree and performs replacement of matching
subexpressions from the bottom to the top of the tree. The default
approach is to do the replacement in a simultaneous fashion so
changes made are targeted only once. If this is not desired or causes
problems, <code class="docutils literal notranslate"><span class="pre">simultaneous</span></code> can be set to False. In addition, if an
expression containing more than one Wild symbol is being used to match
subexpressions and  the <code class="docutils literal notranslate"><span class="pre">exact</span></code> flag is True, then the match will only
succeed if non-zero values are received for each Wild that appears in
the match pattern.</p>
<p>The list of possible combinations of queries and replacement values
is listed below:</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.subs" title="nipy.algorithms.statistics.formula.formulae.FactorTerm.subs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subs</span></code></a></dt><dd><p>substitution of subexpressions as defined by the objects themselves.</p>
</dd>
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.xreplace" title="nipy.algorithms.statistics.formula.formulae.FactorTerm.xreplace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">xreplace</span></code></a></dt><dd><p>exact node replacement in expr tree; also capable of using matching rules</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>Initial setup</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">log</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">tan</span><span class="p">,</span> <span class="n">Wild</span><span class="p">,</span> <span class="n">Mul</span><span class="p">,</span> <span class="n">Add</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">+</span> <span class="n">tan</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<dl>
<dt>1.1. type -&gt; type</dt><dd><p>obj.replace(type, newtype)</p>
<p>When object of type <code class="docutils literal notranslate"><span class="pre">type</span></code> is found, replace it with the
result of passing its argument(s) to <code class="docutils literal notranslate"><span class="pre">newtype</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">)</span>
<span class="go">log(cos(x)) + tan(cos(x**2))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="nb">map</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(cos(x), {sin(x): cos(x)})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">Mul</span><span class="p">,</span> <span class="n">Add</span><span class="p">)</span>
<span class="go">x + y</span>
</pre></div>
</div>
</dd>
<dt>1.2. type -&gt; func</dt><dd><p>obj.replace(type, func)</p>
<p>When object of type <code class="docutils literal notranslate"><span class="pre">type</span></code> is found, apply <code class="docutils literal notranslate"><span class="pre">func</span></code> to its
argument(s). <code class="docutils literal notranslate"><span class="pre">func</span></code> must be written to handle the number
of arguments of <code class="docutils literal notranslate"><span class="pre">type</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">arg</span><span class="p">:</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">arg</span><span class="p">))</span>
<span class="go">log(sin(2*x)) + tan(sin(2*x**2))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">Mul</span><span class="p">,</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)))</span>
<span class="go">sin(2*x*y)</span>
</pre></div>
</div>
</dd>
<dt>2.1. pattern -&gt; expr</dt><dd><p>obj.replace(pattern(wild), expr(wild))</p>
<p>Replace subexpressions matching <code class="docutils literal notranslate"><span class="pre">pattern</span></code> with the expression
written in terms of the Wild symbols in <code class="docutils literal notranslate"><span class="pre">pattern</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Wild</span><span class="p">,</span> <span class="s1">&#39;ab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">tan</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
<span class="go">log(tan(x)) + tan(tan(x**2))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">tan</span><span class="p">(</span><span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
<span class="go">log(tan(x/2)) + tan(tan(x**2/2))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">a</span><span class="p">)</span>
<span class="go">log(x) + tan(x**2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="go">y</span>
</pre></div>
</div>
<p>Matching is exact by default when more than one Wild symbol
is used: matching fails unless the match gives non-zero
values for all Wild symbols:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span>
<span class="go">y - 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span>
<span class="go">2*x</span>
</pre></div>
</div>
<p>When set to False, the results may be non-intuitive:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">2/x</span>
</pre></div>
</div>
</dd>
<dt>2.2. pattern -&gt; func</dt><dd><p>obj.replace(pattern(wild), lambda wild: expr(wild))</p>
<p>All behavior is the same as in 2.1 but now a function in terms of
pattern variables is used rather than an expression:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="p">))</span>
<span class="go">log(sin(2*x)) + tan(sin(2*x**2))</span>
</pre></div>
</div>
</dd>
<dt>3.1. func -&gt; func</dt><dd><p>obj.replace(filter, func)</p>
<p>Replace subexpression <code class="docutils literal notranslate"><span class="pre">e</span></code> with <code class="docutils literal notranslate"><span class="pre">func(e)</span></code> if <code class="docutils literal notranslate"><span class="pre">filter(e)</span></code>
is True.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="k">lambda</span> <span class="n">expr</span><span class="p">:</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Number</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">expr</span><span class="p">:</span> <span class="n">expr</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="go">4*sin(x**9)</span>
</pre></div>
</div>
</dd>
</dl>
<p>The expression itself is also targeted by the query but is done in
such a fashion that changes are not made twice.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="go">2*x*(2*x*y + 1)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.rewrite">
<code class="sig-name descname">rewrite</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**hints</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.rewrite" title="Permalink to this definition">¶</a></dt>
<dd><p>Rewrite functions in terms of other functions.</p>
<p>Rewrites expression containing applications of functions
of one kind in terms of functions of different kind. For
example you can rewrite trigonometric functions as complex
exponentials or combinatorial functions as gamma function.</p>
<p>As a pattern this function accepts a list of functions to
to rewrite (instances of DefinedFunction class). As rule
you can use string or a destination function instance (in
this case rewrite() will use the str() function).</p>
<p>There is also the possibility to pass hints on how to rewrite
the given expressions. For now there is only one such hint
defined called ‘deep’. When ‘deep’ is set to False it will
forbid functions to rewrite their contents.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">sin</span><span class="p">,</span> <span class="n">exp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
</pre></div>
</div>
<p>Unspecified pattern:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span>
<span class="go">-I*(exp(I*x) - exp(-I*x))/2</span>
</pre></div>
</div>
<p>Pattern as a single function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="n">exp</span><span class="p">)</span>
<span class="go">-I*(exp(I*x) - exp(-I*x))/2</span>
</pre></div>
</div>
<p>Pattern as a list of functions:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">rewrite</span><span class="p">([</span><span class="n">sin</span><span class="p">,</span> <span class="p">],</span> <span class="n">exp</span><span class="p">)</span>
<span class="go">-I*(exp(I*x) - exp(-I*x))/2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.round">
<code class="sig-name descname">round</code><span class="sig-paren">(</span><em class="sig-param">p=0</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.round" title="Permalink to this definition">¶</a></dt>
<dd><p>Return x rounded to the given decimal place.</p>
<p>If a complex number would results, apply round to the real
and imaginary components of the number.</p>
<p class="rubric">Notes</p>
<p>Do not confuse the Python builtin function, round, with the
SymPy method of the same name. The former always returns a float
(or raises an error if applied to a complex value) while the
latter returns either a Number or a complex number:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="mi">123</span><span class="p">),</span> <span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="n">Number</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="n">Number</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">((</span><span class="mi">3</span><span class="o">*</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(),</span> <span class="n">Mul</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">((</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(),</span> <span class="n">Add</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">pi</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">Add</span><span class="p">,</span> <span class="n">Mul</span><span class="p">,</span> <span class="n">Number</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="p">(</span><span class="mf">10.5</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">()</span>
<span class="go">11.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">.</span><span class="n">round</span><span class="p">()</span>
<span class="go">3.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">3.14</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span> <span class="o">+</span> <span class="n">E</span><span class="o">*</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">()</span>
<span class="go">6. + 3.*I</span>
</pre></div>
</div>
<p>The round method has a chopping effect:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span> <span class="o">+</span> <span class="n">I</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">()</span>
<span class="go">6.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">10</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">()</span>
<span class="go">2.*I</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">10</span> <span class="o">+</span> <span class="n">E</span><span class="o">*</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0.31 + 2.72*I</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.separate">
<code class="sig-name descname">separate</code><span class="sig-paren">(</span><em class="sig-param">deep=False</em>, <em class="sig-param">force=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.separate" title="Permalink to this definition">¶</a></dt>
<dd><p>See the separate function in sympy.simplify</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.series">
<code class="sig-name descname">series</code><span class="sig-paren">(</span><em class="sig-param">x=None</em>, <em class="sig-param">x0=0</em>, <em class="sig-param">n=6</em>, <em class="sig-param">dir='+'</em>, <em class="sig-param">logx=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.series" title="Permalink to this definition">¶</a></dt>
<dd><p>Series expansion of “self” around <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">x0</span></code> yielding either terms of
the series one by one (the lazy series given when n=None), else
all the terms at once when n != None.</p>
<p>Returns the series expansion of “self” around the point <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">x0</span></code>
with respect to <code class="docutils literal notranslate"><span class="pre">x</span></code> up to <code class="docutils literal notranslate"><span class="pre">O((x</span> <span class="pre">-</span> <span class="pre">x0)**n,</span> <span class="pre">x,</span> <span class="pre">x0)</span></code> (default n is 6).</p>
<p>If <code class="docutils literal notranslate"><span class="pre">x=None</span></code> and <code class="docutils literal notranslate"><span class="pre">self</span></code> is univariate, the univariate symbol will
be supplied, otherwise an error will be raised.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">cos</span><span class="p">,</span> <span class="n">exp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">()</span>
<span class="go">1 - x**2/2 + x**4/24 + O(x**6)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="go">1 - x**2/2 + O(x**4)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">cos(1) - (x - 1)*sin(1) + O((x - 1)**2, (x, 1))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">exp</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">cos(x + 1) - y*sin(x + 1) + O(y**2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">cos(exp(y)) - x*sin(exp(y)) + O(x**2)</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">n=None</span></code> then a generator of the series terms will be returned.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">term</span><span class="o">=</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">term</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>
<span class="go">[1, -x**2/2]</span>
</pre></div>
</div>
<p>For <code class="docutils literal notranslate"><span class="pre">dir=+</span></code> (default) the series is calculated from the right and
for <code class="docutils literal notranslate"><span class="pre">dir=-</span></code> the series from the left. For smooth functions this
flag will not alter the results.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="nb">dir</span><span class="o">=</span><span class="s2">&quot;+&quot;</span><span class="p">)</span>
<span class="go">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="nb">dir</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">)</span>
<span class="go">-x</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.simplify">
<code class="sig-name descname">simplify</code><span class="sig-paren">(</span><em class="sig-param">ratio=1.7</em>, <em class="sig-param">measure=None</em>, <em class="sig-param">rational=False</em>, <em class="sig-param">inverse=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.simplify" title="Permalink to this definition">¶</a></dt>
<dd><p>See the simplify function in sympy.simplify</p>
</dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.sort_key">
<code class="sig-name descname">sort_key</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.sort_key" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.subs">
<code class="sig-name descname">subs</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.subs" title="Permalink to this definition">¶</a></dt>
<dd><p>Substitutes old for new in an expression after sympifying args.</p>
<dl class="simple">
<dt><cite>args</cite> is either:</dt><dd><ul class="simple">
<li><p>two arguments, e.g. foo.subs(old, new)</p></li>
<li><dl class="simple">
<dt>one iterable argument, e.g. foo.subs(iterable). The iterable may be</dt><dd><dl class="simple">
<dt>o an iterable container with (old, new) pairs. In this case the</dt><dd><p>replacements are processed in the order given with successive
patterns possibly affecting replacements already made.</p>
</dd>
<dt>o a dict or set whose key/value items correspond to old/new pairs.</dt><dd><p>In this case the old/new pairs will be sorted by op count and in
case of a tie, by number of args and the default_sort_key. The
resulting sorted list is then processed as an iterable container
(see previous).</p>
</dd>
</dl>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p>If the keyword <code class="docutils literal notranslate"><span class="pre">simultaneous</span></code> is True, the subexpressions will not be
evaluated until all the substitutions have been made.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.replace" title="nipy.algorithms.statistics.formula.formulae.FactorTerm.replace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">replace</span></code></a></dt><dd><p>replacement capable of doing wildcard-like matching, parsing of match, and conditional replacements</p>
</dd>
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.xreplace" title="nipy.algorithms.statistics.formula.formulae.FactorTerm.xreplace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">xreplace</span></code></a></dt><dd><p>exact node replacement in expr tree; also capable of using matching rules</p>
</dd>
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.evalf" title="nipy.algorithms.statistics.formula.formulae.FactorTerm.evalf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">evalf</span></code></a></dt><dd><p>calculates the given formula to a desired level of precision</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">pi</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">oo</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pi</span><span class="p">)</span>
<span class="go">pi*y + 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span><span class="n">pi</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span><span class="mi">2</span><span class="p">})</span>
<span class="go">1 + 2*pi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="n">pi</span><span class="p">),</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="go">1 + 2*pi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reps</span> <span class="o">=</span> <span class="p">[(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">reps</span><span class="p">))</span>
<span class="go">x**2 + 2</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">y**2 + y</span>
</pre></div>
</div>
<p>To replace only the x**2 but not the x**4, use xreplace:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">:</span> <span class="n">y</span><span class="p">})</span>
<span class="go">x**4 + y</span>
</pre></div>
</div>
<p>To delay evaluation until all substitutions have been made,
set the keyword <code class="docutils literal notranslate"><span class="pre">simultaneous</span></code> to True:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span> <span class="n">simultaneous</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
<p>This has the added feature of not allowing subsequent substitutions
to affect those already made:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">})</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">},</span> <span class="n">simultaneous</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">y/(x + y)</span>
</pre></div>
</div>
<p>In order to obtain a canonical result, unordered iterables are
sorted by count_op length, number of arguments and by the
default_sort_key to break any ties. All other iterables are left
unsorted.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)),</span> <span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">),</span> <span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">),</span> <span class="n">c</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">E</span> <span class="o">=</span> <span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">e</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="nb">dict</span><span class="p">([</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">E</span><span class="p">]))</span>
<span class="go">a*c*sin(d*e) + b</span>
</pre></div>
</div>
<p>The resulting expression represents a literal replacement of the
old arguments with the new arguments. This may not reflect the
limiting behavior of the expression:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">oo</span><span class="p">})</span>
<span class="go">nan</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">limit</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">oo</span><span class="p">)</span>
<span class="go">oo</span>
</pre></div>
</div>
<p>If the substitution will be followed by numerical
evaluation, it is better to pass the substitution to
evalf as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="n">subs</span><span class="o">=</span><span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">},</span> <span class="n">n</span><span class="o">=</span><span class="mi">21</span><span class="p">)</span>
<span class="go">0.333333333333333333333</span>
</pre></div>
</div>
<p>rather than</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">})</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="mi">21</span><span class="p">)</span>
<span class="go">0.333333333333333314830</span>
</pre></div>
</div>
<p>as the former will ensure that the desired level of precision is
obtained.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.taylor_term">
<code class="sig-name descname">taylor_term</code><span class="sig-paren">(</span><em class="sig-param">n</em>, <em class="sig-param">x</em>, <em class="sig-param">*previous_terms</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.taylor_term" title="Permalink to this definition">¶</a></dt>
<dd><p>General method for the taylor term.</p>
<p>This method is slow, because it differentiates n-times. Subclasses can
redefine it to make it faster by using the “previous_terms”.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.to_nnf">
<code class="sig-name descname">to_nnf</code><span class="sig-paren">(</span><em class="sig-param">simplify=True</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.to_nnf" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.together">
<code class="sig-name descname">together</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.together" title="Permalink to this definition">¶</a></dt>
<dd><p>See the together function in sympy.polys</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.transpose">
<code class="sig-name descname">transpose</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.transpose" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.trigsimp">
<code class="sig-name descname">trigsimp</code><span class="sig-paren">(</span><em class="sig-param">**args</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.trigsimp" title="Permalink to this definition">¶</a></dt>
<dd><p>See the trigsimp function in sympy.simplify</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.FactorTerm.xreplace">
<code class="sig-name descname">xreplace</code><span class="sig-paren">(</span><em class="sig-param">rule</em>, <em class="sig-param">hack2=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.xreplace" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace occurrences of objects within the expression.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>rule</strong> : dict-like</p>
<blockquote>
<div><p>Expresses a replacement rule</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>xreplace</strong> : the result of the replacement</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.replace" title="nipy.algorithms.statistics.formula.formulae.FactorTerm.replace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">replace</span></code></a></dt><dd><p>replacement capable of doing wildcard-like matching, parsing of match, and conditional replacements</p>
</dd>
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.FactorTerm.subs" title="nipy.algorithms.statistics.formula.formulae.FactorTerm.subs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subs</span></code></a></dt><dd><p>substitution of subexpressions as defined by the objects themselves.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">exp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x y z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">pi</span><span class="p">})</span>
<span class="go">pi*y + 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">pi</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="go">1 + 2*pi</span>
</pre></div>
</div>
<p>Replacements occur only if an entire node in the expression tree is
matched:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">:</span> <span class="n">pi</span><span class="p">})</span>
<span class="go">z + pi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">:</span> <span class="n">pi</span><span class="p">})</span>
<span class="go">x*y*z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">:</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">z</span><span class="p">})</span>
<span class="go">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">:</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">z</span><span class="p">})</span>
<span class="go">4*z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="go">x + y + 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">:</span> <span class="n">y</span><span class="p">})</span>
<span class="go">x + exp(y) + 2</span>
</pre></div>
</div>
<p>xreplace doesn’t differentiate between free and bound symbols. In the
following, subs(x, y) would not change x since it is a bound symbol,
but xreplace does:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Integral</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Integral</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">y</span><span class="p">})</span>
<span class="go">Integral(y, (y, 1, 2*y))</span>
</pre></div>
</div>
<p>Trying to replace x with an expression raises an error:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Integral</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">})</span> 
<span class="go">ValueError: Invalid limits given: ((2*y, 1, 4*y),)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="formula">
<h3><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Formula" title="nipy.algorithms.statistics.formula.formulae.Formula"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formula</span></code></a><a class="headerlink" href="#formula" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="nipy.algorithms.statistics.formula.formulae.Formula">
<em class="property">class </em><code class="sig-prename descclassname">nipy.algorithms.statistics.formula.formulae.</code><code class="sig-name descname">Formula</code><span class="sig-paren">(</span><em class="sig-param">seq</em>, <em class="sig-param">char='b'</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/nipy/algorithms/statistics/formula/formulae.html#Formula"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Formula" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A Formula is a model for a mean in a regression model.</p>
<p>It is often given by a sequence of sympy expressions, with the mean
model being the sum of each term multiplied by a linear regression
coefficient.</p>
<p>The expressions may depend on additional Symbol instances, giving a
non-linear regression model.</p>
<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Formula.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">seq</em>, <em class="sig-param">char='b'</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/nipy/algorithms/statistics/formula/formulae.html#Formula.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Formula.__init__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>seq</strong> : sequence of <code class="docutils literal notranslate"><span class="pre">sympy.Basic</span></code></p>
<p><strong>char</strong> : str, optional</p>
<blockquote>
<div><p>character for regression coefficient</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Formula.coefs">
<em class="property">property </em><code class="sig-name descname">coefs</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Formula.coefs" title="Permalink to this definition">¶</a></dt>
<dd><p>Coefficients in the linear regression formula.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Formula.terms">
<em class="property">property </em><code class="sig-name descname">terms</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Formula.terms" title="Permalink to this definition">¶</a></dt>
<dd><p>Terms in the linear regression formula.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Formula.mean">
<em class="property">property </em><code class="sig-name descname">mean</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Formula.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Expression for the mean, expressed as a linear combination of terms, each with dummy variables in front.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Formula.design_expr">
<em class="property">property </em><code class="sig-name descname">design_expr</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Formula.design_expr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Formula.dtype">
<em class="property">property </em><code class="sig-name descname">dtype</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Formula.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>The dtype of the design matrix of the Formula.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Formula.fromrec">
<em class="property">static </em><code class="sig-name descname">fromrec</code><span class="sig-paren">(</span><em class="sig-param">rec</em>, <em class="sig-param">keep=[]</em>, <em class="sig-param">drop=[]</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/nipy/algorithms/statistics/formula/formulae.html#Formula.fromrec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Formula.fromrec" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct Formula from recarray</p>
<p>For fields with a string-dtype, it is assumed that these are
qualtiatitve regressors, i.e. Factors.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>rec: recarray</strong></p>
<blockquote>
<div><p>Recarray whose field names will be used to create a formula.</p>
</div></blockquote>
<p><strong>keep: []</strong></p>
<blockquote>
<div><p>Field names to explicitly keep, dropping all others.</p>
</div></blockquote>
<p><strong>drop: []</strong></p>
<blockquote>
<div><p>Field names to drop.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Formula.subs">
<code class="sig-name descname">subs</code><span class="sig-paren">(</span><em class="sig-param">old</em>, <em class="sig-param">new</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/nipy/algorithms/statistics/formula/formulae.html#Formula.subs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Formula.subs" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a sympy substitution on all terms in the Formula</p>
<p>Returns a new instance of the same class</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>old</strong> : sympy.Basic</p>
<blockquote>
<div><p>The expression to be changed</p>
</div></blockquote>
<p><strong>new</strong> : sympy.Basic</p>
<blockquote>
<div><p>The value to change it to.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>newf</strong> : Formula</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="p">[</span><span class="n">Term</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="s1">&#39;st&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="p">[</span><span class="n">sympy</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="s1">&#39;fg&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">form</span> <span class="o">=</span> <span class="n">Formula</span><span class="p">([</span><span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="n">g</span><span class="p">(</span><span class="n">s</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">newform</span> <span class="o">=</span> <span class="n">form</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="s1">&#39;h&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">newform</span><span class="o">.</span><span class="n">terms</span>
<span class="go">array([f(t), h(s)], dtype=object)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">form</span><span class="o">.</span><span class="n">terms</span>
<span class="go">array([f(t), g(s)], dtype=object)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Formula.params">
<em class="property">property </em><code class="sig-name descname">params</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Formula.params" title="Permalink to this definition">¶</a></dt>
<dd><p>The parameters in the Formula.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Formula.design">
<code class="sig-name descname">design</code><span class="sig-paren">(</span><em class="sig-param">input</em>, <em class="sig-param">param=None</em>, <em class="sig-param">return_float=False</em>, <em class="sig-param">contrasts=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/nipy/algorithms/statistics/formula/formulae.html#Formula.design"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Formula.design" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct the design matrix, and optional contrast matrices.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>input</strong> : np.recarray</p>
<blockquote>
<div><p>Recarray including fields needed to compute the Terms in
getparams(self.design_expr).</p>
</div></blockquote>
<p><strong>param</strong> : None or np.recarray</p>
<blockquote>
<div><p>Recarray including fields that are not Terms in
getparams(self.design_expr)</p>
</div></blockquote>
<p><strong>return_float</strong> : bool, optional</p>
<blockquote>
<div><p>If True, return a np.float array rather than a np.recarray</p>
</div></blockquote>
<p><strong>contrasts</strong> : None or dict, optional</p>
<blockquote>
<div><p>Contrasts. The items in this dictionary should be (str,
Formula) pairs where a contrast matrix is constructed for
each Formula by evaluating its design at the same parameters
as self.design. If not None, then the return_float is set to True.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>des</strong> : 2D array</p>
<blockquote>
<div><p>design matrix</p>
</div></blockquote>
<p><strong>cmatrices</strong> : dict, optional</p>
<blockquote>
<div><p>Dictionary with keys from <cite>contrasts</cite> input, and contrast matrices
corresponding to <cite>des</cite> design matrix.  Returned only if <cite>contrasts</cite>
input is not None</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="randomeffects">
<h3><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.RandomEffects" title="nipy.algorithms.statistics.formula.formulae.RandomEffects"><code class="xref py py-class docutils literal notranslate"><span class="pre">RandomEffects</span></code></a><a class="headerlink" href="#randomeffects" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="nipy.algorithms.statistics.formula.formulae.RandomEffects">
<em class="property">class </em><code class="sig-prename descclassname">nipy.algorithms.statistics.formula.formulae.</code><code class="sig-name descname">RandomEffects</code><span class="sig-paren">(</span><em class="sig-param">seq</em>, <em class="sig-param">sigma=None</em>, <em class="sig-param">char='e'</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/nipy/algorithms/statistics/formula/formulae.html#RandomEffects"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.RandomEffects" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Formula" title="nipy.algorithms.statistics.formula.formulae.Formula"><code class="xref py py-class docutils literal notranslate"><span class="pre">nipy.algorithms.statistics.formula.formulae.Formula</span></code></a></p>
<p>Covariance matrices for common random effects analyses.</p>
<p class="rubric">Examples</p>
<p>Two subjects (here named 2 and 3):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">subj</span> <span class="o">=</span> <span class="n">make_recarray</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="s1">&#39;s&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subj_factor</span> <span class="o">=</span> <span class="n">Factor</span><span class="p">(</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
</pre></div>
</div>
<p>By default the covariance matrix is symbolic.  The display differs a little
between sympy versions (hence we don’t check it in the doctests):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">RandomEffects</span><span class="p">(</span><span class="n">subj_factor</span><span class="o">.</span><span class="n">terms</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">subj</span><span class="p">)</span> 
<span class="go">array([[_s2_0, _s2_0, _s2_0, 0, 0],</span>
<span class="go">       [_s2_0, _s2_0, _s2_0, 0, 0],</span>
<span class="go">       [_s2_0, _s2_0, _s2_0, 0, 0],</span>
<span class="go">       [0, 0, 0, _s2_1, _s2_1],</span>
<span class="go">       [0, 0, 0, _s2_1, _s2_1]], dtype=object)</span>
</pre></div>
</div>
<p>With a numeric <cite>sigma</cite>, you get a numeric array:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">RandomEffects</span><span class="p">(</span><span class="n">subj_factor</span><span class="o">.</span><span class="n">terms</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">subj</span><span class="p">)</span>
<span class="go">array([[ 4.,  4.,  4.,  1.,  1.],</span>
<span class="go">       [ 4.,  4.,  4.,  1.,  1.],</span>
<span class="go">       [ 4.,  4.,  4.,  1.,  1.],</span>
<span class="go">       [ 1.,  1.,  1.,  6.,  6.],</span>
<span class="go">       [ 1.,  1.,  1.,  6.,  6.]])</span>
</pre></div>
</div>
<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.RandomEffects.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">seq</em>, <em class="sig-param">sigma=None</em>, <em class="sig-param">char='e'</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/nipy/algorithms/statistics/formula/formulae.html#RandomEffects.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.RandomEffects.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize random effects instance</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>seq</strong> : [<code class="docutils literal notranslate"><span class="pre">sympy.Basic</span></code>]</p>
<p><strong>sigma</strong> : ndarray</p>
<blockquote>
<div><p>Covariance of the random effects. Defaults
to a diagonal with entries for each random
effect.</p>
</div></blockquote>
<p><strong>char</strong> : character for regression coefficient</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.RandomEffects.cov">
<code class="sig-name descname">cov</code><span class="sig-paren">(</span><em class="sig-param">term</em>, <em class="sig-param">param=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/nipy/algorithms/statistics/formula/formulae.html#RandomEffects.cov"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.RandomEffects.cov" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the covariance matrix for some given data.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>term</strong> : np.recarray</p>
<blockquote>
<div><p>Recarray including fields corresponding to the Terms in
getparams(self.design_expr).</p>
</div></blockquote>
<p><strong>param</strong> : np.recarray</p>
<blockquote>
<div><p>Recarray including fields that are not Terms in
getparams(self.design_expr)</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>C</strong> : ndarray</p>
<blockquote>
<div><p>Covariance matrix implied by design and self.sigma.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.RandomEffects.coefs">
<em class="property">property </em><code class="sig-name descname">coefs</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.RandomEffects.coefs" title="Permalink to this definition">¶</a></dt>
<dd><p>Coefficients in the linear regression formula.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.RandomEffects.design">
<code class="sig-name descname">design</code><span class="sig-paren">(</span><em class="sig-param">input</em>, <em class="sig-param">param=None</em>, <em class="sig-param">return_float=False</em>, <em class="sig-param">contrasts=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.RandomEffects.design" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct the design matrix, and optional contrast matrices.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>input</strong> : np.recarray</p>
<blockquote>
<div><p>Recarray including fields needed to compute the Terms in
getparams(self.design_expr).</p>
</div></blockquote>
<p><strong>param</strong> : None or np.recarray</p>
<blockquote>
<div><p>Recarray including fields that are not Terms in
getparams(self.design_expr)</p>
</div></blockquote>
<p><strong>return_float</strong> : bool, optional</p>
<blockquote>
<div><p>If True, return a np.float array rather than a np.recarray</p>
</div></blockquote>
<p><strong>contrasts</strong> : None or dict, optional</p>
<blockquote>
<div><p>Contrasts. The items in this dictionary should be (str,
Formula) pairs where a contrast matrix is constructed for
each Formula by evaluating its design at the same parameters
as self.design. If not None, then the return_float is set to True.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>des</strong> : 2D array</p>
<blockquote>
<div><p>design matrix</p>
</div></blockquote>
<p><strong>cmatrices</strong> : dict, optional</p>
<blockquote>
<div><p>Dictionary with keys from <cite>contrasts</cite> input, and contrast matrices
corresponding to <cite>des</cite> design matrix.  Returned only if <cite>contrasts</cite>
input is not None</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.RandomEffects.design_expr">
<em class="property">property </em><code class="sig-name descname">design_expr</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.RandomEffects.design_expr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.RandomEffects.dtype">
<em class="property">property </em><code class="sig-name descname">dtype</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.RandomEffects.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>The dtype of the design matrix of the Formula.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.RandomEffects.fromrec">
<em class="property">static </em><code class="sig-name descname">fromrec</code><span class="sig-paren">(</span><em class="sig-param">rec</em>, <em class="sig-param">keep=[]</em>, <em class="sig-param">drop=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.RandomEffects.fromrec" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct Formula from recarray</p>
<p>For fields with a string-dtype, it is assumed that these are
qualtiatitve regressors, i.e. Factors.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>rec: recarray</strong></p>
<blockquote>
<div><p>Recarray whose field names will be used to create a formula.</p>
</div></blockquote>
<p><strong>keep: []</strong></p>
<blockquote>
<div><p>Field names to explicitly keep, dropping all others.</p>
</div></blockquote>
<p><strong>drop: []</strong></p>
<blockquote>
<div><p>Field names to drop.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.RandomEffects.mean">
<em class="property">property </em><code class="sig-name descname">mean</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.RandomEffects.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Expression for the mean, expressed as a linear combination of terms, each with dummy variables in front.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.RandomEffects.params">
<em class="property">property </em><code class="sig-name descname">params</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.RandomEffects.params" title="Permalink to this definition">¶</a></dt>
<dd><p>The parameters in the Formula.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.RandomEffects.subs">
<code class="sig-name descname">subs</code><span class="sig-paren">(</span><em class="sig-param">old</em>, <em class="sig-param">new</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.RandomEffects.subs" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a sympy substitution on all terms in the Formula</p>
<p>Returns a new instance of the same class</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>old</strong> : sympy.Basic</p>
<blockquote>
<div><p>The expression to be changed</p>
</div></blockquote>
<p><strong>new</strong> : sympy.Basic</p>
<blockquote>
<div><p>The value to change it to.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>newf</strong> : Formula</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="p">[</span><span class="n">Term</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="s1">&#39;st&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="p">[</span><span class="n">sympy</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="s1">&#39;fg&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">form</span> <span class="o">=</span> <span class="n">Formula</span><span class="p">([</span><span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="n">g</span><span class="p">(</span><span class="n">s</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">newform</span> <span class="o">=</span> <span class="n">form</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="s1">&#39;h&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">newform</span><span class="o">.</span><span class="n">terms</span>
<span class="go">array([f(t), h(s)], dtype=object)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">form</span><span class="o">.</span><span class="n">terms</span>
<span class="go">array([f(t), g(s)], dtype=object)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.RandomEffects.terms">
<em class="property">property </em><code class="sig-name descname">terms</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.RandomEffects.terms" title="Permalink to this definition">¶</a></dt>
<dd><p>Terms in the linear regression formula.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="term">
<h3><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Term" title="nipy.algorithms.statistics.formula.formulae.Term"><code class="xref py py-class docutils literal notranslate"><span class="pre">Term</span></code></a><a class="headerlink" href="#term" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="nipy.algorithms.statistics.formula.formulae.Term">
<em class="property">class </em><code class="sig-prename descclassname">nipy.algorithms.statistics.formula.formulae.</code><code class="sig-name descname">Term</code><a class="reference internal" href="../../_modules/nipy/algorithms/statistics/formula/formulae.html#Term"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sympy.core.symbol.Symbol</span></code></p>
<p>A sympy.Symbol type to represent a term an a regression model</p>
<p>Terms can be added to other sympy expressions with the single
convention that a term plus itself returns itself.</p>
<p>It is meant to emulate something on the right hand side of a formula
in R. In particular, its name can be the name of a field in a
recarray used to create a design matrix.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">Term</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mi">3</span><span class="p">,),(</span><span class="mi">4</span><span class="p">,),(</span><span class="mi">5</span><span class="p">,)],</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">([(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">formula</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">design</span><span class="p">(</span><span class="n">xval</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">descr</span><span class="p">)</span>
<span class="go">[(&#39;x&#39;, &#39;&lt;f8&#39;)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">design</span><span class="p">(</span><span class="n">xval</span><span class="p">,</span> <span class="n">return_float</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([ 3.,  4.,  5.])</span>
</pre></div>
</div>
<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">$self</em>, <em class="sig-param">/</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.formula">
<em class="property">property </em><code class="sig-name descname">formula</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.formula" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Formula with only terms=[self].</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.adjoint">
<code class="sig-name descname">adjoint</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.adjoint" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.apart">
<code class="sig-name descname">apart</code><span class="sig-paren">(</span><em class="sig-param">x=None</em>, <em class="sig-param">**args</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.apart" title="Permalink to this definition">¶</a></dt>
<dd><p>See the apart function in sympy.polys</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.args">
<em class="property">property </em><code class="sig-name descname">args</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.args" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a tuple of arguments of ‘self’.</p>
<p class="rubric">Notes</p>
<p>Never use self._args, always use self.args.
Only use _args in __new__ when creating a new function.
Don’t override .args() from Basic (so that it’s easy to
change the interface in the future if needed).</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">cot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">args</span>
<span class="go">(x,)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">x</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">args</span>
<span class="go">(x, y)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">y</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.args_cnc">
<code class="sig-name descname">args_cnc</code><span class="sig-paren">(</span><em class="sig-param">cset=False</em>, <em class="sig-param">warn=True</em>, <em class="sig-param">split_1=True</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.args_cnc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return [commutative factors, non-commutative factors] of self.</p>
<p>self is treated as a Mul and the ordering of the factors is maintained.
If <code class="docutils literal notranslate"><span class="pre">cset</span></code> is True the commutative factors will be returned in a set.
If there were repeated factors (as may happen with an unevaluated Mul)
then an error will be raised unless it is explicitly suppressed by
setting <code class="docutils literal notranslate"><span class="pre">warn</span></code> to False.</p>
<p>Note: -1 is always separated from a Number unless split_1 is False.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">oo</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;A B&#39;</span><span class="p">,</span> <span class="n">commutative</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x y&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">()</span>
<span class="go">[[-1, 2, x, y], []]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">-</span><span class="mf">2.5</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">()</span>
<span class="go">[[-1, 2.5, x], []]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">A</span><span class="o">*</span><span class="n">B</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">()</span>
<span class="go">[[-1, 2, x, y], [A, B]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">A</span><span class="o">*</span><span class="n">B</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">(</span><span class="n">split_1</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[[-2, x, y], [A, B]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">(</span><span class="n">cset</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[{-1, 2, x, y}, []]</span>
</pre></div>
</div>
<p>The arg is always treated as a Mul:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">()</span>
<span class="go">[[], [x - 2 + A]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">-</span><span class="n">oo</span><span class="p">)</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">()</span> <span class="c1"># -oo is a singleton</span>
<span class="go">[[-1, oo], []]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.as_base_exp">
<code class="sig-name descname">as_base_exp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.as_base_exp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.as_coeff_Add">
<code class="sig-name descname">as_coeff_Add</code><span class="sig-paren">(</span><em class="sig-param">rational=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.as_coeff_Add" title="Permalink to this definition">¶</a></dt>
<dd><p>Efficiently extract the coefficient of a summation.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.as_coeff_Mul">
<code class="sig-name descname">as_coeff_Mul</code><span class="sig-paren">(</span><em class="sig-param">rational=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.as_coeff_Mul" title="Permalink to this definition">¶</a></dt>
<dd><p>Efficiently extract the coefficient of a product.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.as_coeff_add">
<code class="sig-name descname">as_coeff_add</code><span class="sig-paren">(</span><em class="sig-param">*deps</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.as_coeff_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the tuple (c, args) where self is written as an Add, <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
<p>c should be a Rational added to any terms of the Add that are
independent of deps.</p>
<p>args should be a tuple of all other terms of <code class="docutils literal notranslate"><span class="pre">a</span></code>; args is empty
if self is a Number or if self is independent of deps (when given).</p>
<p>This should be used when you don’t know if self is an Add or not but
you want to treat self as an Add or if you want to process the
individual arguments of the tail of self as an Add.</p>
<ul class="simple">
<li><p>if you know self is an Add and want only the head, use self.args[0];</p></li>
<li><p>if you don’t want to process the arguments of the tail but need the
tail then use self.as_two_terms() which gives the head and tail.</p></li>
<li><p>if you want to split self into an independent and dependent parts
use <code class="docutils literal notranslate"><span class="pre">self.as_independent(*deps)</span></code></p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">S</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">as_coeff_add</span><span class="p">()</span>
<span class="go">(3, ())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">as_coeff_add</span><span class="p">()</span>
<span class="go">(3, (x,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">as_coeff_add</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">(y + 3, (x,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">as_coeff_add</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">(y + 3, ())</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.as_coeff_exponent">
<code class="sig-name descname">as_coeff_exponent</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.as_coeff_exponent" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">c*x**e</span> <span class="pre">-&gt;</span> <span class="pre">c,e</span></code> where x can be any symbolic expression.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.as_coeff_mul">
<code class="sig-name descname">as_coeff_mul</code><span class="sig-paren">(</span><em class="sig-param">*deps</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.as_coeff_mul" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the tuple (c, args) where self is written as a Mul, <code class="docutils literal notranslate"><span class="pre">m</span></code>.</p>
<p>c should be a Rational multiplied by any factors of the Mul that are
independent of deps.</p>
<p>args should be a tuple of all other factors of m; args is empty
if self is a Number or if self is independent of deps (when given).</p>
<p>This should be used when you don’t know if self is a Mul or not but
you want to treat self as a Mul or if you want to process the
individual arguments of the tail of self as a Mul.</p>
<ul class="simple">
<li><p>if you know self is a Mul and want only the head, use self.args[0];</p></li>
<li><p>if you don’t want to process the arguments of the tail but need the
tail then use self.as_two_terms() which gives the head and tail;</p></li>
<li><p>if you want to split self into an independent and dependent parts
use <code class="docutils literal notranslate"><span class="pre">self.as_independent(*deps)</span></code></p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">S</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">as_coeff_mul</span><span class="p">()</span>
<span class="go">(3, ())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">as_coeff_mul</span><span class="p">()</span>
<span class="go">(3, (x, y))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">as_coeff_mul</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">(3*y, (x,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">as_coeff_mul</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">(3*y, ())</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.as_coefficient">
<code class="sig-name descname">as_coefficient</code><span class="sig-paren">(</span><em class="sig-param">expr</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.as_coefficient" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts symbolic coefficient at the given expression. In
other words, this functions separates ‘self’ into the product
of ‘expr’ and ‘expr’-free coefficient. If such separation
is not possible it will return None.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Term.coeff" title="nipy.algorithms.statistics.formula.formulae.Term.coeff"><code class="xref py py-obj docutils literal notranslate"><span class="pre">coeff</span></code></a></dt><dd><p>return sum of terms have a given factor</p>
</dd>
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Term.as_coeff_Add" title="nipy.algorithms.statistics.formula.formulae.Term.as_coeff_Add"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_coeff_Add</span></code></a></dt><dd><p>separate the additive constant from an expression</p>
</dd>
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Term.as_coeff_Mul" title="nipy.algorithms.statistics.formula.formulae.Term.as_coeff_Mul"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_coeff_Mul</span></code></a></dt><dd><p>separate the multiplicative constant from an expression</p>
</dd>
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Term.as_independent" title="nipy.algorithms.statistics.formula.formulae.Term.as_independent"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_independent</span></code></a></dt><dd><p>separate x-dependent terms/factors from others</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.polys.polytools.coeff_monomial</span></code></dt><dd><p>efficiently find the single coefficient of a monomial in Poly</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.polys.polytools.nth</span></code></dt><dd><p>like coeff_monomial but powers of monomial terms are used</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">E</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">Poly</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">E</span><span class="o">.</span><span class="n">as_coefficient</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">E</span><span class="p">)</span><span class="o">.</span><span class="n">as_coefficient</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">E</span><span class="p">)</span><span class="o">*</span><span class="n">E</span><span class="p">)</span><span class="o">.</span><span class="n">as_coefficient</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
</pre></div>
</div>
<p>Two terms have E in them so a sum is returned. (If one were
desiring the coefficient of the term exactly matching E then
the constant from the returned expression could be selected.
Or, for greater precision, a method of Poly can be used to
indicate the desired term from which the coefficient is
desired.)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">E</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">E</span><span class="p">)</span><span class="o">.</span><span class="n">as_coefficient</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="go">x + 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># just want the exact match</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">E</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">E</span><span class="p">);</span> <span class="n">p</span>
<span class="go">Poly(x*E + 2*E, x, E, domain=&#39;ZZ&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">coeff_monomial</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">nth</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>Since the following cannot be written as a product containing
E as a factor, None is returned. (If the coefficient <code class="docutils literal notranslate"><span class="pre">2*x</span></code> is
desired then the <code class="docutils literal notranslate"><span class="pre">coeff</span></code> method should be used.)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">E</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">as_coefficient</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">E</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="go">2*x</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">E</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">as_coefficient</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">as_coefficient</span><span class="p">(</span><span class="n">pi</span><span class="o">*</span><span class="n">I</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">as_coefficient</span><span class="p">(</span><span class="n">pi</span><span class="o">*</span><span class="n">I</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.as_coefficients_dict">
<code class="sig-name descname">as_coefficients_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.as_coefficients_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dictionary mapping terms to their Rational coefficient.
Since the dictionary is a defaultdict, inquiries about terms which
were not present will return a coefficient of 0. If an expression is
not an Add it is considered to have a single term.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">as_coefficients_dict</span><span class="p">()</span>
<span class="go">{1: 4, x: 3, a*x: 1}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">as_coefficients_dict</span><span class="p">()</span>
<span class="go">{a*x: 3}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.as_content_primitive">
<code class="sig-name descname">as_content_primitive</code><span class="sig-paren">(</span><em class="sig-param">radical=False</em>, <em class="sig-param">clear=True</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.as_content_primitive" title="Permalink to this definition">¶</a></dt>
<dd><p>This method should recursively remove a Rational from all arguments
and return that (content) and the new self (primitive). The content
should always be positive and <code class="docutils literal notranslate"><span class="pre">Mul(*foo.as_content_primitive())</span> <span class="pre">==</span> <span class="pre">foo</span></code>.
The primitive need not be in canonical form and should try to preserve
the underlying structure if possible (i.e. expand_mul should not be
applied to self).</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">sqrt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>The as_content_primitive function is recursive and retains structure:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span><span class="o">.</span><span class="n">as_content_primitive</span><span class="p">()</span>
<span class="go">(2, x + 3*y*(y + 1) + 1)</span>
</pre></div>
</div>
<p>Integer powers will have Rationals extracted from the base:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">6</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">as_content_primitive</span><span class="p">()</span>
<span class="go">(4, (3*x + 1)**2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">6</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">as_content_primitive</span><span class="p">()</span>
<span class="go">(1, (2*(3*x + 1))**(2*y))</span>
</pre></div>
</div>
<p>Terms may end up joining once their as_content_primitives are added:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="mi">5</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="p">))</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">y</span><span class="p">)))</span><span class="o">.</span><span class="n">as_content_primitive</span><span class="p">()</span>
<span class="go">(11, x*(y + 1))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="p">))</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">y</span><span class="p">)))</span><span class="o">.</span><span class="n">as_content_primitive</span><span class="p">()</span>
<span class="go">(9, x*(y + 1))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">z</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="p">))</span> <span class="o">+</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">y</span><span class="p">)))</span><span class="o">.</span><span class="n">as_content_primitive</span><span class="p">()</span>
<span class="go">(1, 6.0*x*(y + 1) + 3*z*(y + 1))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="mi">5</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="p">))</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">y</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">as_content_primitive</span><span class="p">()</span>
<span class="go">(121, x**2*(y + 1)**2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="mi">5</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="p">))</span> <span class="o">+</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">y</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">as_content_primitive</span><span class="p">()</span>
<span class="go">(1, 121.0*x**2*(y + 1)**2)</span>
</pre></div>
</div>
<p>Radical content can also be factored out of the primitive:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span><span class="o">.</span><span class="n">as_content_primitive</span><span class="p">(</span><span class="n">radical</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(2, sqrt(2)*(1 + 2*sqrt(5)))</span>
</pre></div>
</div>
<p>If clear=False (default is True) then content will not be removed
from an Add if it can be distributed to leave one or more
terms with integer coefficients.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">as_content_primitive</span><span class="p">()</span>
<span class="go">(1/2, x + 2*y)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">as_content_primitive</span><span class="p">(</span><span class="n">clear</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">(1, x/2 + y)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.as_dummy">
<code class="sig-name descname">as_dummy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.as_dummy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the expression with any objects having structurally
bound symbols replaced with unique, canonical symbols within
the object in which they appear and having only the default
assumption for commutativity being True.</p>
<p class="rubric">Notes</p>
<p>Any object that has structural dummy variables should have
a property, <cite>bound_symbols</cite> that returns a list of structural
dummy symbols of the object itself.</p>
<p>Lambda and Subs have bound symbols, but because of how they
are cached, they already compare the same regardless of their
bound symbols:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Lambda</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Lambda</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">Lambda</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Integral</span><span class="p">,</span> <span class="n">Symbol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Integral</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">as_dummy</span><span class="p">()</span>
<span class="go">Integral(_0, (_0, x))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_real</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.as_expr">
<code class="sig-name descname">as_expr</code><span class="sig-paren">(</span><em class="sig-param">*gens</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.as_expr" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a polynomial to a SymPy expression.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">sin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">as_poly</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">as_expr</span><span class="p">()</span>
<span class="go">x**2 + x*y</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">as_expr</span><span class="p">()</span>
<span class="go">sin(x)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.as_independent">
<code class="sig-name descname">as_independent</code><span class="sig-paren">(</span><em class="sig-param">*deps</em>, <em class="sig-param">**hint</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.as_independent" title="Permalink to this definition">¶</a></dt>
<dd><p>A mostly naive separation of a Mul or Add into arguments that are not
are dependent on deps. To obtain as complete a separation of variables
as possible, use a separation method first, e.g.:</p>
<ul class="simple">
<li><p>separatevars() to change Mul, Add and Pow (including exp) into Mul</p></li>
<li><p>.expand(mul=True) to change Add or Mul into Add</p></li>
<li><p>.expand(log=True) to change log expr into an Add</p></li>
</ul>
<p>The only non-naive thing that is done here is to respect noncommutative
ordering of variables and to always return (0, 0) for <cite>self</cite> of zero
regardless of hints.</p>
<p>For nonzero <cite>self</cite>, the returned tuple (i, d) has the
following interpretation:</p>
<ul class="simple">
<li><p>i will has no variable that appears in deps</p></li>
<li><p>d will either have terms that contain variables that are in deps, or
be equal to 0 (when self is an Add) or 1 (when self is a Mul)</p></li>
<li><p>if self is an Add then self = i + d</p></li>
<li><p>if self is a Mul then self = i*d</p></li>
<li><p>otherwise (self, S.One) or (S.One, self) is returned.</p></li>
</ul>
<p>To force the expression to be treated as an Add, use the hint as_Add=True</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">separatevars</span></code>, <a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Term.expand" title="nipy.algorithms.statistics.formula.formulae.Term.expand"><code class="xref py py-obj docutils literal notranslate"><span class="pre">expand</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">Add.as_two_terms</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">Mul.as_two_terms</span></code>, <a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Term.as_coeff_add" title="nipy.algorithms.statistics.formula.formulae.Term.as_coeff_add"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_coeff_add</span></code></a>, <a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Term.as_coeff_mul" title="nipy.algorithms.statistics.formula.formulae.Term.as_coeff_mul"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_coeff_mul</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<p>– self is an Add</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">exp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">(0, x*y + x)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">(x, x*y)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">(y + z, 2*x*sin(x) + x)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">(z, 2*x*sin(x) + x + y)</span>
</pre></div>
</div>
<p>– self is a Mul</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">(cos(y), x*sin(x))</span>
</pre></div>
</div>
<p>non-commutative terms cannot always be separated out when self is a Mul</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">n3</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;n1 n2 n3&#39;</span><span class="p">,</span> <span class="n">commutative</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">n1</span> <span class="o">+</span> <span class="n">n1</span><span class="o">*</span><span class="n">n2</span><span class="p">)</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">n2</span><span class="p">)</span>
<span class="go">(n1, n1*n2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">n2</span><span class="o">*</span><span class="n">n1</span> <span class="o">+</span> <span class="n">n1</span><span class="o">*</span><span class="n">n2</span><span class="p">)</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">n2</span><span class="p">)</span>
<span class="go">(0, n1*n2 + n2*n1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">n1</span><span class="o">*</span><span class="n">n2</span><span class="o">*</span><span class="n">n3</span><span class="p">)</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">n1</span><span class="p">)</span>
<span class="go">(1, n1*n2*n3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">n1</span><span class="o">*</span><span class="n">n2</span><span class="o">*</span><span class="n">n3</span><span class="p">)</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">n2</span><span class="p">)</span>
<span class="go">(n1, n2*n3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">n1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">(1, (x - y)*(x - n1))</span>
</pre></div>
</div>
<p>– self is anything else:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">(1, sin(x))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">(sin(x), 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">(1, exp(x + y))</span>
</pre></div>
</div>
<p>– force self to be treated as an Add:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">as_Add</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(0, 3*x)</span>
</pre></div>
</div>
<p>– force self to be treated as a Mul:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span><span class="o">+</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">as_Add</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">(1, x + 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="o">+</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">as_Add</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">(1, x - 3)</span>
</pre></div>
</div>
<p>Note how the below differs from the above in making the
constant on the dep term positive.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">y</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="o">+</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">(y, x - 3)</span>
</pre></div>
</div>
<dl class="simple">
<dt>– use .as_independent() for true independence testing instead</dt><dd><p>of .has(). The former considers only symbols in the free
symbols while the latter considers all symbols</p>
</dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Integral</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span> <span class="o">=</span> <span class="n">Integral</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="ow">in</span> <span class="n">I</span><span class="o">.</span><span class="n">free_symbols</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">I</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Note: when trying to get independent terms, a separation method
might need to be used first. In this case, it is important to keep
track of what you send to this routine so you know how to interpret
the returned values</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">separatevars</span><span class="p">,</span> <span class="n">log</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">separatevars</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">(exp(y), exp(x))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">(x, x*y)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">separatevars</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">(x, y + 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">(x, y + 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">mul</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">(x, x*y)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;a b&#39;</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">(log(a), log(b))</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.as_leading_term">
<code class="sig-name descname">as_leading_term</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.as_leading_term" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the leading (nonzero) term of the series expansion of self.</p>
<p>The _eval_as_leading_term routines are used to do this, and they must
always return a non-zero value.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">as_leading_term</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">as_leading_term</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">x**(-2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.as_numer_denom">
<code class="sig-name descname">as_numer_denom</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.as_numer_denom" title="Permalink to this definition">¶</a></dt>
<dd><p>expression -&gt; a/b -&gt; a, b</p>
<p>This is just a stub that should be defined by
an object’s class methods to get anything else.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Term.normal" title="nipy.algorithms.statistics.formula.formulae.Term.normal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">normal</span></code></a></dt><dd><p>return a/b instead of a, b</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.as_ordered_factors">
<code class="sig-name descname">as_ordered_factors</code><span class="sig-paren">(</span><em class="sig-param">order=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.as_ordered_factors" title="Permalink to this definition">¶</a></dt>
<dd><p>Return list of ordered factors (if Mul) else [self].</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.as_ordered_terms">
<code class="sig-name descname">as_ordered_terms</code><span class="sig-paren">(</span><em class="sig-param">order=None</em>, <em class="sig-param">data=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.as_ordered_terms" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform an expression to an ordered list of terms.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">as_ordered_terms</span><span class="p">()</span>
<span class="go">[sin(x)**2*cos(x), sin(x)**2, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.as_poly">
<code class="sig-name descname">as_poly</code><span class="sig-paren">(</span><em class="sig-param">*gens</em>, <em class="sig-param">**args</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.as_poly" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts <code class="docutils literal notranslate"><span class="pre">self</span></code> to a polynomial or returns <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">sin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">((</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">as_poly</span><span class="p">())</span>
<span class="go">Poly(x**2 + x*y, x, y, domain=&#39;ZZ&#39;)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">((</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">as_poly</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
<span class="go">Poly(x**2 + x*y, x, y, domain=&#39;ZZ&#39;)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">((</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">as_poly</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
<span class="go">None</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.as_powers_dict">
<code class="sig-name descname">as_powers_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.as_powers_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self as a dictionary of factors with each factor being
treated as a power. The keys are the bases of the factors and the
values, the corresponding exponents. The resulting dictionary should
be used with caution if the expression is a Mul and contains non-
commutative factors since the order that they appeared will be lost in
the dictionary.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Term.as_ordered_factors" title="nipy.algorithms.statistics.formula.formulae.Term.as_ordered_factors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_ordered_factors</span></code></a></dt><dd><p>An alternative for noncommutative applications, returning an ordered list of factors.</p>
</dd>
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Term.args_cnc" title="nipy.algorithms.statistics.formula.formulae.Term.args_cnc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">args_cnc</span></code></a></dt><dd><p>Similar to as_ordered_factors, but guarantees separation of commutative and noncommutative factors.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.as_real_imag">
<code class="sig-name descname">as_real_imag</code><span class="sig-paren">(</span><em class="sig-param">deep=True</em>, <em class="sig-param">**hints</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.as_real_imag" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs complex expansion on ‘self’ and returns a tuple
containing collected both real and imaginary parts. This
method can’t be confused with re() and im() functions,
which does not perform complex expansion at evaluation.</p>
<p>However it is possible to expand both re() and im()
functions and get exactly the same results as with
a single call to this function.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">I</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x,y&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">as_real_imag</span><span class="p">()</span>
<span class="go">(x, y)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">z</span><span class="p">,</span> <span class="n">w</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">z</span> <span class="o">+</span> <span class="n">w</span><span class="o">*</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">as_real_imag</span><span class="p">()</span>
<span class="go">(re(z) - im(w), re(w) + im(z))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.as_set">
<code class="sig-name descname">as_set</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.as_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Rewrites Boolean expression in terms of real sets.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">Or</span><span class="p">,</span> <span class="n">And</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Eq</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">as_set</span><span class="p">()</span>
<span class="go">{0}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">as_set</span><span class="p">()</span>
<span class="go">Interval.open(0, oo)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">And</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">as_set</span><span class="p">()</span>
<span class="go">Interval.open(-2, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Or</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">as_set</span><span class="p">()</span>
<span class="go">Union(Interval.open(-oo, -2), Interval.open(2, oo))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.as_terms">
<code class="sig-name descname">as_terms</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.as_terms" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform an expression to a list of terms.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.assumptions0">
<em class="property">property </em><code class="sig-name descname">assumptions0</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.assumptions0" title="Permalink to this definition">¶</a></dt>
<dd><p>Return object <cite>type</cite> assumptions.</p>
<p>For example:</p>
<blockquote>
<div><p>Symbol(‘x’, real=True)
Symbol(‘x’, integer=True)</p>
</div></blockquote>
<p>are different objects. In other words, besides Python type (Symbol in
this case), the initial assumptions are also forming their typeinfo.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Symbol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">assumptions0</span>
<span class="go">{&#39;commutative&#39;: True}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">assumptions0</span>
<span class="go">{&#39;commutative&#39;: True, &#39;complex&#39;: True, &#39;hermitian&#39;: True,</span>
<span class="go">&#39;imaginary&#39;: False, &#39;negative&#39;: False, &#39;nonnegative&#39;: True,</span>
<span class="go">&#39;nonpositive&#39;: False, &#39;nonzero&#39;: True, &#39;positive&#39;: True, &#39;real&#39;: True,</span>
<span class="go">&#39;zero&#39;: False}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.atoms">
<code class="sig-name descname">atoms</code><span class="sig-paren">(</span><em class="sig-param">*types</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.atoms" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the atoms that form the current object.</p>
<p>By default, only objects that are truly atomic and can’t
be divided into smaller pieces are returned: symbols, numbers,
and number symbols like I and pi. It is possible to request
atoms of any type, however, as demonstrated below.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">I</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">sin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">()</span>
<span class="go">{1, 2, I, pi, x, y}</span>
</pre></div>
</div>
<p>If one or more types are given, the results will contain only
those types of atoms.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Number</span><span class="p">,</span> <span class="n">NumberSymbol</span><span class="p">,</span> <span class="n">Symbol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Symbol</span><span class="p">)</span>
<span class="go">{x, y}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Number</span><span class="p">)</span>
<span class="go">{1, 2}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Number</span><span class="p">,</span> <span class="n">NumberSymbol</span><span class="p">)</span>
<span class="go">{1, 2, pi}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Number</span><span class="p">,</span> <span class="n">NumberSymbol</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
<span class="go">{1, 2, I, pi}</span>
</pre></div>
</div>
<p>Note that I (imaginary unit) and zoo (complex infinity) are special
types of number symbols and are not part of the NumberSymbol class.</p>
<p>The type can be given implicitly, too:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c1"># x is a Symbol</span>
<span class="go">{x, y}</span>
</pre></div>
</div>
<p>Be careful to check your assumptions when using the implicit option
since <code class="docutils literal notranslate"><span class="pre">S(1).is_Integer</span> <span class="pre">=</span> <span class="pre">True</span></code> but <code class="docutils literal notranslate"><span class="pre">type(S(1))</span></code> is <code class="docutils literal notranslate"><span class="pre">One</span></code>, a special type
of sympy atom, while <code class="docutils literal notranslate"><span class="pre">type(S(2))</span></code> is type <code class="docutils literal notranslate"><span class="pre">Integer</span></code> and will find all
integers in an expression:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">S</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">{1}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">{1, 2}</span>
</pre></div>
</div>
<p>Finally, arguments to atoms() can select more than atomic atoms: any
sympy type (loaded in core/__init__.py) can be listed as an argument
and those types of “atoms” as found in scanning the arguments of the
expression recursively:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Mul</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.core.function</span> <span class="k">import</span> <span class="n">AppliedUndef</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Function</span><span class="p">)</span>
<span class="go">{f(x), sin(y + I*pi)}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">AppliedUndef</span><span class="p">)</span>
<span class="go">{f(x)}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Mul</span><span class="p">)</span>
<span class="go">{I*pi, 2*sin(y + I*pi)}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.binary_symbols">
<em class="property">property </em><code class="sig-name descname">binary_symbols</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.binary_symbols" title="Permalink to this definition">¶</a></dt>
<dd><p>Return from the atoms of self those which are free symbols.</p>
<p>For most expressions, all symbols are free symbols. For some classes
this is not true. e.g. Integrals use Symbols for the dummy variables
which are bound variables, so Integral has a method to return all
symbols except those. Derivative keeps track of symbols with respect
to which it will perform a derivative; those are
bound variables, too, so it has its own free_symbols method.</p>
<p>Any other method that uses bound variables should implement a
free_symbols method.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.cancel">
<code class="sig-name descname">cancel</code><span class="sig-paren">(</span><em class="sig-param">*gens</em>, <em class="sig-param">**args</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.cancel" title="Permalink to this definition">¶</a></dt>
<dd><p>See the cancel function in sympy.polys</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.canonical_variables">
<em class="property">property </em><code class="sig-name descname">canonical_variables</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.canonical_variables" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dictionary mapping any variable defined in
<code class="docutils literal notranslate"><span class="pre">self.bound_symbols</span></code> to Symbols that do not clash
with any existing symbol in the expression.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Lambda</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Lambda</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">canonical_variables</span>
<span class="go">{x: _0}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.class_key">
<em class="property">classmethod </em><code class="sig-name descname">class_key</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.class_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Nice order of classes.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.coeff">
<code class="sig-name descname">coeff</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">n=1</em>, <em class="sig-param">right=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.coeff" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the coefficient from the term(s) containing <code class="docutils literal notranslate"><span class="pre">x**n</span></code>. If <code class="docutils literal notranslate"><span class="pre">n</span></code>
is zero then all terms independent of <code class="docutils literal notranslate"><span class="pre">x</span></code> will be returned.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">x</span></code> is noncommutative, the coefficient to the left (default) or
right of <code class="docutils literal notranslate"><span class="pre">x</span></code> can be returned. The keyword ‘right’ is ignored when
<code class="docutils literal notranslate"><span class="pre">x</span></code> is commutative.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Term.as_coefficient" title="nipy.algorithms.statistics.formula.formulae.Term.as_coefficient"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_coefficient</span></code></a></dt><dd><p>separate the expression into a coefficient and factor</p>
</dd>
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Term.as_coeff_Add" title="nipy.algorithms.statistics.formula.formulae.Term.as_coeff_Add"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_coeff_Add</span></code></a></dt><dd><p>separate the additive constant from an expression</p>
</dd>
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Term.as_coeff_Mul" title="nipy.algorithms.statistics.formula.formulae.Term.as_coeff_Mul"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_coeff_Mul</span></code></a></dt><dd><p>separate the multiplicative constant from an expression</p>
</dd>
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Term.as_independent" title="nipy.algorithms.statistics.formula.formulae.Term.as_independent"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_independent</span></code></a></dt><dd><p>separate x-dependent terms/factors from others</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.polys.polytools.coeff_monomial</span></code></dt><dd><p>efficiently find the single coefficient of a monomial in Poly</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.polys.polytools.nth</span></code></dt><dd><p>like coeff_monomial but powers of monomial terms are used</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
</pre></div>
</div>
<p>You can select terms that have an explicit negative in front of them:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">-</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">2*y</span>
</pre></div>
</div>
<p>You can select terms with no Rational coefficient:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<p>You can select terms independent of x by making n=0; in this case
expr.as_independent(x)[0] is returned (and 0 will be returned instead
of None):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span>
<span class="go">x**3 + 3*x**2 + 3*x + 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">eq</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))]</span>
<span class="go">[1, 3, 3, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">-=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">eq</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))]</span>
<span class="go">[1, 3, 3, 0]</span>
</pre></div>
</div>
<p>You can select terms that have a numerical term in front of them:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">-</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">-y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">sqrt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">x</span>
</pre></div>
</div>
<p>The matching is exact:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">z</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="go">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">z</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<p>In addition, no factoring is done, so 1 + z*(1 + y) is not obtained
from the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">z</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
<p>If such factoring is desired, factor_terms can be used first:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">factor_terms</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factor_terms</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">z</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">z*(y + 1) + 1</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">o</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;n m o&#39;</span><span class="p">,</span> <span class="n">commutative</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">m</span> <span class="o">+</span> <span class="n">m</span><span class="o">*</span><span class="n">n</span><span class="o">*</span><span class="n">m</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="c1"># = (1 + m)*n*m</span>
<span class="go">1 + m</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">m</span> <span class="o">+</span> <span class="n">m</span><span class="o">*</span><span class="n">n</span><span class="o">*</span><span class="n">m</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># = (1 + m)*n*m</span>
<span class="go">m</span>
</pre></div>
</div>
<p>If there is more than one possible coefficient 0 is returned:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">m</span> <span class="o">+</span> <span class="n">m</span><span class="o">*</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<p>If there is only one possible coefficient, it is returned:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">m</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">m</span><span class="o">*</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">m</span><span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="go">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">m</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">m</span><span class="o">*</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">m</span><span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.collect">
<code class="sig-name descname">collect</code><span class="sig-paren">(</span><em class="sig-param">syms</em>, <em class="sig-param">func=None</em>, <em class="sig-param">evaluate=True</em>, <em class="sig-param">exact=False</em>, <em class="sig-param">distribute_order_term=True</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.collect" title="Permalink to this definition">¶</a></dt>
<dd><p>See the collect function in sympy.simplify</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.combsimp">
<code class="sig-name descname">combsimp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.combsimp" title="Permalink to this definition">¶</a></dt>
<dd><p>See the combsimp function in sympy.simplify</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.compare">
<code class="sig-name descname">compare</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.compare" title="Permalink to this definition">¶</a></dt>
<dd><p>Return -1, 0, 1 if the object is smaller, equal, or greater than other.</p>
<p>Not in the mathematical sense. If the object is of a different type
from the “other” then their classes are ordered according to
the sorted_classes list.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">-1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.compute_leading_term">
<code class="sig-name descname">compute_leading_term</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">logx=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.compute_leading_term" title="Permalink to this definition">¶</a></dt>
<dd><p>as_leading_term is only allowed for results of .series()
This is a wrapper to compute a series first.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.conjugate">
<code class="sig-name descname">conjugate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.conjugate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.could_extract_minus_sign">
<code class="sig-name descname">could_extract_minus_sign</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.could_extract_minus_sign" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if self is not in a canonical form with respect
to its sign.</p>
<p>For most expressions, e, there will be a difference in e and -e.
When there is, True will be returned for one and False for the
other; False will be returned if there is no difference.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">{</span><span class="n">i</span><span class="o">.</span><span class="n">could_extract_minus_sign</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="o">-</span><span class="n">e</span><span class="p">)}</span>
<span class="go">{False, True}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.count">
<code class="sig-name descname">count</code><span class="sig-paren">(</span><em class="sig-param">query</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Count the number of matching subexpressions.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.count_ops">
<code class="sig-name descname">count_ops</code><span class="sig-paren">(</span><em class="sig-param">visual=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.count_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper for count_ops that returns the operation count.</p>
</dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.default_assumptions">
<code class="sig-name descname">default_assumptions</code><em class="property"> = {}</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.default_assumptions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.diff">
<code class="sig-name descname">diff</code><span class="sig-paren">(</span><em class="sig-param">*symbols</em>, <em class="sig-param">**assumptions</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.diff" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.doit">
<code class="sig-name descname">doit</code><span class="sig-paren">(</span><em class="sig-param">**hints</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.doit" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate objects that are not evaluated by default like limits,
integrals, sums and products. All objects of this kind will be
evaluated recursively, unless some species were excluded via ‘hints’
or unless the ‘deep’ hint was set to ‘False’.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Integral</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">2</span><span class="o">*</span><span class="n">Integral</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">2*Integral(x, x)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Integral</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">doit</span><span class="p">()</span>
<span class="go">x**2</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Integral</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">doit</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">2*Integral(x, x)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.dummy_eq">
<code class="sig-name descname">dummy_eq</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">symbol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.dummy_eq" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two expressions and handle dummy symbols.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Dummy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s1">&#39;u&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">dummy_eq</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">dummy_eq</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">dummy_eq</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.equals">
<code class="sig-name descname">equals</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">failing_expression=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.equals" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if self == other, False if it doesn’t, or None. If
failing_expression is True then the expression which did not simplify
to a 0 will be returned instead of None.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">self</span></code> is a Number (or complex number) that is not zero, then
the result is False.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">self</span></code> is a number and has not evaluated to zero, evalf will be
used to test whether the expression evaluates to zero. If it does so
and the result has significance (i.e. the precision is either -1, for
a Rational result, or is greater than 1) then the evalf value will be
used to return True or False.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.evalf">
<code class="sig-name descname">evalf</code><span class="sig-paren">(</span><em class="sig-param">n=15</em>, <em class="sig-param">subs=None</em>, <em class="sig-param">maxn=100</em>, <em class="sig-param">chop=False</em>, <em class="sig-param">strict=False</em>, <em class="sig-param">quad=None</em>, <em class="sig-param">verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.evalf" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the given formula to an accuracy of n digits.
Optional keyword arguments:</p>
<blockquote>
<div><dl class="simple">
<dt>subs=&lt;dict&gt;</dt><dd><p>Substitute numerical values for symbols, e.g.
subs={x:3, y:1+pi}. The substitutions must be given as a
dictionary.</p>
</dd>
<dt>maxn=&lt;integer&gt;</dt><dd><p>Allow a maximum temporary working precision of maxn digits
(default=100)</p>
</dd>
<dt>chop=&lt;bool&gt;</dt><dd><p>Replace tiny real or imaginary parts in subresults
by exact zeros (default=False)</p>
</dd>
<dt>strict=&lt;bool&gt;</dt><dd><p>Raise PrecisionExhausted if any subresult fails to evaluate
to full accuracy, given the available maxprec
(default=False)</p>
</dd>
<dt>quad=&lt;str&gt;</dt><dd><p>Choose algorithm for numerical quadrature. By default,
tanh-sinh quadrature is used. For oscillatory
integrals on an infinite interval, try quad=’osc’.</p>
</dd>
<dt>verbose=&lt;bool&gt;</dt><dd><p>Print debug information (default=False)</p>
</dd>
</dl>
</div></blockquote>
<p class="rubric">Notes</p>
<p>When Floats are naively substituted into an expression, precision errors
may adversely affect the result. For example, adding 1e16 (a Float) to 1
will truncate to 1e16; if 1e16 is then subtracted, the result will be 0.
That is exactly what happens in the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="mf">1e16</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="mf">1e16</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">-</span> <span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<p>Using the subs argument for evalf is the accurate way to evaluate such an
expression:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">-</span> <span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="n">subs</span><span class="o">=</span><span class="n">values</span><span class="p">)</span>
<span class="go">1.00000000000000</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.expand">
<code class="sig-name descname">expand</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.expand" title="Permalink to this definition">¶</a></dt>
<dd><p>Expand an expression using hints.</p>
<p>See the docstring of the expand() function in sympy.core.function for
more information.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.expr_free_symbols">
<em class="property">property </em><code class="sig-name descname">expr_free_symbols</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.expr_free_symbols" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <code class="docutils literal notranslate"><span class="pre">free_symbols</span></code>, but returns the free symbols only if they are contained in an expression node.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">expr_free_symbols</span>
<span class="go">{x, y}</span>
</pre></div>
</div>
<p>If the expression is contained in a non-expression object, don’t return
the free symbols. Compare:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Tuple</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">expr_free_symbols</span>
<span class="go">set()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">free_symbols</span>
<span class="go">{x, y}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.extract_additively">
<code class="sig-name descname">extract_additively</code><span class="sig-paren">(</span><em class="sig-param">c</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.extract_additively" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self - c if it’s possible to subtract c from self and
make all matching coefficients move towards zero, else return None.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Term.extract_multiplicatively" title="nipy.algorithms.statistics.formula.formulae.Term.extract_multiplicatively"><code class="xref py py-obj docutils literal notranslate"><span class="pre">extract_multiplicatively</span></code></a>, <a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Term.coeff" title="nipy.algorithms.statistics.formula.formulae.Term.coeff"><code class="xref py py-obj docutils literal notranslate"><span class="pre">coeff</span></code></a>, <a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Term.as_coefficient" title="nipy.algorithms.statistics.formula.formulae.Term.as_coefficient"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_coefficient</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">x + 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">y</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">(x + 1)*(x + 2*y) + 3</span>
</pre></div>
</div>
<p>Sometimes auto-expansion will return a less simplified result
than desired; gcd_terms might be used in such cases:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">gcd_terms</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">4*x*(y + 1) + x*(4*y + 3) - x*(4*y + 4) + y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gcd_terms</span><span class="p">(</span><span class="n">_</span><span class="p">)</span>
<span class="go">x*(4*y + 3) + y</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.extract_branch_factor">
<code class="sig-name descname">extract_branch_factor</code><span class="sig-paren">(</span><em class="sig-param">allow_half=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.extract_branch_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Try to write self as <code class="docutils literal notranslate"><span class="pre">exp_polar(2*pi*I*n)*z</span></code> in a nice way.
Return (z, n).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">exp_polar</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">pi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exp_polar</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span><span class="o">.</span><span class="n">extract_branch_factor</span><span class="p">()</span>
<span class="go">(exp_polar(I*pi), 0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exp_polar</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span><span class="o">.</span><span class="n">extract_branch_factor</span><span class="p">()</span>
<span class="go">(1, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exp_polar</span><span class="p">(</span><span class="o">-</span><span class="n">pi</span><span class="o">*</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">extract_branch_factor</span><span class="p">()</span>
<span class="go">(exp_polar(I*pi), -1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exp_polar</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">extract_branch_factor</span><span class="p">()</span>
<span class="go">(exp_polar(x + I*pi), 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">y</span><span class="o">*</span><span class="n">exp_polar</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">I</span><span class="p">)</span><span class="o">*</span><span class="n">exp_polar</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">extract_branch_factor</span><span class="p">()</span>
<span class="go">(y*exp_polar(2*pi*x), -1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exp_polar</span><span class="p">(</span><span class="o">-</span><span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">extract_branch_factor</span><span class="p">()</span>
<span class="go">(exp_polar(-I*pi/2), 0)</span>
</pre></div>
</div>
<p>If allow_half is True, also extract exp_polar(I*pi):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">exp_polar</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span><span class="o">.</span><span class="n">extract_branch_factor</span><span class="p">(</span><span class="n">allow_half</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(1, 1/2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exp_polar</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span><span class="o">.</span><span class="n">extract_branch_factor</span><span class="p">(</span><span class="n">allow_half</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(1, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exp_polar</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span><span class="o">.</span><span class="n">extract_branch_factor</span><span class="p">(</span><span class="n">allow_half</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(1, 3/2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exp_polar</span><span class="p">(</span><span class="o">-</span><span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span><span class="o">.</span><span class="n">extract_branch_factor</span><span class="p">(</span><span class="n">allow_half</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(1, -1/2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.extract_multiplicatively">
<code class="sig-name descname">extract_multiplicatively</code><span class="sig-paren">(</span><em class="sig-param">c</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.extract_multiplicatively" title="Permalink to this definition">¶</a></dt>
<dd><p>Return None if it’s not possible to make self in the form
c * something in a nice way, i.e. preserving the properties
of arguments of self.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">Rational</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x,y&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">extract_multiplicatively</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span>
<span class="go">x*y**2</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">extract_multiplicatively</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">4</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">extract_multiplicatively</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">x</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">extract_multiplicatively</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">extract_multiplicatively</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">x/6</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.factor">
<code class="sig-name descname">factor</code><span class="sig-paren">(</span><em class="sig-param">*gens</em>, <em class="sig-param">**args</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.factor" title="Permalink to this definition">¶</a></dt>
<dd><p>See the factor() function in sympy.polys.polytools</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.find">
<code class="sig-name descname">find</code><span class="sig-paren">(</span><em class="sig-param">query</em>, <em class="sig-param">group=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.find" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all subexpressions matching a query.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.fourier_series">
<code class="sig-name descname">fourier_series</code><span class="sig-paren">(</span><em class="sig-param">limits=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.fourier_series" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute fourier sine/cosine series of self.</p>
<p>See the docstring of the <a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Term.fourier_series" title="nipy.algorithms.statistics.formula.formulae.Term.fourier_series"><code class="xref py py-func docutils literal notranslate"><span class="pre">fourier_series()</span></code></a> in sympy.series.fourier
for more information.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.fps">
<code class="sig-name descname">fps</code><span class="sig-paren">(</span><em class="sig-param">x=None</em>, <em class="sig-param">x0=0</em>, <em class="sig-param">dir=1</em>, <em class="sig-param">hyper=True</em>, <em class="sig-param">order=4</em>, <em class="sig-param">rational=True</em>, <em class="sig-param">full=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.fps" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute formal power power series of self.</p>
<p>See the docstring of the <a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Term.fps" title="nipy.algorithms.statistics.formula.formulae.Term.fps"><code class="xref py py-func docutils literal notranslate"><span class="pre">fps()</span></code></a> function in sympy.series.formal for
more information.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.free_symbols">
<em class="property">property </em><code class="sig-name descname">free_symbols</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.free_symbols" title="Permalink to this definition">¶</a></dt>
<dd><p>Return from the atoms of self those which are free symbols.</p>
<p>For most expressions, all symbols are free symbols. For some classes
this is not true. e.g. Integrals use Symbols for the dummy variables
which are bound variables, so Integral has a method to return all
symbols except those. Derivative keeps track of symbols with respect
to which it will perform a derivative; those are
bound variables, too, so it has its own free_symbols method.</p>
<p>Any other method that uses bound variables should implement a
free_symbols method.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.fromiter">
<em class="property">classmethod </em><code class="sig-name descname">fromiter</code><span class="sig-paren">(</span><em class="sig-param">args</em>, <em class="sig-param">**assumptions</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.fromiter" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new object from an iterable.</p>
<p>This is a convenience function that allows one to create objects from
any iterable, without having to convert to a list or tuple first.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Tuple</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Tuple</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">(0, 1, 2, 3, 4)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.func">
<em class="property">property </em><code class="sig-name descname">func</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.func" title="Permalink to this definition">¶</a></dt>
<dd><p>The top-level function in an expression.</p>
<p>The following should hold for all objects:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;</span> <span class="n">x</span> <span class="o">==</span> <span class="n">x</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">func</span>
<span class="go">&lt;class &#39;sympy.core.mul.Mul&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">args</span>
<span class="go">(2, x)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
<span class="go">2*x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">==</span> <span class="n">a</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.gammasimp">
<code class="sig-name descname">gammasimp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.gammasimp" title="Permalink to this definition">¶</a></dt>
<dd><p>See the gammasimp function in sympy.simplify</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.getO">
<code class="sig-name descname">getO</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.getO" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the additive O(..) symbol if there is one, else None.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.getn">
<code class="sig-name descname">getn</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.getn" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the order of the expression.</p>
<p>The order is determined either from the O(…) term. If there
is no O(…) term, it returns None.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">O</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="n">O</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">getn</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">getn</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.has">
<code class="sig-name descname">has</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.has" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether any subexpression matches any of the patterns.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">sin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Note <code class="docutils literal notranslate"><span class="pre">has</span></code> is a structural algorithm with no knowledge of
mathematics. Consider the following half-open interval:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.sets</span> <span class="k">import</span> <span class="n">Interval</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">Interval</span><span class="o">.</span><span class="n">Lopen</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span> <span class="n">i</span>
<span class="go">Interval.Lopen(0, 5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">args</span>
<span class="go">(0, 5, True, False)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># there is no &quot;4&quot; in the arguments</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># there *is* a &quot;0&quot; in the arguments</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Instead, use <code class="docutils literal notranslate"><span class="pre">contains</span></code> to determine whether a number is in the
interval or not:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">expr.has(*patterns)</span></code> is exactly equivalent to
<code class="docutils literal notranslate"><span class="pre">any(expr.has(p)</span> <span class="pre">for</span> <span class="pre">p</span> <span class="pre">in</span> <span class="pre">patterns)</span></code>. In particular, <code class="docutils literal notranslate"><span class="pre">False</span></code> is
returned when the list of patterns is empty.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">has</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.integrate">
<code class="sig-name descname">integrate</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.integrate" title="Permalink to this definition">¶</a></dt>
<dd><p>See the integrate function in sympy.integrals</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.invert">
<code class="sig-name descname">invert</code><span class="sig-paren">(</span><em class="sig-param">g</em>, <em class="sig-param">*gens</em>, <em class="sig-param">**args</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.invert" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the multiplicative inverse of <code class="docutils literal notranslate"><span class="pre">self</span></code> mod <code class="docutils literal notranslate"><span class="pre">g</span></code>
where <code class="docutils literal notranslate"><span class="pre">self</span></code> (and <code class="docutils literal notranslate"><span class="pre">g</span></code>) may be symbolic expressions).</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.core.numbers.mod_inverse</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.polys.polytools.invert</span></code></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_Add">
<code class="sig-name descname">is_Add</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_Add" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_AlgebraicNumber">
<code class="sig-name descname">is_AlgebraicNumber</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_AlgebraicNumber" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_Atom">
<code class="sig-name descname">is_Atom</code><em class="property"> = True</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_Atom" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_Boolean">
<code class="sig-name descname">is_Boolean</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_Boolean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_Derivative">
<code class="sig-name descname">is_Derivative</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_Derivative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_Dummy">
<code class="sig-name descname">is_Dummy</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_Dummy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_Equality">
<code class="sig-name descname">is_Equality</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_Equality" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_Float">
<code class="sig-name descname">is_Float</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_Float" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_Function">
<code class="sig-name descname">is_Function</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_Function" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_Indexed">
<code class="sig-name descname">is_Indexed</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_Indexed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_Integer">
<code class="sig-name descname">is_Integer</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_Integer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_MatAdd">
<code class="sig-name descname">is_MatAdd</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_MatAdd" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_MatMul">
<code class="sig-name descname">is_MatMul</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_MatMul" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_Matrix">
<code class="sig-name descname">is_Matrix</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_Matrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_Mul">
<code class="sig-name descname">is_Mul</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_Mul" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_Not">
<code class="sig-name descname">is_Not</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_Not" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_Number">
<code class="sig-name descname">is_Number</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_Number" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_NumberSymbol">
<code class="sig-name descname">is_NumberSymbol</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_NumberSymbol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_Order">
<code class="sig-name descname">is_Order</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_Order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_Piecewise">
<code class="sig-name descname">is_Piecewise</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_Piecewise" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_Point">
<code class="sig-name descname">is_Point</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_Point" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_Poly">
<code class="sig-name descname">is_Poly</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_Poly" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_Pow">
<code class="sig-name descname">is_Pow</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_Pow" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_Rational">
<code class="sig-name descname">is_Rational</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_Rational" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_Relational">
<code class="sig-name descname">is_Relational</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_Relational" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_Symbol">
<code class="sig-name descname">is_Symbol</code><em class="property"> = True</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_Symbol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_Vector">
<code class="sig-name descname">is_Vector</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_Vector" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_Wild">
<code class="sig-name descname">is_Wild</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_Wild" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_algebraic">
<em class="property">property </em><code class="sig-name descname">is_algebraic</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_algebraic" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_algebraic_expr">
<code class="sig-name descname">is_algebraic_expr</code><span class="sig-paren">(</span><em class="sig-param">*syms</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_algebraic_expr" title="Permalink to this definition">¶</a></dt>
<dd><p>This tests whether a given expression is algebraic or not, in the
given symbols, syms. When syms is not given, all free symbols
will be used. The rational function does not have to be in expanded
or in any kind of canonical form.</p>
<p>This function returns False for expressions that are “algebraic
expressions” with symbolic exponents. This is a simple extension to the
is_rational_function, including rational exponentiation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Term.is_rational_function" title="nipy.algorithms.statistics.formula.formulae.Term.is_rational_function"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_rational_function</span></code></a></p>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Algebraic_expression">https://en.wikipedia.org/wiki/Algebraic_expression</a></p></li>
</ul>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">sqrt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">is_rational_function</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">is_algebraic_expr</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>This function does not attempt any nontrivial simplifications that may
result in an expression that does not appear to be an algebraic
expression to become one.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">exp</span><span class="p">,</span> <span class="n">factor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">is_algebraic_expr</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factor</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">is_algebraic_expr</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_antihermitian">
<em class="property">property </em><code class="sig-name descname">is_antihermitian</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_antihermitian" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_commutative">
<em class="property">property </em><code class="sig-name descname">is_commutative</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_commutative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_comparable">
<code class="sig-name descname">is_comparable</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_comparable" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_complex">
<em class="property">property </em><code class="sig-name descname">is_complex</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_complex" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_composite">
<em class="property">property </em><code class="sig-name descname">is_composite</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_composite" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_constant">
<code class="sig-name descname">is_constant</code><span class="sig-paren">(</span><em class="sig-param">*wrt</em>, <em class="sig-param">**flags</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_constant" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if self is constant, False if not, or None if
the constancy could not be determined conclusively.</p>
<p>If an expression has no free symbols then it is a constant. If
there are free symbols it is possible that the expression is a
constant, perhaps (but not necessarily) zero. To test such
expressions, two strategies are tried:</p>
<p>1) numerical evaluation at two random points. If two such evaluations
give two different values and the values have a precision greater than
1 then self is not constant. If the evaluations agree or could not be
obtained with any precision, no decision is made. The numerical testing
is done only if <code class="docutils literal notranslate"><span class="pre">wrt</span></code> is different than the free symbols.</p>
<p>2) differentiation with respect to variables in ‘wrt’ (or all free
symbols if omitted) to see if the expression is constant or not. This
will not always lead to an expression that is zero even though an
expression is constant (see added test in test_expr.py). If
all derivatives are zero then self is constant with respect to the
given symbols.</p>
<p>If neither evaluation nor differentiation can prove the expression is
constant, None is returned unless two numerical values happened to be
the same and the flag <code class="docutils literal notranslate"><span class="pre">failing_number</span></code> is True – in that case the
numerical value will be returned.</p>
<p>If flag simplify=False is passed, self will not be simplified;
the default is True since self should be simplified before testing.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">cos</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">Sum</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">pi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">a</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">is_constant</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">is_constant</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span><span class="o">.</span><span class="n">is_constant</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span><span class="o">.</span><span class="n">is_constant</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span><span class="o">.</span><span class="n">is_constant</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span><span class="o">.</span><span class="n">is_constant</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span><span class="o">.</span><span class="n">is_constant</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span><span class="o">.</span><span class="n">is_constant</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">pi</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span> <span class="o">==</span> <span class="n">eq</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">pi</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="mi">3</span><span class="p">})</span> <span class="o">==</span> <span class="mi">0</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">0</span><span class="o">**</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">is_constant</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">is_constant</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">is_constant</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">one</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">one</span><span class="o">.</span><span class="n">is_constant</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="n">one</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">is_constant</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="c1"># could be 0 or 1</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_even">
<em class="property">property </em><code class="sig-name descname">is_even</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_even" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_finite">
<em class="property">property </em><code class="sig-name descname">is_finite</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_finite" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_hermitian">
<em class="property">property </em><code class="sig-name descname">is_hermitian</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_hermitian" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_hypergeometric">
<code class="sig-name descname">is_hypergeometric</code><span class="sig-paren">(</span><em class="sig-param">k</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_hypergeometric" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_imaginary">
<em class="property">property </em><code class="sig-name descname">is_imaginary</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_imaginary" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_infinite">
<em class="property">property </em><code class="sig-name descname">is_infinite</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_infinite" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_integer">
<em class="property">property </em><code class="sig-name descname">is_integer</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_integer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_irrational">
<em class="property">property </em><code class="sig-name descname">is_irrational</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_irrational" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_negative">
<em class="property">property </em><code class="sig-name descname">is_negative</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_negative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_noninteger">
<em class="property">property </em><code class="sig-name descname">is_noninteger</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_noninteger" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_nonnegative">
<em class="property">property </em><code class="sig-name descname">is_nonnegative</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_nonnegative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_nonpositive">
<em class="property">property </em><code class="sig-name descname">is_nonpositive</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_nonpositive" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_nonzero">
<em class="property">property </em><code class="sig-name descname">is_nonzero</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_nonzero" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_number">
<code class="sig-name descname">is_number</code><em class="property"> = False</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_number" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_odd">
<em class="property">property </em><code class="sig-name descname">is_odd</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_odd" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_polar">
<em class="property">property </em><code class="sig-name descname">is_polar</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_polar" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_polynomial">
<code class="sig-name descname">is_polynomial</code><span class="sig-paren">(</span><em class="sig-param">*syms</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if self is a polynomial in syms and False otherwise.</p>
<p>This checks if self is an exact polynomial in syms.  This function
returns False for expressions that are “polynomials” with symbolic
exponents.  Thus, you should be able to apply polynomial algorithms to
expressions for which this returns True, and Poly(expr, *syms) should
work if and only if expr.is_polynomial(*syms) returns True. The
polynomial does not have to be in expanded form.  If no symbols are
given, all free symbols in the expression will be used.</p>
<p>This is not part of the assumptions system.  You cannot do
Symbol(‘z’, polynomial=True).</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Symbol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">is_polynomial</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">is_polynomial</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">is_polynomial</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="n">nonnegative</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">is_polynomial</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>This function does not attempt any nontrivial simplifications that may
result in an expression that does not appear to be a polynomial to
become one.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">factor</span><span class="p">,</span> <span class="n">cancel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">is_polynomial</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factor</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">y + 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factor</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">is_polynomial</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">is_polynomial</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cancel</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">y + 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cancel</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">is_polynomial</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>See also .is_rational_function()</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_positive">
<em class="property">property </em><code class="sig-name descname">is_positive</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_positive" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_prime">
<em class="property">property </em><code class="sig-name descname">is_prime</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_prime" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_rational">
<em class="property">property </em><code class="sig-name descname">is_rational</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_rational" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_rational_function">
<code class="sig-name descname">is_rational_function</code><span class="sig-paren">(</span><em class="sig-param">*syms</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_rational_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether function is a ratio of two polynomials in the given
symbols, syms. When syms is not given, all free symbols will be used.
The rational function does not have to be in expanded or in any kind of
canonical form.</p>
<p>This function returns False for expressions that are “rational
functions” with symbolic exponents.  Thus, you should be able to call
.as_numer_denom() and apply polynomial algorithms to the result for
expressions for which this returns True.</p>
<p>This is not part of the assumptions system.  You cannot do
Symbol(‘z’, rational_function=True).</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">sin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">is_rational_function</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">is_rational_function</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">is_rational_function</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">is_rational_function</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>This function does not attempt any nontrivial simplifications that may
result in an expression that does not appear to be a rational function
to become one.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">factor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">is_rational_function</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factor</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">(y + 1)/y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factor</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">is_rational_function</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>See also is_algebraic_expr().</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_real">
<em class="property">property </em><code class="sig-name descname">is_real</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_real" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_scalar">
<code class="sig-name descname">is_scalar</code><em class="property"> = True</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_scalar" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_symbol">
<code class="sig-name descname">is_symbol</code><em class="property"> = True</em><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_symbol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_transcendental">
<em class="property">property </em><code class="sig-name descname">is_transcendental</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_transcendental" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.is_zero">
<em class="property">property </em><code class="sig-name descname">is_zero</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.is_zero" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.leadterm">
<code class="sig-name descname">leadterm</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.leadterm" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the leading term a*x**b as a tuple (a, b).</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">x</span><span class="o">+</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">leadterm</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">(1, 0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">x</span><span class="o">+</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">leadterm</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">(1, -2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.limit">
<code class="sig-name descname">limit</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">xlim</em>, <em class="sig-param">dir='+'</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute limit x-&gt;xlim.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.lseries">
<code class="sig-name descname">lseries</code><span class="sig-paren">(</span><em class="sig-param">x=None</em>, <em class="sig-param">x0=0</em>, <em class="sig-param">dir='+'</em>, <em class="sig-param">logx=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.lseries" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper for series yielding an iterator of the terms of the series.</p>
<p>Note: an infinite series will yield an infinite iterator. The following,
for exaxmple, will never terminate. It will just keep printing terms
of the sin(x) series:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">lseries</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="nb">print</span> <span class="n">term</span>
</pre></div>
</div>
<p>The advantage of lseries() over nseries() is that many times you are
just interested in the next term in the series (i.e. the first term for
example), but you don’t know how many you should ask for in nseries()
using the “n” parameter.</p>
<p>See also nseries().</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.match">
<code class="sig-name descname">match</code><span class="sig-paren">(</span><em class="sig-param">pattern</em>, <em class="sig-param">old=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.match" title="Permalink to this definition">¶</a></dt>
<dd><p>Pattern matching.</p>
<p>Wild symbols match all.</p>
<p>Return <code class="docutils literal notranslate"><span class="pre">None</span></code> when expression (self) does not match
with pattern. Otherwise return a dictionary such that:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pattern</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">pattern</span><span class="p">))</span> <span class="o">==</span> <span class="bp">self</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Wild</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s2">&quot;q&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="n">p</span><span class="p">)</span>
<span class="go">{p_: x + y}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="n">q</span><span class="p">)</span>
<span class="go">{p_: x + y, q_: x + y}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">q</span><span class="o">**</span><span class="n">r</span><span class="p">)</span>
<span class="go">{p_: 4, q_: x, r_: 2}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">q</span><span class="o">**</span><span class="n">r</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">q</span><span class="o">**</span><span class="n">r</span><span class="p">))</span>
<span class="go">4*x**2</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">old</span></code> flag will give the old-style pattern matching where
expressions and patterns are essentially solved to give the
match. Both of the following give None unless <code class="docutils literal notranslate"><span class="pre">old=True</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">x</span><span class="p">,</span> <span class="n">old</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{p_: 2*x - 2}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">old</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{p_: 2/x**2}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.matches">
<code class="sig-name descname">matches</code><span class="sig-paren">(</span><em class="sig-param">expr</em>, <em class="sig-param">repl_dict={}</em>, <em class="sig-param">old=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.matches" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper method for match() that looks for a match between Wild symbols
in self and expressions in expr.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">Wild</span><span class="p">,</span> <span class="n">Basic</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;a b c&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Basic</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">Basic</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Basic</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">Basic</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">))</span>
<span class="go">{x_: b + c}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.n">
<code class="sig-name descname">n</code><span class="sig-paren">(</span><em class="sig-param">n=15</em>, <em class="sig-param">subs=None</em>, <em class="sig-param">maxn=100</em>, <em class="sig-param">chop=False</em>, <em class="sig-param">strict=False</em>, <em class="sig-param">quad=None</em>, <em class="sig-param">verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.n" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the given formula to an accuracy of n digits.
Optional keyword arguments:</p>
<blockquote>
<div><dl class="simple">
<dt>subs=&lt;dict&gt;</dt><dd><p>Substitute numerical values for symbols, e.g.
subs={x:3, y:1+pi}. The substitutions must be given as a
dictionary.</p>
</dd>
<dt>maxn=&lt;integer&gt;</dt><dd><p>Allow a maximum temporary working precision of maxn digits
(default=100)</p>
</dd>
<dt>chop=&lt;bool&gt;</dt><dd><p>Replace tiny real or imaginary parts in subresults
by exact zeros (default=False)</p>
</dd>
<dt>strict=&lt;bool&gt;</dt><dd><p>Raise PrecisionExhausted if any subresult fails to evaluate
to full accuracy, given the available maxprec
(default=False)</p>
</dd>
<dt>quad=&lt;str&gt;</dt><dd><p>Choose algorithm for numerical quadrature. By default,
tanh-sinh quadrature is used. For oscillatory
integrals on an infinite interval, try quad=’osc’.</p>
</dd>
<dt>verbose=&lt;bool&gt;</dt><dd><p>Print debug information (default=False)</p>
</dd>
</dl>
</div></blockquote>
<p class="rubric">Notes</p>
<p>When Floats are naively substituted into an expression, precision errors
may adversely affect the result. For example, adding 1e16 (a Float) to 1
will truncate to 1e16; if 1e16 is then subtracted, the result will be 0.
That is exactly what happens in the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="mf">1e16</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="mf">1e16</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">-</span> <span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<p>Using the subs argument for evalf is the accurate way to evaluate such an
expression:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">-</span> <span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="n">subs</span><span class="o">=</span><span class="n">values</span><span class="p">)</span>
<span class="go">1.00000000000000</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.name">
<code class="sig-name descname">name</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.normal">
<code class="sig-name descname">normal</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.normal" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.nseries">
<code class="sig-name descname">nseries</code><span class="sig-paren">(</span><em class="sig-param">x=None</em>, <em class="sig-param">x0=0</em>, <em class="sig-param">n=6</em>, <em class="sig-param">dir='+'</em>, <em class="sig-param">logx=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.nseries" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper to _eval_nseries if assumptions allow, else to series.</p>
<p>If x is given, x0 is 0, dir=’+’, and self has x, then _eval_nseries is
called. This calculates “n” terms in the innermost expressions and
then builds up the final series just by “cross-multiplying” everything
out.</p>
<p>The optional <code class="docutils literal notranslate"><span class="pre">logx</span></code> parameter can be used to replace any log(x) in the
returned series with a symbolic value to avoid evaluating log(x) at 0. A
symbol to use in place of log(x) should be provided.</p>
<p>Advantage – it’s fast, because we don’t have to determine how many
terms we need to calculate in advance.</p>
<p>Disadvantage – you may end up with less terms than you may have
expected, but the O(x**n) term appended will always be correct and
so the result, though perhaps shorter, will also be correct.</p>
<p>If any of those assumptions is not met, this is treated like a
wrapper to series which will try harder to return the correct
number of terms.</p>
<p>See also lseries().</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">sin</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">Symbol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">nseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="go">x - x**3/6 + x**5/120 + O(x**6)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">nseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">x - x**2/2 + x**3/3 - x**4/4 + O(x**5)</span>
</pre></div>
</div>
<p>Handling of the <code class="docutils literal notranslate"><span class="pre">logx</span></code> parameter — in the following example the
expansion fails since <code class="docutils literal notranslate"><span class="pre">sin</span></code> does not have an asymptotic expansion
at -oo (the limit of log(x) as x approaches 0):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">nseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">PoleError</span>: <span class="n">...</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">logx</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;logx&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">nseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="n">logx</span><span class="p">)</span>
<span class="go">sin(logx)</span>
</pre></div>
</div>
<p>In the following example, the expansion works but gives only an Order term
unless the <code class="docutils literal notranslate"><span class="pre">logx</span></code> parameter is used:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">nseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">O(log(x)**2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">nseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="n">logx</span><span class="p">)</span>
<span class="go">exp(logx*y)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.nsimplify">
<code class="sig-name descname">nsimplify</code><span class="sig-paren">(</span><em class="sig-param">constants=[]</em>, <em class="sig-param">tolerance=None</em>, <em class="sig-param">full=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.nsimplify" title="Permalink to this definition">¶</a></dt>
<dd><p>See the nsimplify function in sympy.simplify</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.powsimp">
<code class="sig-name descname">powsimp</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.powsimp" title="Permalink to this definition">¶</a></dt>
<dd><p>See the powsimp function in sympy.simplify</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.primitive">
<code class="sig-name descname">primitive</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.primitive" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the positive Rational that can be extracted non-recursively
from every term of self (i.e., self is treated like an Add). This is
like the as_coeff_Mul() method but primitive always extracts a positive
Rational (never a negative or a Float).</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">primitive</span><span class="p">()</span>
<span class="go">(3, (x + 1)**2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="mi">6</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span> <span class="n">a</span><span class="o">.</span><span class="n">primitive</span><span class="p">()</span>
<span class="go">(2, 3*x + 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="p">);</span> <span class="n">b</span><span class="o">.</span><span class="n">primitive</span><span class="p">()</span>
<span class="go">(1/2, x + 6)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">primitive</span><span class="p">()</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.radsimp">
<code class="sig-name descname">radsimp</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.radsimp" title="Permalink to this definition">¶</a></dt>
<dd><p>See the radsimp function in sympy.simplify</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.ratsimp">
<code class="sig-name descname">ratsimp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.ratsimp" title="Permalink to this definition">¶</a></dt>
<dd><p>See the ratsimp function in sympy.simplify</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.rcall">
<code class="sig-name descname">rcall</code><span class="sig-paren">(</span><em class="sig-param">*args</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.rcall" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply on the argument recursively through the expression tree.</p>
<p>This method is used to simulate a common abuse of notation for
operators. For instance in SymPy the the following will not work:</p>
<p><code class="docutils literal notranslate"><span class="pre">(x+Lambda(y,</span> <span class="pre">2*y))(z)</span> <span class="pre">==</span> <span class="pre">x+2*z</span></code>,</p>
<p>however you can use</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Lambda</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">Lambda</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">rcall</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
<span class="go">x + 2*z</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.refine">
<code class="sig-name descname">refine</code><span class="sig-paren">(</span><em class="sig-param">assumption=True</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.refine" title="Permalink to this definition">¶</a></dt>
<dd><p>See the refine function in sympy.assumptions</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.removeO">
<code class="sig-name descname">removeO</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.removeO" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes the additive O(..) symbol if there is one</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.replace">
<code class="sig-name descname">replace</code><span class="sig-paren">(</span><em class="sig-param">query</em>, <em class="sig-param">value</em>, <em class="sig-param">map=False</em>, <em class="sig-param">simultaneous=True</em>, <em class="sig-param">exact=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.replace" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace matching subexpressions of <code class="docutils literal notranslate"><span class="pre">self</span></code> with <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">map</span> <span class="pre">=</span> <span class="pre">True</span></code> then also return the mapping {old: new} where <code class="docutils literal notranslate"><span class="pre">old</span></code>
was a sub-expression found with query and <code class="docutils literal notranslate"><span class="pre">new</span></code> is the replacement
value for it. If the expression itself doesn’t match the query, then
the returned value will be <code class="docutils literal notranslate"><span class="pre">self.xreplace(map)</span></code> otherwise it should
be <code class="docutils literal notranslate"><span class="pre">self.subs(ordered(map.items()))</span></code>.</p>
<p>Traverses an expression tree and performs replacement of matching
subexpressions from the bottom to the top of the tree. The default
approach is to do the replacement in a simultaneous fashion so
changes made are targeted only once. If this is not desired or causes
problems, <code class="docutils literal notranslate"><span class="pre">simultaneous</span></code> can be set to False. In addition, if an
expression containing more than one Wild symbol is being used to match
subexpressions and  the <code class="docutils literal notranslate"><span class="pre">exact</span></code> flag is True, then the match will only
succeed if non-zero values are received for each Wild that appears in
the match pattern.</p>
<p>The list of possible combinations of queries and replacement values
is listed below:</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Term.subs" title="nipy.algorithms.statistics.formula.formulae.Term.subs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subs</span></code></a></dt><dd><p>substitution of subexpressions as defined by the objects themselves.</p>
</dd>
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Term.xreplace" title="nipy.algorithms.statistics.formula.formulae.Term.xreplace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">xreplace</span></code></a></dt><dd><p>exact node replacement in expr tree; also capable of using matching rules</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>Initial setup</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">log</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">tan</span><span class="p">,</span> <span class="n">Wild</span><span class="p">,</span> <span class="n">Mul</span><span class="p">,</span> <span class="n">Add</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">+</span> <span class="n">tan</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<dl>
<dt>1.1. type -&gt; type</dt><dd><p>obj.replace(type, newtype)</p>
<p>When object of type <code class="docutils literal notranslate"><span class="pre">type</span></code> is found, replace it with the
result of passing its argument(s) to <code class="docutils literal notranslate"><span class="pre">newtype</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">)</span>
<span class="go">log(cos(x)) + tan(cos(x**2))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="nb">map</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(cos(x), {sin(x): cos(x)})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">Mul</span><span class="p">,</span> <span class="n">Add</span><span class="p">)</span>
<span class="go">x + y</span>
</pre></div>
</div>
</dd>
<dt>1.2. type -&gt; func</dt><dd><p>obj.replace(type, func)</p>
<p>When object of type <code class="docutils literal notranslate"><span class="pre">type</span></code> is found, apply <code class="docutils literal notranslate"><span class="pre">func</span></code> to its
argument(s). <code class="docutils literal notranslate"><span class="pre">func</span></code> must be written to handle the number
of arguments of <code class="docutils literal notranslate"><span class="pre">type</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">arg</span><span class="p">:</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">arg</span><span class="p">))</span>
<span class="go">log(sin(2*x)) + tan(sin(2*x**2))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">Mul</span><span class="p">,</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)))</span>
<span class="go">sin(2*x*y)</span>
</pre></div>
</div>
</dd>
<dt>2.1. pattern -&gt; expr</dt><dd><p>obj.replace(pattern(wild), expr(wild))</p>
<p>Replace subexpressions matching <code class="docutils literal notranslate"><span class="pre">pattern</span></code> with the expression
written in terms of the Wild symbols in <code class="docutils literal notranslate"><span class="pre">pattern</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Wild</span><span class="p">,</span> <span class="s1">&#39;ab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">tan</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
<span class="go">log(tan(x)) + tan(tan(x**2))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">tan</span><span class="p">(</span><span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
<span class="go">log(tan(x/2)) + tan(tan(x**2/2))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">a</span><span class="p">)</span>
<span class="go">log(x) + tan(x**2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="go">y</span>
</pre></div>
</div>
<p>Matching is exact by default when more than one Wild symbol
is used: matching fails unless the match gives non-zero
values for all Wild symbols:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span>
<span class="go">y - 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span>
<span class="go">2*x</span>
</pre></div>
</div>
<p>When set to False, the results may be non-intuitive:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">2/x</span>
</pre></div>
</div>
</dd>
<dt>2.2. pattern -&gt; func</dt><dd><p>obj.replace(pattern(wild), lambda wild: expr(wild))</p>
<p>All behavior is the same as in 2.1 but now a function in terms of
pattern variables is used rather than an expression:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="p">))</span>
<span class="go">log(sin(2*x)) + tan(sin(2*x**2))</span>
</pre></div>
</div>
</dd>
<dt>3.1. func -&gt; func</dt><dd><p>obj.replace(filter, func)</p>
<p>Replace subexpression <code class="docutils literal notranslate"><span class="pre">e</span></code> with <code class="docutils literal notranslate"><span class="pre">func(e)</span></code> if <code class="docutils literal notranslate"><span class="pre">filter(e)</span></code>
is True.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="k">lambda</span> <span class="n">expr</span><span class="p">:</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Number</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">expr</span><span class="p">:</span> <span class="n">expr</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="go">4*sin(x**9)</span>
</pre></div>
</div>
</dd>
</dl>
<p>The expression itself is also targeted by the query but is done in
such a fashion that changes are not made twice.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="go">2*x*(2*x*y + 1)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.rewrite">
<code class="sig-name descname">rewrite</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**hints</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.rewrite" title="Permalink to this definition">¶</a></dt>
<dd><p>Rewrite functions in terms of other functions.</p>
<p>Rewrites expression containing applications of functions
of one kind in terms of functions of different kind. For
example you can rewrite trigonometric functions as complex
exponentials or combinatorial functions as gamma function.</p>
<p>As a pattern this function accepts a list of functions to
to rewrite (instances of DefinedFunction class). As rule
you can use string or a destination function instance (in
this case rewrite() will use the str() function).</p>
<p>There is also the possibility to pass hints on how to rewrite
the given expressions. For now there is only one such hint
defined called ‘deep’. When ‘deep’ is set to False it will
forbid functions to rewrite their contents.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">sin</span><span class="p">,</span> <span class="n">exp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
</pre></div>
</div>
<p>Unspecified pattern:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span>
<span class="go">-I*(exp(I*x) - exp(-I*x))/2</span>
</pre></div>
</div>
<p>Pattern as a single function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="n">exp</span><span class="p">)</span>
<span class="go">-I*(exp(I*x) - exp(-I*x))/2</span>
</pre></div>
</div>
<p>Pattern as a list of functions:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">rewrite</span><span class="p">([</span><span class="n">sin</span><span class="p">,</span> <span class="p">],</span> <span class="n">exp</span><span class="p">)</span>
<span class="go">-I*(exp(I*x) - exp(-I*x))/2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.round">
<code class="sig-name descname">round</code><span class="sig-paren">(</span><em class="sig-param">p=0</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.round" title="Permalink to this definition">¶</a></dt>
<dd><p>Return x rounded to the given decimal place.</p>
<p>If a complex number would results, apply round to the real
and imaginary components of the number.</p>
<p class="rubric">Notes</p>
<p>Do not confuse the Python builtin function, round, with the
SymPy method of the same name. The former always returns a float
(or raises an error if applied to a complex value) while the
latter returns either a Number or a complex number:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="mi">123</span><span class="p">),</span> <span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="n">Number</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="n">Number</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">((</span><span class="mi">3</span><span class="o">*</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(),</span> <span class="n">Mul</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">((</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(),</span> <span class="n">Add</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">pi</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">Add</span><span class="p">,</span> <span class="n">Mul</span><span class="p">,</span> <span class="n">Number</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="p">(</span><span class="mf">10.5</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">()</span>
<span class="go">11.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">.</span><span class="n">round</span><span class="p">()</span>
<span class="go">3.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">3.14</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span> <span class="o">+</span> <span class="n">E</span><span class="o">*</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">()</span>
<span class="go">6. + 3.*I</span>
</pre></div>
</div>
<p>The round method has a chopping effect:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span> <span class="o">+</span> <span class="n">I</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">()</span>
<span class="go">6.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">10</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">()</span>
<span class="go">2.*I</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">10</span> <span class="o">+</span> <span class="n">E</span><span class="o">*</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0.31 + 2.72*I</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.separate">
<code class="sig-name descname">separate</code><span class="sig-paren">(</span><em class="sig-param">deep=False</em>, <em class="sig-param">force=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.separate" title="Permalink to this definition">¶</a></dt>
<dd><p>See the separate function in sympy.simplify</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.series">
<code class="sig-name descname">series</code><span class="sig-paren">(</span><em class="sig-param">x=None</em>, <em class="sig-param">x0=0</em>, <em class="sig-param">n=6</em>, <em class="sig-param">dir='+'</em>, <em class="sig-param">logx=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.series" title="Permalink to this definition">¶</a></dt>
<dd><p>Series expansion of “self” around <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">x0</span></code> yielding either terms of
the series one by one (the lazy series given when n=None), else
all the terms at once when n != None.</p>
<p>Returns the series expansion of “self” around the point <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">x0</span></code>
with respect to <code class="docutils literal notranslate"><span class="pre">x</span></code> up to <code class="docutils literal notranslate"><span class="pre">O((x</span> <span class="pre">-</span> <span class="pre">x0)**n,</span> <span class="pre">x,</span> <span class="pre">x0)</span></code> (default n is 6).</p>
<p>If <code class="docutils literal notranslate"><span class="pre">x=None</span></code> and <code class="docutils literal notranslate"><span class="pre">self</span></code> is univariate, the univariate symbol will
be supplied, otherwise an error will be raised.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">cos</span><span class="p">,</span> <span class="n">exp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">()</span>
<span class="go">1 - x**2/2 + x**4/24 + O(x**6)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="go">1 - x**2/2 + O(x**4)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">cos(1) - (x - 1)*sin(1) + O((x - 1)**2, (x, 1))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">exp</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">cos(x + 1) - y*sin(x + 1) + O(y**2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">cos(exp(y)) - x*sin(exp(y)) + O(x**2)</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">n=None</span></code> then a generator of the series terms will be returned.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">term</span><span class="o">=</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">term</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>
<span class="go">[1, -x**2/2]</span>
</pre></div>
</div>
<p>For <code class="docutils literal notranslate"><span class="pre">dir=+</span></code> (default) the series is calculated from the right and
for <code class="docutils literal notranslate"><span class="pre">dir=-</span></code> the series from the left. For smooth functions this
flag will not alter the results.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="nb">dir</span><span class="o">=</span><span class="s2">&quot;+&quot;</span><span class="p">)</span>
<span class="go">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="nb">dir</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">)</span>
<span class="go">-x</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.simplify">
<code class="sig-name descname">simplify</code><span class="sig-paren">(</span><em class="sig-param">ratio=1.7</em>, <em class="sig-param">measure=None</em>, <em class="sig-param">rational=False</em>, <em class="sig-param">inverse=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.simplify" title="Permalink to this definition">¶</a></dt>
<dd><p>See the simplify function in sympy.simplify</p>
</dd></dl>

<dl class="attribute">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.sort_key">
<code class="sig-name descname">sort_key</code><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.sort_key" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.subs">
<code class="sig-name descname">subs</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.subs" title="Permalink to this definition">¶</a></dt>
<dd><p>Substitutes old for new in an expression after sympifying args.</p>
<dl class="simple">
<dt><cite>args</cite> is either:</dt><dd><ul class="simple">
<li><p>two arguments, e.g. foo.subs(old, new)</p></li>
<li><dl class="simple">
<dt>one iterable argument, e.g. foo.subs(iterable). The iterable may be</dt><dd><dl class="simple">
<dt>o an iterable container with (old, new) pairs. In this case the</dt><dd><p>replacements are processed in the order given with successive
patterns possibly affecting replacements already made.</p>
</dd>
<dt>o a dict or set whose key/value items correspond to old/new pairs.</dt><dd><p>In this case the old/new pairs will be sorted by op count and in
case of a tie, by number of args and the default_sort_key. The
resulting sorted list is then processed as an iterable container
(see previous).</p>
</dd>
</dl>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p>If the keyword <code class="docutils literal notranslate"><span class="pre">simultaneous</span></code> is True, the subexpressions will not be
evaluated until all the substitutions have been made.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Term.replace" title="nipy.algorithms.statistics.formula.formulae.Term.replace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">replace</span></code></a></dt><dd><p>replacement capable of doing wildcard-like matching, parsing of match, and conditional replacements</p>
</dd>
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Term.xreplace" title="nipy.algorithms.statistics.formula.formulae.Term.xreplace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">xreplace</span></code></a></dt><dd><p>exact node replacement in expr tree; also capable of using matching rules</p>
</dd>
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Term.evalf" title="nipy.algorithms.statistics.formula.formulae.Term.evalf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">evalf</span></code></a></dt><dd><p>calculates the given formula to a desired level of precision</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">pi</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">oo</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pi</span><span class="p">)</span>
<span class="go">pi*y + 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span><span class="n">pi</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span><span class="mi">2</span><span class="p">})</span>
<span class="go">1 + 2*pi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="n">pi</span><span class="p">),</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="go">1 + 2*pi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reps</span> <span class="o">=</span> <span class="p">[(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">reps</span><span class="p">))</span>
<span class="go">x**2 + 2</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">y**2 + y</span>
</pre></div>
</div>
<p>To replace only the x**2 but not the x**4, use xreplace:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">:</span> <span class="n">y</span><span class="p">})</span>
<span class="go">x**4 + y</span>
</pre></div>
</div>
<p>To delay evaluation until all substitutions have been made,
set the keyword <code class="docutils literal notranslate"><span class="pre">simultaneous</span></code> to True:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span> <span class="n">simultaneous</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
<p>This has the added feature of not allowing subsequent substitutions
to affect those already made:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">})</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">},</span> <span class="n">simultaneous</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">y/(x + y)</span>
</pre></div>
</div>
<p>In order to obtain a canonical result, unordered iterables are
sorted by count_op length, number of arguments and by the
default_sort_key to break any ties. All other iterables are left
unsorted.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)),</span> <span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">),</span> <span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">),</span> <span class="n">c</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">E</span> <span class="o">=</span> <span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">e</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="nb">dict</span><span class="p">([</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">E</span><span class="p">]))</span>
<span class="go">a*c*sin(d*e) + b</span>
</pre></div>
</div>
<p>The resulting expression represents a literal replacement of the
old arguments with the new arguments. This may not reflect the
limiting behavior of the expression:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">oo</span><span class="p">})</span>
<span class="go">nan</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">limit</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">oo</span><span class="p">)</span>
<span class="go">oo</span>
</pre></div>
</div>
<p>If the substitution will be followed by numerical
evaluation, it is better to pass the substitution to
evalf as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="n">subs</span><span class="o">=</span><span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">},</span> <span class="n">n</span><span class="o">=</span><span class="mi">21</span><span class="p">)</span>
<span class="go">0.333333333333333333333</span>
</pre></div>
</div>
<p>rather than</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">})</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="mi">21</span><span class="p">)</span>
<span class="go">0.333333333333333314830</span>
</pre></div>
</div>
<p>as the former will ensure that the desired level of precision is
obtained.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.taylor_term">
<code class="sig-name descname">taylor_term</code><span class="sig-paren">(</span><em class="sig-param">n</em>, <em class="sig-param">x</em>, <em class="sig-param">*previous_terms</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.taylor_term" title="Permalink to this definition">¶</a></dt>
<dd><p>General method for the taylor term.</p>
<p>This method is slow, because it differentiates n-times. Subclasses can
redefine it to make it faster by using the “previous_terms”.</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.to_nnf">
<code class="sig-name descname">to_nnf</code><span class="sig-paren">(</span><em class="sig-param">simplify=True</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.to_nnf" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.together">
<code class="sig-name descname">together</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.together" title="Permalink to this definition">¶</a></dt>
<dd><p>See the together function in sympy.polys</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.transpose">
<code class="sig-name descname">transpose</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.transpose" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.trigsimp">
<code class="sig-name descname">trigsimp</code><span class="sig-paren">(</span><em class="sig-param">**args</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.trigsimp" title="Permalink to this definition">¶</a></dt>
<dd><p>See the trigsimp function in sympy.simplify</p>
</dd></dl>

<dl class="method">
<dt id="nipy.algorithms.statistics.formula.formulae.Term.xreplace">
<code class="sig-name descname">xreplace</code><span class="sig-paren">(</span><em class="sig-param">rule</em>, <em class="sig-param">hack2=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.Term.xreplace" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace occurrences of objects within the expression.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>rule</strong> : dict-like</p>
<blockquote>
<div><p>Expresses a replacement rule</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>xreplace</strong> : the result of the replacement</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Term.replace" title="nipy.algorithms.statistics.formula.formulae.Term.replace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">replace</span></code></a></dt><dd><p>replacement capable of doing wildcard-like matching, parsing of match, and conditional replacements</p>
</dd>
<dt><a class="reference internal" href="#nipy.algorithms.statistics.formula.formulae.Term.subs" title="nipy.algorithms.statistics.formula.formulae.Term.subs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subs</span></code></a></dt><dd><p>substitution of subexpressions as defined by the objects themselves.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">exp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x y z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">pi</span><span class="p">})</span>
<span class="go">pi*y + 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">pi</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="go">1 + 2*pi</span>
</pre></div>
</div>
<p>Replacements occur only if an entire node in the expression tree is
matched:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">:</span> <span class="n">pi</span><span class="p">})</span>
<span class="go">z + pi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">:</span> <span class="n">pi</span><span class="p">})</span>
<span class="go">x*y*z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">:</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">z</span><span class="p">})</span>
<span class="go">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">:</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">z</span><span class="p">})</span>
<span class="go">4*z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="go">x + y + 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">:</span> <span class="n">y</span><span class="p">})</span>
<span class="go">x + exp(y) + 2</span>
</pre></div>
</div>
<p>xreplace doesn’t differentiate between free and bound symbols. In the
following, subs(x, y) would not change x since it is a bound symbol,
but xreplace does:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Integral</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Integral</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">y</span><span class="p">})</span>
<span class="go">Integral(y, (y, 1, 2*y))</span>
</pre></div>
</div>
<p>Trying to replace x with an expression raises an error:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Integral</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">})</span> 
<span class="go">ValueError: Invalid limits given: ((2*y, 1, 4*y),)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nipy.algorithms.statistics.formula.formulae.contrast_from_cols_or_rows">
<code class="sig-prename descclassname">nipy.algorithms.statistics.formula.formulae.</code><code class="sig-name descname">contrast_from_cols_or_rows</code><span class="sig-paren">(</span><em class="sig-param">L</em>, <em class="sig-param">D</em>, <em class="sig-param">pseudo=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/nipy/algorithms/statistics/formula/formulae.html#contrast_from_cols_or_rows"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.contrast_from_cols_or_rows" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a contrast matrix from a design matrix D</p>
<p>(possibly with its pseudo inverse already computed)
and a matrix L that either specifies something in
the column space of D or the row space of D.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>L</strong> : ndarray</p>
<blockquote>
<div><p>Matrix used to try and construct a contrast.</p>
</div></blockquote>
<p><strong>D</strong> : ndarray</p>
<blockquote>
<div><p>Design matrix used to create the contrast.</p>
</div></blockquote>
<p><strong>pseudo</strong> : None or array-like, optional</p>
<blockquote>
<div><p>If not None, gives pseudo-inverse of <cite>D</cite>.  Allows you to pass
this if it is already calculated.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>C</strong> : ndarray</p>
<blockquote>
<div><p>Matrix with C.shape[1] == D.shape[1] representing an estimable
contrast.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>From an n x p design matrix D and a matrix L, tries to determine a p
x q contrast matrix C which determines a contrast of full rank,
i.e. the n x q matrix</p>
<p>dot(transpose(C), pinv(D))</p>
<p>is full rank.</p>
<p>L must satisfy either L.shape[0] == n or L.shape[1] == p.</p>
<p>If L.shape[0] == n, then L is thought of as representing
columns in the column space of D.</p>
<p>If L.shape[1] == p, then L is thought of as what is known
as a contrast matrix. In this case, this function returns an estimable
contrast corresponding to the dot(D, L.T)</p>
<p>This always produces a meaningful contrast, not always
with the intended properties because q is always non-zero unless
L is identically 0. That is, it produces a contrast that spans
the column space of L (after projection onto the column space of D).</p>
</dd></dl>

<dl class="function">
<dt id="nipy.algorithms.statistics.formula.formulae.define">
<code class="sig-prename descclassname">nipy.algorithms.statistics.formula.formulae.</code><code class="sig-name descname">define</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/nipy/algorithms/statistics/formula/formulae.html#define"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.define" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nipy.algorithms.statistics.formula.formulae.getparams">
<code class="sig-prename descclassname">nipy.algorithms.statistics.formula.formulae.</code><code class="sig-name descname">getparams</code><span class="sig-paren">(</span><em class="sig-param">expression</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/nipy/algorithms/statistics/formula/formulae.html#getparams"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.getparams" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the parameters of an expression that are not Term 
instances but are instances of sympy.Symbol.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="p">[</span><span class="n">Term</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="s1">&#39;xyz&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Formula</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getparams</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">mean</span>
<span class="go">_b0*x + _b1*y + _b2*z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getparams</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">mean</span><span class="p">)</span>
<span class="go">[_b0, _b1, _b2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">th</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;theta&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">mean</span><span class="o">*</span><span class="n">sympy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">th</span><span class="p">)</span>
<span class="go">(_b0*x + _b1*y + _b2*z)*exp(theta)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getparams</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">mean</span><span class="o">*</span><span class="n">sympy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">th</span><span class="p">))</span>
<span class="go">[_b0, _b1, _b2, theta]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="nipy.algorithms.statistics.formula.formulae.getterms">
<code class="sig-prename descclassname">nipy.algorithms.statistics.formula.formulae.</code><code class="sig-name descname">getterms</code><span class="sig-paren">(</span><em class="sig-param">expression</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/nipy/algorithms/statistics/formula/formulae.html#getterms"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.getterms" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the all instances of Term in an expression.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="p">[</span><span class="n">Term</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="s1">&#39;xyz&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Formula</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getterms</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">[x, y, z]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getterms</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">mean</span><span class="p">)</span>
<span class="go">[x, y, z]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="nipy.algorithms.statistics.formula.formulae.is_factor">
<code class="sig-prename descclassname">nipy.algorithms.statistics.formula.formulae.</code><code class="sig-name descname">is_factor</code><span class="sig-paren">(</span><em class="sig-param">obj</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/nipy/algorithms/statistics/formula/formulae.html#is_factor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.is_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Is obj a Factor?</p>
</dd></dl>

<dl class="function">
<dt id="nipy.algorithms.statistics.formula.formulae.is_factor_term">
<code class="sig-prename descclassname">nipy.algorithms.statistics.formula.formulae.</code><code class="sig-name descname">is_factor_term</code><span class="sig-paren">(</span><em class="sig-param">obj</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/nipy/algorithms/statistics/formula/formulae.html#is_factor_term"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.is_factor_term" title="Permalink to this definition">¶</a></dt>
<dd><p>Is obj a FactorTerm?</p>
</dd></dl>

<dl class="function">
<dt id="nipy.algorithms.statistics.formula.formulae.is_formula">
<code class="sig-prename descclassname">nipy.algorithms.statistics.formula.formulae.</code><code class="sig-name descname">is_formula</code><span class="sig-paren">(</span><em class="sig-param">obj</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/nipy/algorithms/statistics/formula/formulae.html#is_formula"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.is_formula" title="Permalink to this definition">¶</a></dt>
<dd><p>Is obj a Formula?</p>
</dd></dl>

<dl class="function">
<dt id="nipy.algorithms.statistics.formula.formulae.is_term">
<code class="sig-prename descclassname">nipy.algorithms.statistics.formula.formulae.</code><code class="sig-name descname">is_term</code><span class="sig-paren">(</span><em class="sig-param">obj</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/nipy/algorithms/statistics/formula/formulae.html#is_term"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.is_term" title="Permalink to this definition">¶</a></dt>
<dd><p>Is obj a Term?</p>
</dd></dl>

<dl class="function">
<dt id="nipy.algorithms.statistics.formula.formulae.make_dummy">
<code class="sig-prename descclassname">nipy.algorithms.statistics.formula.formulae.</code><code class="sig-name descname">make_dummy</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.make_dummy" title="Permalink to this definition">¶</a></dt>
<dd><p><cite>make_dummy</cite> is deprecated!
Please use sympy.Dummy instead of this function</p>
<blockquote>
<div><p>Make dummy variable of given name</p>
</div></blockquote>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>name</strong> : str</p>
<blockquote>
<div><p>name of dummy variable</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>dum</strong> : <cite>Dummy</cite> instance</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The interface to Dummy changed between 0.6.7 and 0.7.0, and we used this
function to keep compatibility. Now we depend on sympy 0.7.0 and this
function is obsolete.</p>
</dd></dl>

<dl class="function">
<dt id="nipy.algorithms.statistics.formula.formulae.make_recarray">
<code class="sig-prename descclassname">nipy.algorithms.statistics.formula.formulae.</code><code class="sig-name descname">make_recarray</code><span class="sig-paren">(</span><em class="sig-param">rows</em>, <em class="sig-param">names</em>, <em class="sig-param">dtypes=None</em>, <em class="sig-param">drop_name_dim=&lt;class 'nipy.utils._NoValue'&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/nipy/algorithms/statistics/formula/formulae.html#make_recarray"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.make_recarray" title="Permalink to this definition">¶</a></dt>
<dd><p>Create recarray from <cite>rows</cite> with field names <cite>names</cite></p>
<p>Create a recarray with named columns from a list or ndarray of <cite>rows</cite> and
sequence of <cite>names</cite> for the columns. If <cite>rows</cite> is an ndarray, <cite>dtypes</cite> must
be None, otherwise we raise a ValueError. Otherwise, if <cite>dtypes</cite> is None,
we cast the data in all columns in <cite>rows</cite> as np.float. If <cite>dtypes</cite> is not
None, the routine uses <cite>dtypes</cite> as a dtype specifier for the output
structured array.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>rows: list or array</strong></p>
<blockquote>
<div><p>Rows that will be turned into an recarray.</p>
</div></blockquote>
<p><strong>names: sequence</strong></p>
<blockquote>
<div><p>Sequence of strings - names for the columns.</p>
</div></blockquote>
<p><strong>dtypes: None or sequence of str or sequence of np.dtype, optional</strong></p>
<blockquote>
<div><p>Used to create a np.dtype, can be sequence of np.dtype or string.</p>
</div></blockquote>
<p><strong>drop_name_dim</strong> : {_NoValue, False, True}, optional</p>
<blockquote>
<div><p>Flag for compatibility with future default behavior.  Current default
is False.  If True, drops the length 1 dimension corresponding to the
axis transformed into fields when converting into a recarray.  If
_NoValue specified, gives default.  Default will change to True in the
next version of Nipy.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>v</strong> : np.ndarray</p>
<blockquote>
<div><p>Structured array with field names given by <cite>names</cite>.</p>
</div></blockquote>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong></p>
<blockquote>
<div><p><cite>dtypes</cite> not None when <cite>rows</cite> is array.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>The following tests depend on machine byte order for their exact output.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">make_recarray</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">],</span>
<span class="gp">... </span>              <span class="n">drop_name_dim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> 
<span class="go">array([(3, 4), (4, 6), (6, 8)],</span>
<span class="go">      dtype=[(&#39;x&#39;, &#39;&lt;i8&#39;), (&#39;y&#39;, &#39;&lt;i8&#39;)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">make_recarray</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">],</span>
<span class="gp">... </span>              <span class="n">drop_name_dim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> 
<span class="go">array([[(3, 4)],</span>
<span class="go">       [(4, 6)],</span>
<span class="go">       [(6, 8)]],</span>
<span class="go">      dtype=[(&#39;x&#39;, &#39;&lt;i8&#39;), (&#39;y&#39;, &#39;&lt;i8&#39;)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">make_recarray</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="s1">&#39;u&#39;</span><span class="p">],</span> <span class="n">drop_name_dim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">make_recarray</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">],</span>
<span class="gp">... </span>              <span class="n">drop_name_dim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> 
<span class="go">array([(3, 4), (4, 6), (6, 8)],</span>
<span class="go">      dtype=[(&#39;x&#39;, &#39;&lt;i8&#39;), (&#39;y&#39;, &#39;&lt;i8&#39;)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">make_recarray</span><span class="p">([[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">]],</span> <span class="s1">&#39;wv&#39;</span><span class="p">,</span>
<span class="gp">... </span>              <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">])</span>  
<span class="go">array([(3.0, 4), (4.0, 6), (7.0, 9)],</span>
<span class="go">      dtype=[(&#39;w&#39;, &#39;&lt;f8&#39;), (&#39;v&#39;, &#39;&lt;i8&#39;)])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="nipy.algorithms.statistics.formula.formulae.natural_spline">
<code class="sig-prename descclassname">nipy.algorithms.statistics.formula.formulae.</code><code class="sig-name descname">natural_spline</code><span class="sig-paren">(</span><em class="sig-param">t</em>, <em class="sig-param">knots=None</em>, <em class="sig-param">order=3</em>, <em class="sig-param">intercept=False</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/nipy/algorithms/statistics/formula/formulae.html#natural_spline"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.natural_spline" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Formula containing a natural spline</p>
<p>Spline for a Term with specified <cite>knots</cite> and <cite>order</cite>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>t</strong> : <code class="docutils literal notranslate"><span class="pre">Term</span></code></p>
<p><strong>knots</strong> : None or sequence, optional</p>
<blockquote>
<div><p>Sequence of float.  Default None (same as empty list)</p>
</div></blockquote>
<p><strong>order</strong> : int, optional</p>
<blockquote>
<div><p>Order of the spline. Defaults to a cubic (==3)</p>
</div></blockquote>
<p><strong>intercept</strong> : bool, optional</p>
<blockquote>
<div><p>If True, include a constant function in the natural
spline. Default is False</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>formula</strong> : Formula</p>
<blockquote>
<div><p>A Formula with (len(knots) + order) Terms (if intercept=False,
otherwise includes one more Term), made up of the natural spline
functions.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Term</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">natural_spline</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">knots</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="n">order</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mf">7.</span><span class="p">])</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">([(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">design</span><span class="p">(</span><span class="n">xval</span><span class="p">,</span> <span class="n">return_float</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([[   3.,    9.,   27.,    8.,    0.,   -0.],</span>
<span class="go">       [   5.,   25.,  125.,   64.,    8.,    1.],</span>
<span class="go">       [   7.,   49.,  343.,  216.,   64.,   27.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">design</span><span class="p">(</span><span class="n">xval</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">descr</span><span class="p">)</span>
<span class="go">[(&#39;ns_1(x)&#39;, &#39;&lt;f8&#39;), (&#39;ns_2(x)&#39;, &#39;&lt;f8&#39;), (&#39;ns_3(x)&#39;, &#39;&lt;f8&#39;), (&#39;ns_4(x)&#39;, &#39;&lt;f8&#39;), (&#39;ns_5(x)&#39;, &#39;&lt;f8&#39;), (&#39;ns_6(x)&#39;, &#39;&lt;f8&#39;)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="nipy.algorithms.statistics.formula.formulae.terms">
<code class="sig-prename descclassname">nipy.algorithms.statistics.formula.formulae.</code><code class="sig-name descname">terms</code><span class="sig-paren">(</span><em class="sig-param">names</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/nipy/algorithms/statistics/formula/formulae.html#terms"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nipy.algorithms.statistics.formula.formulae.terms" title="Permalink to this definition">¶</a></dt>
<dd><p>Return list of terms with names given by <cite>names</cite></p>
<p>This is just a convenience in defining a set of terms, and is the
equivalent of <code class="docutils literal notranslate"><span class="pre">sympy.symbols</span></code> for defining symbols in sympy.</p>
<p>We enforce the sympy 0.7.0 behavior of returning symbol “abc” from input
“abc”, rthan than 3 symbols “a”, “b”, “c”.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>names</strong> : str or sequence of str</p>
<blockquote>
<div><p>If a single str, can specify multiple <a href="#id1"><span class="problematic" id="id2">``</span></a>Term``s with string
containing space or ‘,’ as separator.</p>
</div></blockquote>
<p><strong>**kwargs</strong> : keyword arguments</p>
<blockquote>
<div><p>keyword arguments as for <code class="docutils literal notranslate"><span class="pre">sympy.symbols</span></code></p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>ts</strong> : <code class="docutils literal notranslate"><span class="pre">Term</span></code> or tuple</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">Term</span></code> instance or list of <code class="docutils literal notranslate"><span class="pre">Term</span></code> instance objects named from <cite>names</cite></p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">terms</span><span class="p">((</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">))</span>
<span class="go">(a, b, c)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">terms</span><span class="p">(</span><span class="s1">&#39;a, b, c&#39;</span><span class="p">)</span>
<span class="go">(a, b, c)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">terms</span><span class="p">(</span><span class="s1">&#39;abc&#39;</span><span class="p">)</span>
<span class="go">abc</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright J. Taylor and others
      <span class="lastupdated">
        Last updated on Sep 24, 2019.
      </span>

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>