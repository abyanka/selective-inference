{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Inference in the full model\n",
    "\n",
    "This is the same example as considered in [Liu et al.](https://arxiv.org/abs/1801.09037) though we\n",
    "do not consider the special analysis in that paper. We let the computer\n",
    "guide us in correcting for selection.\n",
    "\n",
    "The functions `full_model_inference` and `pivot_plot` below are just simulation utilities\n",
    "used to simulate results in least squares regression. The underlying functionality\n",
    "is contained in the function `selectinf.learning.core.infer_full_target`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/Users/jonathantaylor/anaconda/envs/py36/lib/python3.6/site-packages/sklearn/ensemble/weight_boosting.py:29: DeprecationWarning: numpy.core.umath_tests is an internal NumPy module and should not be imported. It will be removed in a future NumPy release.\n",
      "  from numpy.core.umath_tests import inner1d\n",
      "Using TensorFlow backend.\n",
      "/Users/jonathantaylor/anaconda/envs/py36/lib/python3.6/site-packages/tensorflow/python/framework/dtypes.py:455: FutureWarning: Passing (type, 1) or '1type' as a synonym of type is deprecated; in a future version of numpy, it will be understood as (type, (1,)) / '(1,)type'.\n",
      "  _np_qint8 = np.dtype([(\"qint8\", np.int8, 1)])\n",
      "/Users/jonathantaylor/anaconda/envs/py36/lib/python3.6/site-packages/tensorflow/python/framework/dtypes.py:456: FutureWarning: Passing (type, 1) or '1type' as a synonym of type is deprecated; in a future version of numpy, it will be understood as (type, (1,)) / '(1,)type'.\n",
      "  _np_quint8 = np.dtype([(\"quint8\", np.uint8, 1)])\n",
      "/Users/jonathantaylor/anaconda/envs/py36/lib/python3.6/site-packages/tensorflow/python/framework/dtypes.py:457: FutureWarning: Passing (type, 1) or '1type' as a synonym of type is deprecated; in a future version of numpy, it will be understood as (type, (1,)) / '(1,)type'.\n",
      "  _np_qint16 = np.dtype([(\"qint16\", np.int16, 1)])\n",
      "/Users/jonathantaylor/anaconda/envs/py36/lib/python3.6/site-packages/tensorflow/python/framework/dtypes.py:458: FutureWarning: Passing (type, 1) or '1type' as a synonym of type is deprecated; in a future version of numpy, it will be understood as (type, (1,)) / '(1,)type'.\n",
      "  _np_quint16 = np.dtype([(\"quint16\", np.uint16, 1)])\n",
      "/Users/jonathantaylor/anaconda/envs/py36/lib/python3.6/site-packages/tensorflow/python/framework/dtypes.py:459: FutureWarning: Passing (type, 1) or '1type' as a synonym of type is deprecated; in a future version of numpy, it will be understood as (type, (1,)) / '(1,)type'.\n",
      "  _np_qint32 = np.dtype([(\"qint32\", np.int32, 1)])\n",
      "/Users/jonathantaylor/anaconda/envs/py36/lib/python3.6/site-packages/tensorflow/python/framework/dtypes.py:462: FutureWarning: Passing (type, 1) or '1type' as a synonym of type is deprecated; in a future version of numpy, it will be understood as (type, (1,)) / '(1,)type'.\n",
      "  np_resource = np.dtype([(\"resource\", np.ubyte, 1)])\n",
      "R[write to console]: Loaded gbm 2.1.5\n",
      "\n",
      "R[write to console]: randomForest 4.6-14\n",
      "\n",
      "R[write to console]: Type rfNews() to see new features/changes/bug fixes.\n",
      "\n"
     ]
    }
   ],
   "source": [
    "import functools\n",
    "\n",
    "import numpy as np, pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "%matplotlib inline\n",
    "import regreg.api as rr\n",
    "\n",
    "from selectinf.tests.instance import gaussian_instance # to generate the data\n",
    "from selectinf.learning.core import normal_sampler     # our representation of the (limiting) Gaussian data\n",
    "\n",
    "from selectinf.learning.utils import full_model_inference, pivot_plot\n",
    "from selectinf.learning.Rfitters import logit_fit"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We will know generate some data from an OLS regression model and fit the LASSO\n",
    "with a fixed value of $\\lambda$. In the simulation world, we know the\n",
    "true parameters, hence we can then return\n",
    "pivots for each variable selected by the LASSO. These pivots should look\n",
    "(marginally) like a draw from `np.random.sample`. This is the plot below."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "np.random.seed(0) # for replicability\n",
    "\n",
    "def simulate(n=100, \n",
    "             p=20, \n",
    "             s=5, \n",
    "             signal=(0.5, 1), \n",
    "             sigma=2, \n",
    "             alpha=0.1, \n",
    "             B=4000,\n",
    "             verbose=False):\n",
    "\n",
    "    # description of statistical problem\n",
    "\n",
    "    X, y, truth = gaussian_instance(n=n,\n",
    "                                    p=p, \n",
    "                                    s=s,\n",
    "                                    equicorrelated=False,\n",
    "                                    rho=0.5, \n",
    "                                    sigma=sigma,\n",
    "                                    signal=signal,\n",
    "                                    random_signs=True,\n",
    "                                    scale=False)[:3]\n",
    "\n",
    "    dispersion = sigma**2\n",
    "\n",
    "    S = X.T.dot(y)\n",
    "    covS = dispersion * X.T.dot(X)\n",
    "    \n",
    "    # this declares our target as linear in S where S has a given covariance\n",
    "    sampler = normal_sampler(S, covS) \n",
    "\n",
    "    def base_algorithm(XTX, lam, sampler):\n",
    "\n",
    "        p = XTX.shape[0]\n",
    "        success = np.zeros(p)\n",
    "\n",
    "        loss = rr.quadratic_loss((p,), Q=XTX)\n",
    "        pen = rr.l1norm(p, lagrange=lam)\n",
    "\n",
    "        scale = 0.\n",
    "        noisy_S = sampler(scale=scale)\n",
    "        loss.quadratic = rr.identity_quadratic(0, 0, -noisy_S, 0)\n",
    "        problem = rr.simple_problem(loss, pen)\n",
    "        soln = problem.solve(max_its=50, tol=1.e-6)\n",
    "        success += soln != 0\n",
    "        \n",
    "        return set(np.nonzero(success)[0])\n",
    "\n",
    "    XTX = X.T.dot(X)\n",
    "    XTXi = np.linalg.inv(XTX)\n",
    "    resid = y - X.dot(XTXi.dot(X.T.dot(y)))\n",
    "    dispersion = np.linalg.norm(resid)**2 / (n-p)\n",
    "                         \n",
    "    lam = 3.5 * np.sqrt(n)\n",
    "    selection_algorithm = functools.partial(base_algorithm, XTX, lam)\n",
    "    if verbose:\n",
    "        print(selection_algorithm(sampler))\n",
    "    # run selection algorithm\n",
    "\n",
    "    return full_model_inference(X,\n",
    "                                y,\n",
    "                                truth,\n",
    "                                selection_algorithm,\n",
    "                                sampler,\n",
    "                                success_params=(1, 1),\n",
    "                                B=B,\n",
    "                                fit_probability=logit_fit,\n",
    "                                fit_args={'df':20})"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Let's take a look at what we get as a return value:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "{18, 13, 14}\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "Index(['B', 'alpha', 'coverage', 'id', 'length', 'lower', 'nfeature',\n",
       "       'nsample', 'pivot', 'pvalue', 'target', 'upper', 'variable',\n",
       "       'bonferroni_coverage', 'bonferroni_length', 'bonferroni_lower',\n",
       "       'bonferroni_pvalue', 'bonferroni_upper', 'naive_coverage',\n",
       "       'naive_length', 'naive_lower', 'naive_pivot', 'naive_pvalue',\n",
       "       'naive_upper'],\n",
       "      dtype='object')"
      ]
     },
     "execution_count": 3,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "while True:\n",
    "    df = simulate(verbose=True)\n",
    "    if df is not None:\n",
    "        break\n",
    "df.columns"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "dfs = []\n",
    "for i in range(30):\n",
    "    df = simulate()\n",
    "    if df is not None:\n",
    "        dfs.append(df)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "fig = plt.figure(figsize=(8, 8))\n",
    "results = pd.concat(dfs)\n",
    "pivot_plot(results, fig=fig);"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "jupytext": {
   "cell_metadata_filter": "all,-slideshow",
   "formats": "ipynb,Rmd"
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.2"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
